<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · NNFEM</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="NNFEM logo"/></a><div class="docs-package-name"><span class="docs-autofit">NNFEM</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Getting Started</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Elements-1"><span>Elements</span></a></li><li><a class="tocitem" href="#Materials-1"><span>Materials</span></a></li><li><a class="tocitem" href="#Assembly-1"><span>Assembly</span></a></li><li><a class="tocitem" href="#Solvers-1"><span>Solvers</span></a></li><li><a class="tocitem" href="#Utilities-1"><span>Utilities</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/kailaix/NNFEM.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference-1"><a class="docs-heading-anchor" href="#API-Reference-1">API Reference</a><a class="docs-heading-anchor-permalink" href="#API-Reference-1" title="Permalink"></a></h1><h2 id="Elements-1"><a class="docs-heading-anchor" href="#Elements-1">Elements</a><a class="docs-heading-anchor-permalink" href="#Elements-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NNFEM.FiniteStrainContinuum" href="#NNFEM.FiniteStrainContinuum"><code>NNFEM.FiniteStrainContinuum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FiniteStrainContinuum</code></pre><p>Implements the finite strain element. </p><ul><li><code>eledim</code>: spatial dimension of the element (default = 2).</li><li><code>mat</code>: constitutive law, a length <code>#elem</code> vector of materials such as <a href="@ref"><code>PlaneStress</code></a></li><li><code>elnodes</code>: the node indices in this finite element, an integer array </li><li><code>props</code>: property dictionary </li><li><code>coords</code>: coordinates of the vertices of the element</li><li><code>dhdx</code>, <code>weights</code>, <code>hs</code>: data for integral </li><li><code>stress</code>: stress at each quadrature points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/elements/FiniteStrainContinuum.jl#L4-L16">source</a></section></article><h2 id="Materials-1"><a class="docs-heading-anchor" href="#Materials-1">Materials</a><a class="docs-heading-anchor-permalink" href="#Materials-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NNFEM.PlaneStrain" href="#NNFEM.PlaneStrain"><code>NNFEM.PlaneStrain</code></a> — <span class="docstring-category">Type</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/materials/PlaneStrain.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.PlaneStressIncompressibleRivlinSaunders" href="#NNFEM.PlaneStressIncompressibleRivlinSaunders"><code>NNFEM.PlaneStressIncompressibleRivlinSaunders</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Pascon, João Paulo.  &quot;Large deformation analysis of plane-stress hyperelastic problems via triangular membrane finite elements.&quot;  International Journal of Advanced Structural Engineering (2019): 1-20.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/materials/PlaneStressIncompressibleRivlinSaunders.jl#L3-L7">source</a></section></article><h2 id="Assembly-1"><a class="docs-heading-anchor" href="#Assembly-1">Assembly</a><a class="docs-heading-anchor-permalink" href="#Assembly-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NNFEM.assembleInternalForce" href="#NNFEM.assembleInternalForce"><code>NNFEM.assembleInternalForce</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Numerically assemble internal force vector, compute local internal force f_int 
from domain.state and then assemble to F_int
- &#39;globdat&#39;: GlobalData
- &#39;domain&#39;: Domain, finite element domain, for data structure
- &#39;Δt&#39;:  Float64, current time step size
Return F_int: Float64[neqs], internal force vector</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/fem/assembly.jl#L5-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.assembleMassMatrix!-Tuple{GlobalData,Domain}" href="#NNFEM.assembleMassMatrix!-Tuple{GlobalData,Domain}"><code>NNFEM.assembleMassMatrix!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute constant sparse mass matrix
due to the time-dependent Dirichlet boundary condition
mass matrix = M,    MID
              MID&#39;  MDD

- &#39;globdat&#39;: GlobalData
- &#39;domain&#39;: Domain, finite element domain, for data structure
here M is Float64[neqns, neqns]
     MID is Float64[neqns, nd1]
     Mlumped is Float64[neqns]

update M and MID and Mlumpe in globaldat</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/fem/assembly.jl#L235-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.assembleStiffAndForce" href="#NNFEM.assembleStiffAndForce"><code>NNFEM.assembleStiffAndForce</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Numerically assemble internal force vector and stiffness matrix, compute local internal force f_int/ 
stiffness matrix Slocal from domain.state and then assemble to F_int/Ksparse
- &#39;globdat&#39;: GlobalData
- &#39;domain&#39;: Domain, finite element domain, for data structure
- &#39;Δt&#39;:  Float64, current time step size
Return F_int: Float64[neqs], internal force vector
Return Ksparse: Float64[neqs, neqns], sparse stiffness matrix</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/fem/assembly.jl#L142-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.tfAssembleInternalForce-Tuple{Domain,Function,PyCall.PyObject,PyCall.PyObject,PyCall.PyObject,PyCall.PyObject}" href="#NNFEM.tfAssembleInternalForce-Tuple{Domain,Function,PyCall.PyObject,PyCall.PyObject,PyCall.PyObject,PyCall.PyObject}"><code>NNFEM.tfAssembleInternalForce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Tensorflow version of assembling internal force vector, compute local internal 
force f_int and then assemble to F_int, which generates inverse problem automatically.

- &#39;domain&#39;: Domain, finite element domain, for data structure
- &#39;nn&#39;: Function strain -&gt; stress, neural network constitutive law function 
- &#39;E_all&#39;: PyObject(Float64)[neles*nGauss, nstrains], neles*nGauss is the number of Gaussian quadrature points, 
           nstrain is the number of strain components. All strains for the current time-step
- &#39;DE_all&#39;: PyObject(Float64)[neles*nGauss, nstrains], neles*nGauss is the number of Gaussian quadrature points, 
            nstrain is the number of strain components. All strains for the previous time-step
- &#39;w∂E∂u_all&#39;: PyObject(Float64)[neles*nGauss, ndofs_per_element, nstrains], neles*nGauss is the number of Gaussian quadrature points, 
               ndofs_per_element is the number of freedoms per element, nstrain is the number of strain components.
               Multiplication of the Gaussian weight and ∂E∂u^T for current time-step, 
        
- &#39;σ0_all&#39;: PyObject(Float64)[neles*nGauss, nstrains], neles*nGauss is the number of Gaussian quadrature points, 
nstrain is the number of strain components.  All stresses for the last time-step

Return: internal force vector F_int, PyObject(Float64)[neqns] and the predicted stresses at the 
        current step σ_all, PyObject(Float64)[neles*nGauss, nstrains]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/fem/assembly.jl#L44-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.Domain" href="#NNFEM.Domain"><code>NNFEM.Domain</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Domain</p><p>Date structure for the computatational domain</p><ul><li><p><code>nnodes</code>: Int64, number of nodes (each quadratical quad element has 9 nodes)</p></li><li><p><code>nodes</code>: Float64[nnodes, ndims], coordinate array of all nodes</p></li><li><p><code>neles</code>: number of elements </p></li><li><p><code>elements</code>: Element[neles], element array, each element is a struct </p></li><li><p><code>ndims</code>: Int64, dimension of the problem space </p></li><li><p><code>state</code>: Float64[nnodes*ndims] current displacement of all nodal freedoms, Float64[1:nnodes] are for the first direction.</p></li><li><p><code>Dstate</code>: Float64[nnodes*ndims] previous displacement of all nodal freedoms, Float64[1:nnodes] are for the first direction.</p></li><li><p>&#39;LM&#39;:  Int64[neles][ndims], LM(e,d) is the global equation number(active freedom number) of element e&#39;s d th freedom,         -1 means fixed (time-independent) Dirichlet        -2 means time-dependent Dirichlet</p></li><li><p>&#39;DOF&#39;: Int64[neles][ndims], DOF(e,d) is the global freedom number of element e&#39;s d th freedom</p></li><li><p>&#39;ID&#39;:  Int64[nnodes, ndims], ID(n,d) is the equation number(active freedom number) of node n&#39;s dth freedom,         -1 means fixed (time-independent) Dirichlet        -2 means time-dependent Dirichlet</p></li><li><p>&#39;neqs&#39;:  Int64,  number of equations or active freedoms</p></li><li><p>&#39;eq<em>to</em>dof&#39;:  Int64[neqs], map from to equation number(active freedom number) to the freedom number (Int64[1:nnodes] are for the first direction) </p></li><li><p>&#39;dof<em>to</em>eq&#39;:  Bool[nnodes*ndims], map from freedom number(Int64[1:nnodes] are for the first direction) to booleans (active freedoms(equation number) are true)</p></li><li><p>&#39;EBC&#39;:  Int64[nnodes, ndims], EBC[n,d] is the displacement boundary condition of node n&#39;s dth freedom,          -1 means fixed(time-independent) Dirichlet boundary nodes          -2 means time-dependent Dirichlet boundary nodes</p></li><li><p>&#39;g&#39;:  Float64[nnodes, ndims], values for fixed(time-independent) Dirichlet boundary conditions of node n&#39;s dth freedom,</p></li><li><p>&#39;FBC&#39;: Int64[nnodes, ndims], FBC[n,d] is the force load boundary condition of node n&#39;s dth freedom,          -1 means constant(time-independent) force load boundary nodes          -2 means time-dependent force load boundary nodes</p></li><li><p>&#39;fext&#39;:  Float64[neqs], constant(time-independent) force load boundary conditions for these freedoms</p></li><li><p>&#39;time&#39;: Float64, current time</p></li><li><p>&#39;npoints&#39;: Int64, number of points (each quadratical quad element has 4 points, npoints==nnodes, when porder==1)</p></li><li><p>&#39;node<em>to</em>point&#39;: Int64[nnodes]:map from node number to point point, -1 means the node is not a geometry point</p></li><li><p>&#39;ii_stiff&#39;: Int64[], first index of the sparse matrix representation of the stiffness matrix</p></li><li><p>&#39;jj_stiff&#39;: Int64[], second index of the sparse matrix representation of the stiffness matrix</p></li><li><p>&#39;vv<em>stiff</em>ele_indptr&#39;: Int64[], Int64[e] is the first index entry for the e&#39;s element of the sparse matrix representation of the stiffness matrix</p></li><li><p>&#39;vv_stiff&#39;: Float64[], values of the sparse matrix representation of the stiffness matrix</p></li><li><p>&#39;ii<em>dfint</em>dstress&#39;: Int64[], first index of the sparse matrix representation of the dfint_dstress matrix </p></li><li><p>&#39;jj<em>dfint</em>dstress&#39;: Int64[], second index of the sparse matrix representation of the dfint_dstress matrix</p></li><li><p>&#39;vv<em>dfint</em>dstress<em>ele</em>indptr&#39;: Int64[], Int64[e] is the first index entry for the e&#39;s element of the sparse matrix representation of the dfint_dstress matrix</p></li><li><p>&#39;vv<em>dfint</em>dstress&#39;: Float64[], values of the sparse matrix representation of the dfint_dstress matrix </p></li><li><p>&#39;ii<em>dstrain</em>dstate&#39;: Int64[], first index of the sparse matrix representation of the dstrain_dstate matrix</p></li><li><p>&#39;jj<em>dstrain</em>dstate&#39;: Int64[], second index of the sparse matrix representation of the dstrain_dstate matrix</p></li><li><p>&#39;vv<em>dstrain</em>dstate<em>ele</em>indptr&#39;: Int64[], Int64[e] is the first index entry for the e&#39;s element of the sparse matrix representation of the stiffness matrix</p></li><li><p>&#39;vv<em>dstrain</em>dstate&#39;: Float64[], values of the sparse matrix representation of the dstrain_dstate matrix</p></li><li><p>&#39;history&#39;: Dict{String, Array{Array{Float64}}}, dictionary between string and its time-histories quantity Float64[ntime][]</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/fem/fem.jl#L48-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.Domain-Tuple{Array{Float64,N} where N,Array,Int64,Array{Int64,N} where N,Array{Float64,N} where N,Array{Int64,N} where N,Array{Float64,N} where N}" href="#NNFEM.Domain-Tuple{Array{Float64,N} where N,Array,Int64,Array{Int64,N} where N,Array{Float64,N} where N,Array{Int64,N} where N,Array{Float64,N} where N}"><code>NNFEM.Domain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Creating a finite element domain

- `nodes`: Float64[nnodes, ndims], coordinate array of all nodes
- `elements`: Element[neles], element array, each element is a struct 
- `ndims`: Int64, dimension of the problem space 
- &#39;EBC&#39;:  Int64[nnodes, ndims], EBC[n,d] is the displacement boundary condition of node n&#39;s dth freedom,
       -1 means fixed(time-independent) Dirichlet boundary nodes
       -2 means time-dependent Dirichlet boundary nodes
- &#39;g&#39;:  Float64[nnodes, ndims], values for fixed(time-independent) Dirichlet boundary conditions of node n&#39;s dth freedom,
- &#39;FBC&#39;: Int64[nnodes, ndims], FBC[n,d] is the force load boundary condition of node n&#39;s dth freedom,
       -1 means constant(time-independent) force load boundary nodes
       -2 means time-dependent force load boundary nodes
- &#39;f&#39;:  Float64[nnodes, ndims], values for constant(time-independent) force load boundary conditions of node n&#39;s dth freedom,

Return: Domain, the finite element domain</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/fem/fem.jl#L150-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.GlobalData" href="#NNFEM.GlobalData"><code>NNFEM.GlobalData</code></a> — <span class="docstring-category">Type</span></header><section><div><p>GlobalData</p><p>Store data for finite element update, assume the problem has n freedoms</p><ul><li><code>state</code>: Float64[n],  displacement array at the current time, only for active freedoms,   the ordering is based on the equation number, here ndims=2 is the dimension of the problem space</li><li><code>state</code>: Float64[n],  displacement array at the previous time</li><li><code>velo</code>: Float64[n],  velocity array at the current </li><li><code>acce</code>: Float64[n],  acceleration array at the current </li><li><code>time</code>: float, current time</li><li><code>M</code>: Float64[n,n] spares mass matrix</li><li><code>Mlumped</code>: Float64[n] lumped mass array</li><li><code>MID</code>: Float64[n, nd1] off-diagonal part of the mass matrix, between the active freedoms and the time-dependent Dirichlet freedoms, assume there are nd time-dependent Dirichlet freedoms</li><li><code>EBC_func</code>: function Float64:t-&gt; Float64[n_d1] float array, time-dependent Dirichlet boundary condition (ordering is direction first then node number, u1, u3, ... v1, v4 ...)</li><li><code>FBC_func</code>: function Float64:t-&gt; Float64[n_t1] float array, time-dependent load boundary condition (ordering is direction first then node number, u1, u3, ... v1, v4 ...)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/fem/fem.jl#L5-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.setGeometryPoints!-Tuple{Domain,Int64,Array{Int64,N} where N}" href="#NNFEM.setGeometryPoints!-Tuple{Domain,Int64,Array{Int64,N} where N}"><code>NNFEM.setGeometryPoints!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">In the constructor 
Update the node_to_point map 

- `self`: Domain, finit element domain
- &#39;npoints&#39;: Int64, number of points (each quadratical quad element has 4 points, npoints==nnodes, when porder==1)
- &#39;node_to_point&#39;: Int64[nnodes]:map from node number to point point, -1 means the node is not a geometry point</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/fem/fem.jl#L203-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.setNeumannBoundary!-Tuple{Domain,Array{Int64,N} where N,Array{Float64,N} where N}" href="#NNFEM.setNeumannBoundary!-Tuple{Domain,Array{Int64,N} where N,Array{Float64,N} where N}"><code>NNFEM.setNeumannBoundary!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">In the constructor
Update the external force vector fext
- &#39;self&#39;: Domain
- &#39;FBC&#39;: Int64[nnodes, ndims], FBC[n,d] is the force load boundary condition of node n&#39;s dth freedom,
       -1 means constant(time-independent) force load boundary nodes
       -2 means time-dependent force load boundary nodes
- &#39;f&#39;:  Float64[nnodes, ndims], values for constant(time-independent) force load boundary conditions of node n&#39;s dth freedom,</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/fem/fem.jl#L327-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.updateDomainStateBoundary!-Tuple{Domain,GlobalData}" href="#NNFEM.updateDomainStateBoundary!-Tuple{Domain,GlobalData}"><code>NNFEM.updateDomainStateBoundary!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Update time dependent boundary of state fext in Domain based on the time-dependent boundary functions in GlobalData.</p><ul><li>&#39;self&#39;: Domain</li><li>&#39;globaldat&#39;: GlobalData</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/fem/fem.jl#L407-L411">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.updateStates!-Tuple{Domain,GlobalData}" href="#NNFEM.updateStates!-Tuple{Domain,GlobalData}"><code>NNFEM.updateStates!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">At each time step
Update the state and Dstate in Domain from GlobalData
state and Dstate in GlobalData are only for active freedoms (equations)
state and Dstate in Domain are only for all freedoms, they are used for constructing the internal force and/or stiffness matrix
update the state and acc history of the Domain
- &#39;self&#39;: Domain
- &#39;globaldat&#39;: GlobalData</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/fem/fem.jl#L355-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.assembleSparseMatrixPattern!-Tuple{Domain}" href="#NNFEM.assembleSparseMatrixPattern!-Tuple{Domain}"><code>NNFEM.assembleSparseMatrixPattern!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Compute constant stiff, dfint_dstress, dstrain_dstate matrix patterns
- &#39;self&#39;: Domain</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/fem/fem.jl#L530-L533">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.commitHistory-Tuple{Domain}" href="#NNFEM.commitHistory-Tuple{Domain}"><code>NNFEM.commitHistory</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Update current step strain, stress in the history map of the Domain
strain and stress are both Float[ngp, nstrain], ngp is the number of Gaussian quadrature point
nstrain=1 for 1D and nstrain = 3 for 2D 
The strain is in Voigt notation</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/fem/fem.jl#L219-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.getCoords-Tuple{Domain,Array{Int64,N} where N}" href="#NNFEM.getCoords-Tuple{Domain,Array{Int64,N} where N}"><code>NNFEM.getCoords</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Get the coordinates of several nodes (possibly in one element)
- &#39;self&#39;: Domain
- &#39;el_nodes&#39;: Int64[n], node array

Return: Float64[n, ndims], the coordinates of these nodes</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/fem/fem.jl#L471-L477">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.getDofs-Tuple{Domain,Int64}" href="#NNFEM.getDofs-Tuple{Domain,Int64}"><code>NNFEM.getDofs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Get the global freedom numbers of the element
- &#39;self&#39;: Domain
- &#39;iele&#39;: Int64, element number

Return: Int64[], the global freedom numbers of the element (ordering in local element ordering)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/fem/fem.jl#L482-L489">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.getDstate-Tuple{Domain,Array{Int64,N} where N}" href="#NNFEM.getDstate-Tuple{Domain,Array{Int64,N} where N}"><code>NNFEM.getDstate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Get the displacements of several nodes (possibly in one element) at the previous time step
- &#39;self&#39;: Domain
- &#39;el_nodes&#39;: Int64[n], node array

Return: Float64[n, ndims], the displacements of these nodes at the previous time step</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/fem/fem.jl#L518-L524">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.getEqns-Tuple{Domain,Int64}" href="#NNFEM.getEqns-Tuple{Domain,Int64}"><code>NNFEM.getEqns</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Get the equation numbers(active freedom numbers) of the element
- &#39;self&#39;: Domain
- &#39;iele&#39;: Int64, element number

Return: Int64[], the equation numbers(active freedom numbers) of the element (ordering in local element ordering)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/fem/fem.jl#L494-L501">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.getExternalForce!-Tuple{Domain,GlobalData,Array{Float64,N} where N}" href="#NNFEM.getExternalForce!-Tuple{Domain,GlobalData,Array{Float64,N} where N}"><code>NNFEM.getExternalForce!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Compute external force vector, including external force load and time-dependent Dirichlet boundary conditions
The function needs to be called after
function updateDomainStateBoundary!(self::Domain, globaldat::GlobalData)
which computes the external force vector from external force load

- &#39;self&#39;: Domain
- &#39;globaldat&#39;: GlobalData
- &#39;fext&#39;: Float64[neqs], container for the external force vector

return external force vector at the present step</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/fem/fem.jl#L447-L458">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.getState-Tuple{Domain,Array{Int64,N} where N}" href="#NNFEM.getState-Tuple{Domain,Array{Int64,N} where N}"><code>NNFEM.getState</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Get the displacements of several nodes (possibly in one element)
- &#39;self&#39;: Domain
- &#39;el_nodes&#39;: Int64[n], node array

Return: Float64[n, ndims], the displacements of these nodes</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/fem/fem.jl#L507-L513">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.setDirichletBoundary!-Tuple{Domain,Array{Int64,N} where N,Array{Float64,N} where N}" href="#NNFEM.setDirichletBoundary!-Tuple{Domain,Array{Int64,N} where N,Array{Float64,N} where N}"><code>NNFEM.setDirichletBoundary!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">In the constructor 
Update the fixed (time-independent Dirichlet boundary) state entries 
Build LM, and DOF array
- &#39;self&#39;: Domain
- &#39;EBC&#39;:  Int64[nnodes, ndims], EBC[n,d] is the displacement boundary condition of node n&#39;s dth freedom,
       -1 means fixed(time-independent) Dirichlet boundary nodes
       -2 means time-dependent Dirichlet boundary nodes
- &#39;g&#39;:  Float64[nnodes, ndims], values for fixed(time-independent) Dirichlet boundary conditions of node n&#39;s dth freedom,
&#39;&#39;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/fem/fem.jl#L264-L274">source</a></section></article><h2 id="Solvers-1"><a class="docs-heading-anchor" href="#Solvers-1">Solvers</a><a class="docs-heading-anchor-permalink" href="#Solvers-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NNFEM.DynamicMatLawLoss-Tuple{Domain,Array{Float64,N} where N,Array{Float64,N} where N,Array{Float64,N} where N,Function}" href="#NNFEM.DynamicMatLawLoss-Tuple{Domain,Array{Float64,N} where N,Array{Float64,N} where N,Array{Float64,N} where N,Function}"><code>NNFEM.DynamicMatLawLoss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">- &#39;domain&#39;: Domain, finite element domain, for data structure
- &#39;E_all&#39;:  Float64[NT+1, neles*nGauss, nstrains], all strains for the whole simulation from training data
- &#39;w∂E∂u_all&#39;: Float64[NT+1, neles*nGauss, ndofs_per_element, nstrains], 
            multiplication of the Gaussian weight and ∂E∂u^T for the whole simulation from training data 
- &#39;F_tot&#39;: Float64[NT, neqs] approximated internal force for the whole simulation, from time n=1 to time n=NT

form the loss function, based on dynamic equilibrium 
    (Mddu + fint(NN, E, DE) + MIDddu_bc = fext

we have  
    F_tot  = fext - MIDddu_bc - Mddu
loss = ∑ ||fint(NN, E, DE) - F_tot||^2

todo
We assume the time step is constant for the training data</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/solvers/NNSolver.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.DynamicMatLawLoss-Union{Tuple{S}, Tuple{T}, Tuple{Domain,GlobalData,Array{T,N} where N,Array{S,N} where N,Function,Float64}} where S where T" href="#NNFEM.DynamicMatLawLoss-Union{Tuple{S}, Tuple{T}, Tuple{Domain,GlobalData,Array{T,N} where N,Array{S,N} where N,Function,Float64}} where S where T"><code>NNFEM.DynamicMatLawLoss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">- &#39;domain&#39;: Domain,  finite element domain
- &#39;globdat&#39;: GlobalData,  finite element data structure
- &#39;state_history&#39;: Float64[NT+1][ndofs], displace history of all time steps and all nodes, including time 0
                hcat(state_history...) gives a matrix of Float64[NT+1, ndofs]
- &#39;fext_history&#39;: Float64[NT+1][neqns] or Float64[NT][neqns]: external force load of all time steps and all equations, 
                with or without the initial step
                hcat(fext_history...) gives a matrix of size(neqns, NT+1)
nn: Neural network
Δt: time step size

compute loss function from state and external force history</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/solvers/NNSolver.jl#L167-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.LSfittingStress-Tuple{Domain,GlobalData,Array{Float64,N} where N,Array{Float64,N} where N,Float64,String}" href="#NNFEM.LSfittingStress-Tuple{Domain,GlobalData,Array{Float64,N} where N,Array{Float64,N} where N,Float64,String}"><code>NNFEM.LSfittingStress</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Fit the stress from the strain and external load conditions, 
For quadratic element, nx, ny, ... elements in each direction
The number of equations are neqs ≈ 2*(2nx + 1)*(2ny + 1)
Linear approach : Assume the stress in each element is constant, the number of unknows are 3*nx*ny
Constant approach: Assume the stress in each element is linear, the number of unknows are 3*(nx+1)*(ny+1) on each nodes
Least Square problem is solving for stress

- &#39;domain&#39;: Domain 
- &#39;globdat&#39;: GlobalData
- &#39;state_history&#39;: Float64[NT+1, ndofs], displacement fields for each freedoms
- &#39;F_ext&#39;: Float64[neqns, NT+1] or Float64[neqns, NT+1], external force vector for each equations
- &#39;Δt&#39;: Float64, time step size
- &#39;method&#39;: String &quot;Constant&quot; or &quot;Linear&quot; for Constant approach or Linear approach

Return: 
- &#39;E_all&#39;:  Float64[NT+1, neles*ngps_per_elem, nstrain], strain fields
- &#39;S_all&#39;:  Float64[NT+1, neles*ngps_per_elem, nstrain], fitted stress fields at each Gaussian quadratic point

Remark: Turss 1D requires method == &quot;Constant&quot;, otherwise the system is under constraint</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/solvers/NNSolver.jl#L528-L548">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.LSfittingStressHelper-Tuple{Any,Array{Float64,N} where N,String}" href="#NNFEM.LSfittingStressHelper-Tuple{Any,Array{Float64,N} where N,String}"><code>NNFEM.LSfittingStressHelper</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the Fint, dFint<em>dS</em>comp, E<em>all, S</em>all and dfint<em>dstress, based on the state in domain and the stress in S</em>comp</p><ul><li>&#39;domain&#39;: Domain</li><li>&#39;S_comp&#39;: Float64[neles, nstrain] or Float64[npoints, nstrain], the stresses in each element(Constant) or at each geometric point(Linear)</li><li>&#39;method&#39;: String &quot;Constant&quot; or &quot;Linear&quot; for Constant approach or Linear approach</li></ul><p>Return      Fint: Float64[neqns], constructed from state in domain     dFint<em>dS</em>comp: Float64[neqs,  size(S<em>comp,1)*nstrain], sparse matrix representation     E</em>all: Float64[neles<em>ngps<em>per</em>elem, nstrain], strains at each Gaussian quadrature point ,constructed from state in domain     S_all: Float64[neles</em>ngps<em>per</em>elem, nstrain], stresses at each Gaussian quadrature point ,constructed from S_comp</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/solvers/NNSolver.jl#L381-L393">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.preprocessing-Tuple{Domain,GlobalData,Array{Float64,N} where N,Float64}" href="#NNFEM.preprocessing-Tuple{Domain,GlobalData,Array{Float64,N} where N,Float64}"><code>NNFEM.preprocessing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Postprocess the data from domain.history and F_ext
- &#39;domain&#39;: Domain, domain.history[&quot;state&quot;] is Float64[NT+1][ndofs] 
- &#39;globdat&#39;: GlobalData, for mass matrix
- &#39;F_ext&#39;: Float64[neqns, NT+1] or Float64[neqns, NT], external force history with/without the initial step
- &#39;Δt&#39;: Float64, time step size

Return:
- &#39;F_tot&#39;: Float64[NT, neqns], approxmiated internal force
- &#39;E_all&#39;: Float64[NT+1, neles*nGauss, nstrains], all strains for the whole simulation from training data
- &#39;w∂E∂u_all&#39;: Float64[NT+1, neles*nGauss, neqns_per_elem, nstrains], multiplication of the Gaussian weight and ∂E∂u^T 
for the whole simulation from training data 


todo
We assume the time step is constant for the training data</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/solvers/NNSolver.jl#L207-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.AdaptiveSolver-NTuple{6,Any}" href="#NNFEM.AdaptiveSolver-NTuple{6,Any}"><code>NNFEM.AdaptiveSolver</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Adaptive Solver, solve the whole process, if this step fails, redo the step with half of
the time step size, when there are continuing 5 successful steps, double the step size when dt &lt; T/NT

- &#39;solvername&#39;: String,  so far only NewmarkSolver is supported
- &#39;globdat&#39;, GlobalData
- &#39;domain&#39;, Domain
- &#39;T&#39;, Float64, total simulation time
- &#39;NT&#39;, Int64, planned time steps
- &#39;args&#39;, Dict{String, Value}, arguments for the solver


return globdat, domain, ts, here ts is Float64[nteps+1]</code></pre><p>todo For the first time step a<em>0 = M^{-1}(- f^{int}(u</em>0) + f^{ext}_0)</p><p>We assume globdat.acce[:] = a_0 and so far initialized to 0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/solvers/Solvers.jl#L286-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.ExplicitSolver-Tuple{Any,Any,Any}" href="#NNFEM.ExplicitSolver-Tuple{Any,Any,Any}"><code>NNFEM.ExplicitSolver</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Central Difference explicit solver</p><ul><li>&#39;Δt&#39;: Float64,  time step size </li><li>&#39;globdat&#39;, GlobalData</li><li>&#39;domain&#39;, Domain</li></ul><p>Central Difference explicit solver for <code>M a + fint(u) = fext(u)</code>, with lumped mass matrix (MID = 0) <code>a</code>, <code>v</code>, <code>u</code> are acceleration, velocity and displacement</p><div>\[\begin{align}
u_{n+1} =&amp; u_n + dtv_n + dt^2/2 a_n \\
v_{n+1} =&amp; v_n + dt/2(a_n + a_{n+1}) \\
M a_{n+1} + f^{int}(u_{n+1}) =&amp; f^{ext}_{n+1} \\
M a_{n+1} =&amp; f^{ext}_{n+1} - f^{int}(u_{n+1}) \\
\end{align}\]</div><p>use the current states <code>a</code>, <code>v</code>, <code>u</code>, <code>time</code> in globdat, and update these stetes to next time step update domain history </p><p>todo For the first time step a<em>0 = M^{-1}(- f^{int}(u</em>0) + f^{ext}_0)</p><p>We assume globdat.acce[:] = a_0 and so far initialized to 0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/solvers/Solvers.jl#L3-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.NewmarkSolver" href="#NNFEM.NewmarkSolver"><code>NNFEM.NewmarkSolver</code></a> — <span class="docstring-category">Function</span></header><section><div><p>NewmarkSolver (Generalized-alpha) implicit solver</p><ul><li>&#39;Δt&#39;: Float64,  time step size </li><li>&#39;globdat&#39;, GlobalData</li><li>&#39;domain&#39;, Domain</li><li>&#39;αm&#39;, Float64</li><li>&#39;αf&#39;, Float64 </li><li>&#39;ε&#39;, Float64, absolute error for Newton convergence</li><li>&#39;ε0&#39;, Float64, relative error for Newton convergence</li><li>&#39;maxiterstep&#39;, Int64, maximum iteration number for Newton convergence</li><li>&#39;η&#39;, Float64, Newton step size at the first iteration</li><li>&#39;failsafe&#39;, Bool, if failsafe is true, when the Newton fails to converge,              revert back, and return false</li></ul><p>Implicit solver for <span>$Ma  + fint(u) = fext$</span> <span>$a$</span>, <span>$v$</span>, <span>$u$</span> are acceleration, velocity and displacement respectively.</p><div>\[u_{n+1} = u_n + dtv_n + dt^2/2 ((1 - 2\beta)a_n + 2\beta a_{n+1})
v_{n+1} = v_n + dt((1 - \gamma)a_n + \gamma a_{n+1})
2\beta = 0.5*(1 - αm + αf)^2
\gamma = 0.5 - \alpha_m + \alpha_f
\]</div><div>\[a_{n+1-\alpha_m} = (1-\alpha_m)a_{n+1} + \alpha_m a_{n} 
v_{n+1-\alpha_f} = (1-\alpha_f)v_{n+1} + \alpha_f v_{n}
u_{n+1-\alpha_f} = (1-\alpha_f)u_{n+1} + \alpha_f u_{n}
M a_{n+1-\alpha_m} + f^{int}(u_{n+1-\alpha_f}) = f^{ext}_{n+1-\alpha_f}\]</div><p>&#39;a_{n+1}&#39; is solved by </p><div>\[M ((1-\alpha_m)a_{n+1} + \alpha_m a_{n})  
+ f^{int}((1-\alpha_f)(u_n + dtv_n + dt^2/2 ((1 - 2\beta)a_n + 2\beta a_{n+1}))) + \alpha_f u_{n}) 
= f^{ext}_{n+1-\alpha_f}\]</div><p>As for &#39;\alpha<em>m&#39; and &#39;\alpha</em>f&#39;</p><div>\[\alpha_m = (2\rho_{\infty} - 1)/(\rho_{\infty} + 1)
\alpha_f = \rho_{\infty}/(\rho_{\infty} + 1)\]</div><p>use the current states <code>a</code>, <code>v</code>, <code>u</code>, <code>time</code> in globdat, and update these stetes to next time step update domain history, when failsafe is true, and Newton&#39;s solver fails, nothing will be changed.</p><p>todo For the first time step a<em>0 = M^{-1}(- f^{int}(u</em>0) + f^{ext}_0)</p><p>We assume globdat.acce[:] = a_0 and so far initialized to 0 We also assume the external force is conservative (it does not depend on the current deformation)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/solvers/Solvers.jl#L73-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.StaticSolver" href="#NNFEM.StaticSolver"><code>NNFEM.StaticSolver</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Static implicit solver</p><ul><li>&#39;globdat&#39;, GlobalData</li><li>&#39;domain&#39;, Domain</li><li>&#39;loaditerstep&#39;, Int64, load stepping steps</li><li>&#39;ε&#39;, Float64, absolute error for Newton convergence</li><li>&#39;maxiterstep&#39;, Int64, maximum iteration number for Newton convergence</li></ul><p>Solver for <span>$fint(u) = fext$</span> with load stepping, <span>$u$</span> is the displacement. Iteratively solve u_{i}</p><div>\[f^{int}(u_i) = i/loaditerstep f^{ext}\]</div><p>todo We assume the external force is conservative (it does not depend on the current deformation)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/solvers/Solvers.jl#L232-L249">source</a></section></article><h2 id="Utilities-1"><a class="docs-heading-anchor" href="#Utilities-1">Utilities</a><a class="docs-heading-anchor-permalink" href="#Utilities-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NNFEM.orthotropic_H-Tuple{PyCall.PyObject}" href="#NNFEM.orthotropic_H-Tuple{PyCall.PyObject}"><code>NNFEM.orthotropic_H</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">orthotropic_H(y::PyObject)
orthotropic_H(o::Array)</code></pre><p>Creates a symmetric matrix from 4 parameters</p><div>\[H = \begin{bmatrix}
y_1 &amp; y_2 &amp; 0\\ 
y_2 &amp; y_3 &amp; 0 \\ 
0 &amp; 0 &amp; y_4
\end{bmatrix}\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/utils/matrix.jl#L29-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.spd_Chol_Orth-Tuple{Array}" href="#NNFEM.spd_Chol_Orth-Tuple{Array}"><code>NNFEM.spd_Chol_Orth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">spd_Chol_Orth(o::Array)
spd_Chol_Orth(o::PyObject)</code></pre><p>Creates a SPD matrix from 4 scalars. </p><div>\[A = LL&#39;\]</div><p>where</p><div>\[L = \begin{bmatrix}
o_1 &amp; &amp; \\
o_2 &amp; o_3 &amp; \\
 &amp;  &amp; o_4 
\end{bmatrix}\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/utils/matrix.jl#L122-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.spd_Cholesky-Tuple{Array}" href="#NNFEM.spd_Cholesky-Tuple{Array}"><code>NNFEM.spd_Cholesky</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">spd_Cholesky(o::Array)
spd_Cholesky(o::PyObject)</code></pre><p>Creates a SPD matrix from 6 scalars. </p><div>\[A = LL&#39;\]</div><p>where</p><div>\[L = \begin{bmatrix}
o_1 &amp; &amp;  \\
o_2 &amp; o_4 &amp; \\
o_3 &amp; o_5 &amp; o_6 
\end{bmatrix}\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/utils/matrix.jl#L85-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.spd_H-Tuple{PyCall.PyObject,Array{Float64,2}}" href="#NNFEM.spd_H-Tuple{PyCall.PyObject,Array{Float64,2}}"><code>NNFEM.spd_H</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">spd_H(o::PyObject, H0::Array{Float64,2})
spd_H(o::Array, H0::Array)</code></pre><p>Creates a SPD matrix from 3 scalars</p><div>\[H = H_0 - \frac{H_0nn&#39;H_0}{1+n&#39;H_0n}\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/utils/matrix.jl#L57-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.spd_zero_to_H-Tuple{PyCall.PyObject,Array{Float64,2}}" href="#NNFEM.spd_zero_to_H-Tuple{PyCall.PyObject,Array{Float64,2}}"><code>NNFEM.spd_zero_to_H</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">spd_zero_to_H(o::Array)
spd_zero_to_H(o::Array, H0inv::Array{Float64,2})</code></pre><p>Creates a SPD matrix from 4 scalars. </p><div>\[A = (H_0^{-1} +LL&#39;)^{-1}\]</div><p>where</p><div>\[L =  \begin{bmatrix}
o_1 &amp; &amp; \\
o_2 &amp; o_3 &amp; \\
 &amp;  &amp; o_4
\end{bmatrix}\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/utils/matrix.jl#L157-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.sym_H-Tuple{PyCall.PyObject}" href="#NNFEM.sym_H-Tuple{PyCall.PyObject}"><code>NNFEM.sym_H</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sym_H(y::PyObject)
sym_H(o::Array)</code></pre><p>Creates a symmetric matrix from 6 parameters</p><div>\[H = \begin{bmatrix}
y_1 &amp; y_2 &amp; y_3\\ 
y_2 &amp; y_4 &amp; y_5 \\ 
y_3 &amp; y_5 &amp; y_6
\end{bmatrix}\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/utils/matrix.jl#L4-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.gradtest-Tuple{Function,Array{Float64,N} where N}" href="#NNFEM.gradtest-Tuple{Function,Array{Float64,N} where N}"><code>NNFEM.gradtest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gradtest(f::Function, x0::Array{Float64}; scale::Float64 = 1.0)</code></pre><p>Testing the gradients of a vector function <code>f</code>.  Here <code>x0</code> is <span>$n$</span>-dimensional vector, <code>f</code> takes an <span>$n$</span>-dimensional vector as inputs, and outputs a <span>$m$</span> dimensional vector. The function tests the second order convergence of <code>f</code></p><div>\[\|f(x_0+\gamma c) - f(x_0) - \gamma \nabla f(x_0) c\|_2 = \mathcal{O}(\gamma^2)\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/33deee97a5897a6f4df6581bd14e853805a2af7e/src/utils/Testsuit.jl#L3-L12">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Getting Started</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 6 April 2020 14:53">Monday 6 April 2020</span>. Using Julia version 1.4.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
