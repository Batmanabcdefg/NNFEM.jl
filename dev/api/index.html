<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · NNFEM</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="NNFEM logo"/></a><div class="docs-package-name"><span class="docs-autofit">NNFEM</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Getting Started</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../ex_simulation/">Simulaton Code Structure</a></li><li><a class="tocitem" href="../ex_ad/">Automatic Differentiation</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../representation/">Representations of Constitutive Relation</a></li></ul></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Core-Data-Structure-1"><span>Core Data Structure</span></a></li><li><a class="tocitem" href="#Core-Data-Structure-Utilities-1"><span>Core Data Structure Utilities</span></a></li><li><a class="tocitem" href="#Elements-1"><span>Elements</span></a></li><li><a class="tocitem" href="#Materials-1"><span>Materials</span></a></li><li><a class="tocitem" href="#Matrix-and-Vector-Assembly-1"><span>Matrix and Vector Assembly</span></a></li><li><a class="tocitem" href="#State-Updates-1"><span>State Updates</span></a></li><li><a class="tocitem" href="#Solvers-1"><span>Solvers</span></a></li><li><a class="tocitem" href="#Utilities-1"><span>Utilities</span></a></li><li><a class="tocitem" href="#Automatic-Differentiation-1"><span>Automatic Differentiation</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/kailaix/NNFEM.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference-1"><a class="docs-heading-anchor" href="#API-Reference-1">API Reference</a><a class="docs-heading-anchor-permalink" href="#API-Reference-1" title="Permalink"></a></h1><h2 id="Core-Data-Structure-1"><a class="docs-heading-anchor" href="#Core-Data-Structure-1">Core Data Structure</a><a class="docs-heading-anchor-permalink" href="#Core-Data-Structure-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NNFEM.Domain" href="#NNFEM.Domain"><code>NNFEM.Domain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Domain</code></pre><p>Date structure for the computatational domain.</p><ul><li><p><code>nnodes</code>: Int64, number of nodes (each quadratical quad element has 9 nodes)</p></li><li><p><code>nodes</code>: Float64[nnodes, ndims], coordinate array of all nodes</p></li><li><p><code>neles</code>: number of elements </p></li><li><p><code>elements</code>: a list of <code>neles</code> element arrays, each element is a struct </p></li><li><p><code>ndims</code>: Int64, dimension of the problem space </p></li><li><p><code>state</code>: a matrix of size <code>nnodes×ndims</code>. <strong>Current</strong> displacement of all nodal freedoms, <code>state[1:nnodes]</code> are for the first direction.</p></li><li><p><code>Dstate</code>: <code>nnodes×ndims</code>. <strong>Previous</strong> displacement of all nodal freedoms, <code>Dstate[1:nnodes]</code> are for the first direction.</p></li><li><p><code>LM</code>:  <code>Int64[neles][ndims]</code>, LM(e,d) is the global equation number (active freedom number) of element e&#39;s d th freedom, </p><pre><code class="language-none">   ∘ -1 means fixed (time-independent) Dirichlet

   ∘ -2 means time-dependent Dirichlet

   ∘ &gt;0 means the global equation number</code></pre></li><li><p><code>DOF</code>: a matrix of size <code>neles×ndims</code>, DOF(e,d) is the global freedom number of element e&#39;s d th freedom</p></li><li><p><code>ID</code>:  a matrix of size <code>nnodes×ndims</code>. <code>ID(n,d)</code> is the equation number (active freedom number) of node n&#39;s <span>$d$</span>-th freedom, </p><pre><code class="language-none">   ∘ -1 means fixed (time-independent) Dirichlet

   ∘ -2 means time-dependent Dirichlet

   ∘ &gt;0 means the global equation number</code></pre></li><li><p><code>neqs</code>:  Int64,  number of equations, a.k.a., active freedoms</p></li><li><p><code>eq_to_dof</code>:  an integer vector of length <code>neqs</code>, map from to equation number (active freedom number) to the freedom number (Int64[1:nnodes] are for the first direction) </p></li><li><p><code>dof_to_eq</code>:  a bolean array of size <code>nnodes×ndims</code>, map from freedom number(Int64[1:nnodes] are for the first direction) to booleans (active freedoms(equation number) are true)</p></li><li><p><code>EBC</code>:  Int64[nnodes, ndims], EBC[n,d] is the displacement boundary condition of node n&#39;s dth freedom,          -1 means fixed(time-independent) Dirichlet boundary nodes          -2 means time-dependent Dirichlet boundary nodes</p></li><li><p><code>g</code>:  Float64[nnodes, ndims], values for fixed(time-independent) Dirichlet boundary conditions of node n&#39;s dth freedom,</p></li><li><p><code>FBC</code>: Int64[nnodes, ndims], FBC[n,d] is the force load boundary condition of node n&#39;s dth freedom,          -1 means constant(time-independent) force load boundary nodes          -2 means time-dependent force load boundary nodes</p></li><li><p><code>fext</code>:  Float64[neqs], constant (time-independent) force load boundary conditions for these freedoms</p></li><li><p><code>Edge_Traction_Data</code>: <code>n × 3</code> integer matrix for natural boundary conditions.     Edge<em>Traction</em>Data[i,1] is the element id,     Edge<em>Traction</em>Data[i,2] is the local edge id in the element, where the force is exterted (should be on the boundary, but not required)     Edge<em>Traction</em>Data[i,3] is the force id, which should be consistent with the last component of the Edge_func in the Globdat</p></li><li><p><code>time</code>: Float64, current time</p></li><li><p><code>npoints</code>: Int64, number of points (each quadratical quad element has 4 points, npoints==nnodes, when porder==1)</p></li><li><p><code>node_to_point</code>: Int64[nnodes]:map from node number to point point, -1 means the node is not a geometry point</p></li></ul><p><strong>Auxilliry Data Structures</strong></p><ul><li><p><code>ii_stiff</code>: Int64[], first index of the sparse matrix representation of the stiffness matrix</p></li><li><p><code>jj_stiff</code>: Int64[], second index of the sparse matrix representation of the stiffness matrix</p></li><li><p><code>vv_stiff_ele_indptr</code>: Int64[], Int64[e] is the first index entry for the e&#39;s element of the sparse matrix representation of the stiffness matrix</p></li><li><p><code>vv_stiff</code>: Float64[], values of the sparse matrix representation of the stiffness matrix</p></li><li><p><code>ii_dfint_dstress</code>: Int64[], first index of the sparse matrix representation of the dfint_dstress matrix </p></li><li><p><code>jj_dfint_dstress</code>: Int64[], second index of the sparse matrix representation of the dfint_dstress matrix</p></li><li><p><code>vv_dfint_dstress_ele_indptr</code>: Int64[], Int64[e] is the first index entry for the e&#39;s element of the sparse matrix representation of the dfint_dstress matrix</p></li><li><p><code>vv_dfint_dstress</code>: Float64[], values of the sparse matrix representation of the dfint_dstress matrix </p></li><li><p><code>ii_dstrain_dstate</code>: Int64[], first index of the sparse matrix representation of the dstrain_dstate matrix</p></li><li><p><code>jj_dstrain_dstate</code>: Int64[], second index of the sparse matrix representation of the dstrain_dstate matrix</p></li><li><p><code>vv_dstrain_dstate_ele_indptr</code>: Int64[], Int64[e] is the first index entry for the e&#39;s element of the sparse matrix representation of the stiffness matrix</p></li><li><p><code>vv_dstrain_dstate</code>: Float64[], values of the sparse matrix representation of the dstrain_dstate matrix</p></li><li><p><code>history</code>: Dict{String, Array{Array{Float64}}}, dictionary between string and its time-histories quantity Float64[ntime][]</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/fem/fem.jl#L94-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.GlobalData" href="#NNFEM.GlobalData"><code>NNFEM.GlobalData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GlobalData</code></pre><p>Store data for finite element updates. Assume the problem has n freedoms,</p><ul><li><code>state</code>: a vector of length <span>$n$</span>. Displacement array at the <strong>current</strong> time, only for <strong>active</strong> freedoms.  The ordering is based on the equation number.</li><li><code>Dstate</code>: a vector of length <span>$n$</span>. Displacement array at the <strong>previous</strong> time.</li><li><code>velo</code>: a vector of length <span>$n$</span>. Velocity array at the <strong>current</strong> time.</li><li><code>acce</code>: a vector of length <span>$n$</span>. Acceleration array at the <strong>current</strong> time.</li><li><code>time</code>: float, current time.</li><li><code>M</code>: a matrix of size <span>$n\times n$</span> spares mass matrix</li><li><code>Mlumped</code>: a vector of length <span>$n$</span> lumped mass array</li><li><code>MID</code>: Float64[n, nd1] off-diagonal part of the mass matrix, between the active freedoms and the time-dependent Dirichlet freedoms, assume there are nd time-dependent Dirichlet freedoms</li><li><code>EBC_func</code>: displacement <span>$d$</span>, velocity <span>$v$</span>, and acceleration <span>$a$</span> from time-dependent Dirichlet boundary conditions </li></ul><div>\[d, v, a = \text{EBC\_func}(\text{time})\]</div><p>The length of each output is the same as number of &quot;-2&quot; in <code>EBC</code> array. The ordering is direction major, i.e., <span>$u_1, u_3, \ldots, v_1, v_3, \ldots$</span> </p><ul><li><code>FBC_func</code>: time-dependent load boundary condition. </li></ul><div>\[f = \text{FBC\_func}(\text{time})\]</div><p>Here <span>$f$</span> is a vector. Its length is the same as number of &quot;-2&quot; in <code>FBC</code> array. The ordering is direction major, i.e., <span>$u_1, u_3, \ldots, v_1, v_3, \ldots$</span> </p><ul><li><code>Body_func</code>: time-dependent/independent body force function. </li></ul><div>\[f = \text{Body\_func}(x_{\text{array}}, y_{\text{array}}, \text{time})\]</div><p>Here <span>$f$</span> is a vector. Its length is the same as the length of <span>$x_{\text{array}}$</span> or <span>$y_{\text{array}}$</span>.</p><ul><li><code>Edge_func</code>: time-dependent/independent traction load. </li></ul><div>\[f = \text{Edge\_func}(x_{\text{array}}, y_{\text{array}}, \text{time}, \text{id})\]</div><p>Here <span>$f$</span> is a vector. Its length is the same as the length of <span>$x_{\text{array}}$</span> or <span>$y_{\text{array}}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/fem/fem.jl#L6-L44">source</a></section></article><h2 id="Core-Data-Structure-Utilities-1"><a class="docs-heading-anchor" href="#Core-Data-Structure-Utilities-1">Core Data Structure Utilities</a><a class="docs-heading-anchor-permalink" href="#Core-Data-Structure-Utilities-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NNFEM.getEqns" href="#NNFEM.getEqns"><code>NNFEM.getEqns</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getEqns(domain::Domain, iele::Int64)</code></pre><p>Gets the equation numbers(active freedom numbers) of the element.  This excludes both the time-dependent and time-independent Dirichlet boundary conditions. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/fem/fem.jl#L644-L649">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.getNGauss" href="#NNFEM.getNGauss"><code>NNFEM.getNGauss</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getNGauss(domain::Domain)</code></pre><p>Gets the total number of Gauss quadrature points. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/fem/fem.jl#L631-L635">source</a></section></article><h2 id="Elements-1"><a class="docs-heading-anchor" href="#Elements-1">Elements</a><a class="docs-heading-anchor-permalink" href="#Elements-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NNFEM.FiniteStrainContinuum" href="#NNFEM.FiniteStrainContinuum"><code>NNFEM.FiniteStrainContinuum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FiniteStrainContinuum(coords::Array{Float64}, elnodes::Array{Int64}, props::Dict{String, Any}, ngp::Int64=2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/elements/FiniteStrainContinuum.jl#L59-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.FiniteStrainContinuum" href="#NNFEM.FiniteStrainContinuum"><code>NNFEM.FiniteStrainContinuum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FiniteStrainContinuum</code></pre><p>Constructs a finite strain element. </p><ul><li><code>eledim</code>: spatial dimension of the element (default = 2).</li><li><code>mat</code>: constitutive law, a length <code>#elem</code> vector of materials such as <a href="#NNFEM.PlaneStress"><code>PlaneStress</code></a></li><li><code>elnodes</code>: the node indices in this finite element, an integer array </li><li><code>props</code>: property dictionary </li><li><code>coords</code>: coordinates of the vertices of the element</li><li><code>dhdx</code>, <code>weights</code>, <code>hs</code>: data for integral </li><li><code>stress</code>: stress at each quadrature points</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">#   Local degrees of freedom 
#   4 ---- 3
#
#   1 ---- 2

nx = 10
ny = 5
h = 0.1
element = FiniteStrainContinuum[]
prop = Dict(&quot;name&quot;=&gt; &quot;PlaneStrain&quot;, &quot;rho&quot;=&gt; 0.0876584, &quot;E&quot;=&gt;0.07180760098, &quot;nu&quot;=&gt;0.4)
for j = 1:ny
    for i = 1:nx 
        n = (nx+1)*(j-1) + (i-1)+1
        elnodes = [n, n + 1, n + 1 + (nx + 1), n + (nx + 1)]
        ngp = 3 # 3 x 3 Gauss points per element 
        coords = [(i-1)*h (j-1)*h
                    i*h (j-1)*h
                    i*h j*h
                    (i-1)*h j*h]
        push!(element, FiniteStrainContinuum(coords,elnodes, prop, ngp))
    end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/elements/FiniteStrainContinuum.jl#L5-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.SmallStrainContinuum" href="#NNFEM.SmallStrainContinuum"><code>NNFEM.SmallStrainContinuum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SmallStrainContinuum(coords::Array{Float64}, elnodes::Array{Int64}, props::Dict{String, Any}, ngp::Int64=2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/elements/SmallStrainContinuum.jl#L60-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.SmallStrainContinuum" href="#NNFEM.SmallStrainContinuum"><code>NNFEM.SmallStrainContinuum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SmallStrainContinuum</code></pre><p>Constructs a small strain element. </p><ul><li><code>eledim</code>: spatial dimension of the element (default = 2).</li><li><code>mat</code>: constitutive law, a length <code>#elem</code> vector of materials such as <a href="#NNFEM.PlaneStress"><code>PlaneStress</code></a></li><li><code>elnodes</code>: the node indices in this finite element, an integer array </li><li><code>props</code>: property dictionary </li><li><code>coords</code>: coordinates of the vertices of the element</li><li><code>dhdx</code>: list of <code>ngp</code> shape functions for first order derivatives <span>$\nabla \phi(x)$</span> (<code>ndof×2</code>) on the Gaussian points</li><li><code>weights</code>: weight vector of length <code>n_gauss_points</code>, for numerical quadrature</li><li><code>hs</code>: list of <code>ngp</code> shape functions for function values <span>$\phi(x)$</span> (length <code>ndof</code> vectors) on the Gaussian points</li><li><code>stress</code>: stress at each quadrature points; this field is reserved for visualization. </li></ul><p><strong>Example</strong></p><pre><code class="language-julia">#   Local degrees of freedom 
#   4 ---- 3
#
#   1 ---- 2

nx = 10
ny = 5
h = 0.1
element = SmallStrainContinuum[]
prop = Dict(&quot;name&quot;=&gt; &quot;PlaneStrain&quot;, &quot;rho&quot;=&gt; 0.0876584, &quot;E&quot;=&gt;0.07180760098, &quot;nu&quot;=&gt;0.4)
for j = 1:ny
    for i = 1:nx 
        n = (nx+1)*(j-1) + (i-1)+1
        elnodes = [n, n + 1, n + 1 + (nx + 1), n + (nx + 1)]
        ngp = 3 # 3 x 3 Gauss points per element 
        coords = [(i-1)*h (j-1)*h
                    i*h (j-1)*h
                    i*h j*h
                    (i-1)*h j*h]
        push!(element, SmallStrainContinuum(coords,elnodes, prop, ngp))
    end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/elements/SmallStrainContinuum.jl#L4-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.getInternalForce-Tuple{SmallStrainContinuum,Array{Float64,N} where N,Array{Float64,N} where N,Float64}" href="#NNFEM.getInternalForce-Tuple{SmallStrainContinuum,Array{Float64,N} where N,Array{Float64,N} where N,Float64}"><code>NNFEM.getInternalForce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getInternalForce(elem::SmallStrainContinuum, state::Array{Float64}, Dstate::Array{Float64}, Δt::Float64)</code></pre><p>Returns the internal force term. <code>state</code> and <code>Dstate</code> are restriction of full state variables to this element. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/elements/SmallStrainContinuum.jl#L138-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.getStiffAndForce-Tuple{SmallStrainContinuum,Array{Float64,N} where N,Array{Float64,N} where N,Float64}" href="#NNFEM.getStiffAndForce-Tuple{SmallStrainContinuum,Array{Float64,N} where N,Array{Float64,N} where N,Float64}"><code>NNFEM.getStiffAndForce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getStiffAndForce(elem::SmallStrainContinuum, state::Array{Float64}, Dstate::Array{Float64}, Δt::Float64)</code></pre><p>Returns the internal force term and the stiffness matrix. <code>state</code> and <code>Dstate</code> are restriction of full state variables to this element. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/elements/SmallStrainContinuum.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.getStrain-Tuple{SmallStrainContinuum,Array{Float64,N} where N}" href="#NNFEM.getStrain-Tuple{SmallStrainContinuum,Array{Float64,N} where N}"><code>NNFEM.getStrain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getStrain(elem::SmallStrainContinuum, state::Array{Float64})</code></pre><p>Returns the strain of this element.  <code>state</code> is restricted to this variable. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/elements/SmallStrainContinuum.jl#L173-L177">source</a></section></article><h2 id="Materials-1"><a class="docs-heading-anchor" href="#Materials-1">Materials</a><a class="docs-heading-anchor-permalink" href="#Materials-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NNFEM.PlaneStress" href="#NNFEM.PlaneStress"><code>NNFEM.PlaneStress</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PlaneStress</code></pre><p>Creates a plane stress element</p><ul><li><code>H</code>: Linear elasticity matrix, <span>$3\times3$</span></li><li><code>E</code>: Young&#39;s modulus</li><li><code>ν</code>: Poisson&#39;s ratio </li><li><code>ρ</code>: density </li><li><code>σ0</code>: stress at the <strong>last</strong> time step </li><li><code>σ0_</code>: (for internal use), stress to be updated in <code>commitHistory</code></li><li><code>ε0</code>: strain at the <strong>last</strong> time step </li><li><code>ε0_</code>: (for internal use), strain to be updated in <code>commitHistory</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia">prop = Dict(&quot;name&quot;=&gt; &quot;PlaneStress&quot;, &quot;rho&quot;=&gt; 0.0876584, &quot;E&quot;=&gt;0.07180760098, &quot;nu&quot;=&gt;0.4)
mat = PlaneStress(prop)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/materials/PlaneStress.jl#L3-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.PlaneStress-Tuple{Dict{String,Any}}" href="#NNFEM.PlaneStress-Tuple{Dict{String,Any}}"><code>NNFEM.PlaneStress</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PlaneStress(prop::Dict{String, Any})</code></pre><p><code>prop</code> should contain at least the following three fields: <code>E</code>, <code>nu</code>, <code>rho</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/materials/PlaneStress.jl#L34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.PlaneStrain" href="#NNFEM.PlaneStrain"><code>NNFEM.PlaneStrain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PlaneStrain</code></pre><p>Creates a plane strain element</p><ul><li><code>H</code>: Linear elasticity matrix, <span>$3\times3$</span></li><li><code>E</code>: Young&#39;s modulus</li><li><code>ν</code>: Poisson&#39;s ratio </li><li><code>ρ</code>: density </li><li><code>σ0</code>: stress at the <strong>last</strong> time step </li><li><code>σ0_</code>: (for internal use), stress to be updated in <code>commitHistory</code></li><li><code>ε0</code>: strain at the <strong>last</strong> time step </li><li><code>ε0_</code>: (for internal use), strain to be updated in <code>commitHistory</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia">prop = Dict(&quot;name&quot;=&gt; &quot;PlaneStrain&quot;, &quot;rho&quot;=&gt; 0.0876584, &quot;E&quot;=&gt;0.07180760098, &quot;nu&quot;=&gt;0.4)
mat = PlaneStrain(prop)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/materials/PlaneStrain.jl#L3-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.PlaneStrain-Tuple{Dict{String,Any}}" href="#NNFEM.PlaneStrain-Tuple{Dict{String,Any}}"><code>NNFEM.PlaneStrain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PlaneStrain(prop::Dict{String, Any})</code></pre><p><code>prop</code> should contain at least the following three fields: <code>E</code>, <code>nu</code>, <code>rho</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/materials/PlaneStrain.jl#L34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.PlaneStressIncompressibleRivlinSaunders" href="#NNFEM.PlaneStressIncompressibleRivlinSaunders"><code>NNFEM.PlaneStressIncompressibleRivlinSaunders</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Pascon, João Paulo.  &quot;Large deformation analysis of plane-stress hyperelastic problems via triangular membrane finite elements.&quot;  International Journal of Advanced Structural Engineering (2019): 1-20.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/materials/PlaneStressIncompressibleRivlinSaunders.jl#L3-L7">source</a></section></article><h2 id="Matrix-and-Vector-Assembly-1"><a class="docs-heading-anchor" href="#Matrix-and-Vector-Assembly-1">Matrix and Vector Assembly</a><a class="docs-heading-anchor-permalink" href="#Matrix-and-Vector-Assembly-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NNFEM.assembleInternalForce" href="#NNFEM.assembleInternalForce"><code>NNFEM.assembleInternalForce</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">assembleInternalForce(globdat::GlobalData, domain::Domain, Δt::Float64 = 0.0)</code></pre><p>Computes the internal force vector <span>$F_\mathrm{int}$</span> of length <code>neqs</code></p><ul><li><code>globdat</code>: GlobalData</li><li><code>domain</code>: Domain, finite element domain, for data structure</li><li><code>Δt</code>:  Float64, current time step size</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/fem/assembly.jl#L3-L10">source</a></section><section><div><pre><code class="language-none">assembleInternalForce(domain::Domain, nn::Function, E_all::PyObject, DE_all::PyObject, w∂E∂u_all::PyObject, σ0_all::PyObject)</code></pre><p>Computes local internal force f<em>int and then assemble to F</em>int, which generates inverse problem automatically.</p><ul><li><code>domain</code>: finite element domain</li><li><code>nn</code>: constitutive relation for expressing <code>stress = f(strain)</code>, assuming <code>stress</code> and <code>strain</code> are defined on Gauss points (<code>(neles*nGauss) × nstrains</code>).</li><li><code>E_all</code>: strain data of size <code>(neles*nGauss) × nstrains</code> at the <strong>current</strong> time step.</li><li><code>DE_all</code>: strain data of size <code>(neles*nGauss) × nstrains</code> at the <strong>last</strong> time step.</li><li><code>w∂E∂u_all</code>: sensitivity matrix of size <code>(neles*nGauss) x ndofs_per_element x nstrains</code>; <code>neles*nGauss</code> is the number of Gaussian quadrature points,  <code>ndofs_per_element</code> is the number of freedoms per element, and <code>nstrain</code> is the number of strain components. The sensitivity matrix already considers the quadrature weights. </li></ul><div>\[s_{g,j,i}^e = w_g^e\frac{\partial \epsilon_g^e}{\partial u_j^e}\]</div><p>where <span>$e$</span> is the element index, <span>$g$</span> is the Gaussian index. </p><ul><li><code>σ0_all</code>: stress data of size <code>neles*nGauss×nstrains</code> at the <strong>last</strong> time step. </li></ul><p>Return: </p><ul><li><div>\[F_{\mathrm{int}}\]</div>:  internal force vector of length <code>neqns</code></li><li><div>\[\sigma_{\mathrm{all}}\]</div>: predicted stress at <strong>current</strong> step, a matrix of size <code>(neles*nGauss) × nstrains</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/fem/assembly.jl#L43-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.assembleStiffAndForce" href="#NNFEM.assembleStiffAndForce"><code>NNFEM.assembleStiffAndForce</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">assembleStiffAndForce(globdat::GlobalData, domain::Domain, Δt::Float64 = 0.0)</code></pre><p>Computes the internal force and stiffness matrix. </p><ul><li><code>globdat</code>: GlobalData</li><li><code>domain</code>: Domain, finite element domain, for data structure</li><li><code>Δt</code>:  Float64, current time step size</li></ul><p>Returns a length <code>neqs</code> vector <span>$F_{\mathrm{int}}$</span> and <code>neqs×neqs</code> sparse stiffness matrix. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/fem/assembly.jl#L112-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.assembleMassMatrix!" href="#NNFEM.assembleMassMatrix!"><code>NNFEM.assembleMassMatrix!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">assembleMassMatrix!(globaldat::GlobalData, domain::Domain)</code></pre><p>Computes the constant sparse mass matrix <span>$M_{\mathrm{mass}}$</span>, the lumped mass matrix <span>$M_{\mathrm{lump}}$</span> due to time-dependent Dirichlet boundary conditions, and store them in <code>globaldat</code>. </p><div>\[M_{\mathrm{mass}}\begin{bmatrix}
M &amp; M_{ID}\\ 
M_{ID}^T &amp; M_{DD} 
\end{bmatrix}\]</div><p>Here M is a <code>neqns×neqns</code> matrix, and <span>$M_{ID}$</span> is a <code>neqns×nd</code> matrix. <span>$M_{\mathrm{lump}}$</span> assumes that the local mass matrix is a diagonal matrix. </p><ul><li><code>globdat</code>: <code>GlobalData</code></li><li><code>domain</code>: <code>Domain</code>, finite element domain, for data structure</li></ul><p><img src="../assets/massmatrix.png" alt/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/fem/assembly.jl#L169-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.getBodyForce" href="#NNFEM.getBodyForce"><code>NNFEM.getBodyForce</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getBodyForce(elem::Continuum, fvalue::Array{Float64,2})</code></pre><p>Returns the body force. </p><ul><li><code>fvalue</code> is a <span>$n_{gauss}\times 2$</span> matrix, which is ordered the same as    Gaussian points in the undeformed parent element.</li></ul><p>Returns the nodal force due to the body force <span>$\int_{e} \mathbf{f}(\mathbf{x})\cdot \delta \mathbf{u}(\mathbf{x}) d \mathbf{x}    = \int_{e} \mathbf{f}(\mathbf{\xi})\cdot \delta \mathbf{u}(\mathbf{\xi})    |\frac{\partial \mathbf{x}}{\partial \mathbf{\xi}}| d \mathbf{\xi}$</span></p><p>todo force in the deformed domain</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/elements/Continuum.jl#L7-L21">source</a></section><section><div><pre><code class="language-none">getBodyForce(domain::Domain, globdat::GlobalData, time::Float64)</code></pre><p>Computes the body force vector <span>$F_\mathrm{body}$</span> of length <code>neqs</code></p><ul><li><code>globdat</code>: GlobalData</li><li><code>domain</code>: Domain, finite element domain, for data structure</li><li><code>Δt</code>:  Float64, current time step size</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/fem/fem.jl#L532-L539">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.getExternalForce!" href="#NNFEM.getExternalForce!"><code>NNFEM.getExternalForce!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getExternalForce!(self::Domain, globaldat::GlobalData, fext::Union{Missing,Array{Float64}}=missing)</code></pre><p>Computes external force vector, including both external force load and time-dependent Dirichlet boundary conditions.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The function needs to be called after <a href="#NNFEM.updateDomainStateBoundary!"><code>updateDomainStateBoundary!</code></a>, which computes the external force vector from external force load</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/fem/fem.jl#L509-L516">source</a></section></article><h2 id="State-Updates-1"><a class="docs-heading-anchor" href="#State-Updates-1">State Updates</a><a class="docs-heading-anchor-permalink" href="#State-Updates-1" title="Permalink"></a></h2><p>This set of functions include boundary condition updates, data transfer, and other bookkeeping utilities.</p><article class="docstring"><header><a class="docstring-binding" id="NNFEM.commitHistory" href="#NNFEM.commitHistory"><code>NNFEM.commitHistory</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">commitHistory(elem::Continuum)</code></pre><p>Updates the historic parameters in the material properties. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/elements/Continuum.jl#L160-L164">source</a></section><section><div><pre><code class="language-none">commitHistory(domain::Domain)</code></pre><p>Update current step strain and stress in the history map of the <code>domain</code>.  This is essential for visualization and time dependent constitutive relations. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/fem/fem.jl#L302-L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.setDirichletBoundary!" href="#NNFEM.setDirichletBoundary!"><code>NNFEM.setDirichletBoundary!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setDirichletBoundary!(self::Domain, EBC::Array{Int64}, g::Array{Float64})</code></pre><p>Bookkeepings for Dirichlet boundary conditions. Only called once in the constructor of <code>domain</code>.  It updates the fixed (time-independent Dirichlet boundary) state entries and builds both LM and DOF arrays.</p><ul><li><p><code>self</code>: Domain</p></li><li><p><code>EBC</code>:  Int64[nnodes, ndims], EBC[n,d] is the displacement boundary condition of node n&#39;s dth freedom,</p><p>∘ -1 means fixed(time-independent) Dirichlet boundary nodes</p><p>∘ -2 means time-dependent Dirichlet boundary nodes</p></li><li><p><code>g</code>:  Float64[nnodes, ndims], values for fixed (time-independent) Dirichlet boundary conditions of node n&#39;s dth freedom,</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/fem/fem.jl#L347-L361">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.setNeumannBoundary!" href="#NNFEM.setNeumannBoundary!"><code>NNFEM.setNeumannBoundary!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Bookkeepings for Dirichlet boundary conditions. Only called once in the constructor of <code>domain</code>.  It updates the fixed (time-independent Neumann boundary) state entries and builds both LM and DOF arrays.</p><ul><li><p><code>self</code>: Domain</p></li><li><p><code>FBC</code>:  Int64[nnodes, ndims], FBC[n,d] is the displacement boundary condition of node n&#39;s dth freedom,</p><p>∘ -1 means fixed (time-independent) Neumann boundary nodes</p><p>∘ -2 means time-dependent Dirichlet boundary nodes</p></li><li><p><code>f</code>:  Float64[nnodes, ndims], values for fixed (time-independent) Neumann boundary conditions of node n&#39;s dth freedom,</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/fem/fem.jl#L414-L427">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.updateStates!" href="#NNFEM.updateStates!"><code>NNFEM.updateStates!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">updateStates!(domain::Domain, globaldat::GlobalData)</code></pre><p>At each time step, <code>updateStates!</code> needs to be called to update the full <code>state</code> and <code>Dstate</code> in <code>domain</code> from active ones in <code>globaldat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/fem/fem.jl#L448-L453">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.updateDomainStateBoundary!" href="#NNFEM.updateDomainStateBoundary!"><code>NNFEM.updateDomainStateBoundary!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">updateDomainStateBoundary!(self::Domain, globaldat::GlobalData)</code></pre><p>If there exists time-dependent boundary conditions, <code>updateDomainStateBoundary!</code> must be called to update  the boundaries in <code>domain</code>. This function is called by <a href="#NNFEM.updateStates!"><code>updateStates!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/fem/fem.jl#L468-L473">source</a></section></article><h2 id="Solvers-1"><a class="docs-heading-anchor" href="#Solvers-1">Solvers</a><a class="docs-heading-anchor-permalink" href="#Solvers-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NNFEM.ExplicitSolverStep" href="#NNFEM.ExplicitSolverStep"><code>NNFEM.ExplicitSolverStep</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ExplicitSolverStep(globdat::GlobalData, domain::Domain, Δt::Float64)</code></pre><p>Central Difference explicit solver for <code>M a + fint(u) = fext(u)</code>. <code>a</code>, <code>v</code>, <code>u</code> are acceleration, velocity and displacement.</p><div>\[\begin{align}
u_{n+1} =&amp; u_n + dtv_n + dt^2/2 a_n \\
v_{n+1} =&amp; v_n + dt/2(a_n + a_{n+1}) \\
M a_{n+1} + f^{int}(u_{n+1}) =&amp; f^{ext}_{n+1} \\
M a_{n+1} =&amp; f^{ext}_{n+1} - f^{int}(u_{n+1}) \\
\end{align}\]</div><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>You need to call SolverInitial! before the first time step, if <span>$f^{ext}_0 \neq 0$</span>.  Otherwise we assume the initial acceleration <code>globdat.acce[:] = 0</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/solvers/SolversV2.jl#L2-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.GeneralizedAlphaSolverStep" href="#NNFEM.GeneralizedAlphaSolverStep"><code>NNFEM.GeneralizedAlphaSolverStep</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">GeneralizedAlphaSolverStep(globdat::GlobalData, domain::Domain, Δt::Float64, 
ρ::Float64 = 0.0, ε::Float64 = 1e-8, ε0::Float64 = 1e-8, maxiterstep::Int64=100, 
η::Float64 = 1.0, failsafe::Bool = false, verbose::Bool = false)</code></pre><p>Implicit solver for  <span>$Ma  + f_{int}(u) = fext$</span> Here <span>$a$</span>, <span>$v$</span>, <span>$u$</span> are acceleration, velocity and displacement respectively.</p><ul><li><code>ρ</code>: controls the damping effect of the α-scheme, ρ∈[0,1], ρ=1 corresponds to the maximum damping</li><li><code>ε</code>: Float64, absolute error for Newton convergence</li><li><code>ε0</code>: Float64, relative error for Newton convergence</li><li><code>max_iter</code>: Int64, maximum iteration number for Newton convergence</li><li><code>η</code>: Float64, Newton step size at the first iteration</li><li><code>failsafe</code>: Bool, if failsafe is true, when the Newton fails to converge,              revert back, and return false</li></ul><p>The nonlinear <span>$\alpha$</span></p><div>\[u_{n+1} = u_n + dtv_n + dt^2/2 ((1 - 2\beta)a_n + 2\beta a_{n+1})
v_{n+1} = v_n + dt((1 - \gamma)a_n + \gamma a_{n+1})
2\beta = 0.5*(1 - αm + αf)^2
\gamma = 0.5 - \alpha_m + \alpha_f\]</div><div>\[a_{n+1-\alpha_m} = (1-\alpha_m)a_{n+1} + \alpha_m a_{n} 
v_{n+1-\alpha_f} = (1-\alpha_f)v_{n+1} + \alpha_f v_{n}
u_{n+1-\alpha_f} = (1-\alpha_f)u_{n+1} + \alpha_f u_{n}
M a_{n+1-\alpha_m} + f^{int}(u_{n+1-\alpha_f}) = f^{ext}_{n+1-\alpha_f}\]</div><p>&#39;a_{n+1}&#39; is solved by </p><div>\[M ((1-\alpha_m)a_{n+1} + \alpha_m a_{n})  
+ f^{int}((1-\alpha_f)(u_n + dtv_n + dt^2/2 ((1 - 2\beta)a_n + 2\beta a_{n+1}))) + \alpha_f u_{n}) 
= f^{ext}_{n+1-\alpha_f}\]</div><p>As for <code>\alpha_m</code> and <span>$\alpha_f$</span></p><div>\[\alpha_m = (2\rho_{\infty} - 1)/(\rho_{\infty} + 1)
\alpha_f = \rho_{\infty}/(\rho_{\infty} + 1)\]</div><p>use the current states <code>a</code>, <code>v</code>, <code>u</code>, <code>time</code> in globdat, and update these stetes to next time step update domain history, when failsafe is true, and Newton&#39;s solver fails, nothing will be changed.</p><p>You need to call SolverInitial! before the first time step, if f^{ext}<em>0 != 0. SolverInitial! updates a</em>0 in the globdat.acce a<em>0 = M^{-1}(- f^{int}(u</em>0) + f^{ext}_0)</p><p>We assume globdat.acce[:] = a_0 and so far initialized to 0 We also assume the external force is conservative (it does not depend on the current deformation)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/solvers/SolversV2.jl#L50-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.SolverInitial!" href="#NNFEM.SolverInitial!"><code>NNFEM.SolverInitial!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SolverInitial!(Δt::Float64, globdat::GlobalData, domain::Domain)</code></pre><p>You need to call SolverInitial! before the first time step, if <span>$f^{ext}_0 \neq 0$</span></p><div>\[a_0 = M^{-1}(- f^{int}(u_0) + f^{ext}_0)\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/solvers/Solvers.jl#L58-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.SolverInitial" href="#NNFEM.SolverInitial"><code>NNFEM.SolverInitial</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SolverInitial(Δt::Float64, globdat::GlobalData, domain::Domain)</code></pre><p>Similar to <a href="#NNFEM.SolverInitial!"><code>SolverInitial!</code></a>, but returns the (displacement, velocity, acceleartion) tuple. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/solvers/Solvers.jl#L77-L81">source</a></section></article><h2 id="Utilities-1"><a class="docs-heading-anchor" href="#Utilities-1">Utilities</a><a class="docs-heading-anchor-permalink" href="#Utilities-1" title="Permalink"></a></h2><pre><code class="language-">meshread
visualize_von_mises_stress
visualize_displacement</code></pre><h2 id="Automatic-Differentiation-1"><a class="docs-heading-anchor" href="#Automatic-Differentiation-1">Automatic Differentiation</a><a class="docs-heading-anchor-permalink" href="#Automatic-Differentiation-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NNFEM.init_nnfem" href="#NNFEM.init_nnfem"><code>NNFEM.init_nnfem</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">init_nnfem(domain::Domain)</code></pre><p>Prepares <code>domain</code> for use in custom operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/adutils/kernels.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.s_eval_strain_on_gauss_points" href="#NNFEM.s_eval_strain_on_gauss_points"><code>NNFEM.s_eval_strain_on_gauss_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">s_eval_strain_on_gauss_points(state::Union{Array{Float64,1}, PyObject})</code></pre><p>Computes the strain on Gauss points in the small strain case. <code>state</code> is the full displacement vector. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/adutils/kernels.jl#L111-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.s_compute_stiffness_matrix" href="#NNFEM.s_compute_stiffness_matrix"><code>NNFEM.s_compute_stiffness_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">s_compute_stiffness_matrix(k::Union{Array{Float64,3}, PyObject})</code></pre><p>Computes the small strain stiffness matrix. <span>$k$</span> is a <span>$n\times 3\times 3$</span> matrix, where <span>$n$</span> is the total number of Gauss points. Returns a SparseTensor. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/adutils/kernels.jl#L97-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.s_compute_internal_force_term" href="#NNFEM.s_compute_internal_force_term"><code>NNFEM.s_compute_internal_force_term</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">s_compute_internal_force_term(stress::Union{Array{Float64,2}, PyObject})</code></pre><p>Computes the internal force <span>$\int_\Omega \sigma : \delta \epsilon dx$</span> Only active DOFs are considered. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/adutils/kernels.jl#L137-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.f_eval_strain_on_gauss_points" href="#NNFEM.f_eval_strain_on_gauss_points"><code>NNFEM.f_eval_strain_on_gauss_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">f_eval_strain_on_gauss_points(state::Union{Array{Float64,1}, PyObject})</code></pre><p>Computes the strain on Gauss points in the finite strain case. <code>state</code> is the full displacement vector. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/adutils/kernels.jl#L123-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.f_compute_internal_force_term" href="#NNFEM.f_compute_internal_force_term"><code>NNFEM.f_compute_internal_force_term</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">f_compute_internal_force_term(stress::Union{Array{Float64,2}, PyObject}, 
    state::Union{Array{Float64,1}, PyObject},
    domain::Domain)</code></pre><p>Computes the internal force for finite strain continuum</p><div>\[\int_\Omega \sigma : \delta \epsilon dx\]</div><p>Only active DOFs are considered. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/adutils/kernels.jl#L152-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.ExplicitSolver" href="#NNFEM.ExplicitSolver"><code>NNFEM.ExplicitSolver</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ExplicitSolver(globdat::GlobalData, domain::Domain,
    d0::Union{Array{Float64, 1}, PyObject}, 
    v0::Union{Array{Float64, 1}, PyObject}, 
    a0::Union{Array{Float64, 1}, PyObject}, 
    Δt::Float64, NT::Int64, 
    H::Union{Array{Float64, 3}, Array{Float64, 2}, PyObject},
    Fext::Union{Array{Float64, 2}, PyObject, Missing}=missing,
    ubd::Union{Array{Float64, 2}, PyObject, Missing}=missing,
    abd::Union{Array{Float64, 2}, PyObject, Missing}=missing; strain::String = &quot;small&quot;)</code></pre><p>Differentiable Explicit Solver. </p><ul><li><p><code>d0</code>, <code>v0</code>, <code>a0</code>: initial <strong>full</strong> displacement, velocity, and acceleration. </p></li><li><p><code>Δt</code>: time step </p></li><li><p><code>Hs</code>: linear elasticity matrix at each Gauss point </p></li><li><p><code>Fext</code>: external force, <span>$\mathrm{NT}\times n$</span>, where <span>$n$</span> is the active dof.  The external force includes all <strong>body forces</strong>, <strong>external load forces</strong> (also called <strong>edge forces</strong> in NNFEM) and <strong>boundary acceleration-induced forces</strong>.</p></li><li><p><code>ubd</code>, <code>abd</code>: boundary displacementt and acceleration, <span>$\mathrm{NT}\times m$</span>, where <span>$m$</span> is <strong>time-dependent</strong> boundary DOF.   Time-independent boundary conditions are extracted from <code>domain</code>. </p></li><li><p><code>strain_type</code> (default = &quot;small&quot;): small strain or finite strain</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/adutils/solvers.jl#L18-L44">source</a></section><section><div><pre><code class="language-none">ExplicitSolver(globdat::GlobalData, domain::Domain,
    d0::Union{Array{Float64, 1}, PyObject}, 
    v0::Union{Array{Float64, 1}, PyObject}, 
    a0::Union{Array{Float64, 1}, PyObject}, 
    Δt::Float64, NT::Int64, 
    nn::Function,
    Fext::Union{Array{Float64, 2}, PyObject, Missing}=missing,
    ubd::Union{Array{Float64, 2}, PyObject, Missing}=missing,
    abd::Union{Array{Float64, 2}, PyObject, Missing}=missing; strain_type::String = &quot;small&quot;))</code></pre><p>Similar to <a href="#NNFEM.ExplicitSolver"><code>ExplicitSolver</code></a>; however, the constituve relation from <span>$\epsilon$</span> to <span>$\sigma$</span> must be provided by  the function <code>nn</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/adutils/solvers.jl#L301-L314">source</a></section><section><div><pre><code class="language-none">ExplicitSolver(globdat::GlobalData, domain::Domain,
    d0::Union{Array{Float64, 1}, PyObject}, 
    v0::Union{Array{Float64, 1}, PyObject}, 
    a0::Union{Array{Float64, 1}, PyObject}, 
    σ0::Union{Array{Float64, 1}, PyObject}, 
    ε0::Union{Array{Float64, 1}, PyObject}, 
    Δt::Float64, NT::Int64, 
    nn::Function,
    Fext::Union{Array{Float64, 2}, PyObject, Missing}=missing,
    ubd::Union{Array{Float64, 2}, PyObject, Missing}=missing,
    abd::Union{Array{Float64, 2}, PyObject, Missing}=missing; strain_type::String = &quot;small&quot;)</code></pre><p>Similar to <a href="#NNFEM.ExplicitSolver"><code>ExplicitSolver</code></a>; however, the constitutive relation has the form </p><div>\[\sigma^{n+1} = \mathrm{nn}(\epsilon^{n+1}, \epsilon^n, \sigma^n)\]</div><p>Here the strain and stress are <span>$n \times 3$</span> tensors. <span>$n$</span> is the total number of Gaussian points and can be  obtained via <code>getNGauss(domain)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/adutils/solvers.jl#L394-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.ExplicitSolverTime" href="#NNFEM.ExplicitSolverTime"><code>NNFEM.ExplicitSolverTime</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ExplicitSolverTime(Δt::Float64, NT::Int64)</code></pre><p>Returns the times for explicit solver. Boundary conditions and external forces should be given at these times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/adutils/solvers.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.GeneralizedAlphaSolver" href="#NNFEM.GeneralizedAlphaSolver"><code>NNFEM.GeneralizedAlphaSolver</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">GeneralizedAlphaSolver(globdat::GlobalData, domain::Domain,
    d0::Union{Array{Float64, 1}, PyObject}, 
    v0::Union{Array{Float64, 1}, PyObject}, 
    a0::Union{Array{Float64, 1}, PyObject}, 
    Δt::Float64, NT::Int64, 
    Hs::Union{Array{Float64, 3}, Array{Float64, 2}, PyObject},
    Fext::Union{Array{Float64, 2}, PyObject, Missing}=missing,
    ubd::Union{Array{Float64, 2}, PyObject, Missing}=missing,
    abd::Union{Array{Float64, 2}, PyObject, Missing}=missing; ρ::Float64 = 0.0)</code></pre><p>Differentiable Generalized <span>$\alpha$</span> scheme. This is an extension of <a href="https://kailaix.github.io/ADCME.jl/dev/alphascheme/"><code>αscheme</code></a> provided in ADCME. This function does not support damping and variable time step (for efficiency). </p><ul><li><p><code>d0</code>, <code>v0</code>, <code>a0</code>: initial <strong>full</strong> displacement, velocity, and acceleration. </p></li><li><p><code>Δt</code>: time step </p></li><li><p><code>Hs</code>: linear elasticity matrix at each Gauss point </p></li><li><p><code>Fext</code>: external force, <span>$\mathrm{NT}\times n$</span>, where <span>$n$</span> is the active dof.  The external force includes all <strong>body forces</strong>, <strong>external load forces</strong> (also called <strong>edge forces</strong> in NNFEM) and <strong>boundary acceleration-induced forces</strong>.</p></li><li><p><code>ubd</code>, <code>abd</code>: boundary displacementt and acceleration, <span>$\mathrm{NT}\times m$</span>, where <span>$m$</span> is boundary DOF.  Time-independent boundary conditions are extracted from <code>domain</code>. </p></li></ul><p><code>GeneralizedAlphaSolver</code> does not support finite-strain continuum yet.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/adutils/solvers.jl#L187-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.GeneralizedAlphaSolverTime" href="#NNFEM.GeneralizedAlphaSolverTime"><code>NNFEM.GeneralizedAlphaSolverTime</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">GeneralizedAlphaSolverTime(Δt::Float64, NT::Int64;ρ::Float64 = 0.0)</code></pre><p>Returns the times for the generalized <span>$\alpha$</span> solver. Boundary conditions and external forces should be given at these times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/adutils/solvers.jl#L166-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.compute_boundary_info" href="#NNFEM.compute_boundary_info"><code>NNFEM.compute_boundary_info</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_boundary_info(domain::Domain, globdat::GlobalData, ts::Array{Float64})</code></pre><p>Computes the boundary information <code>ubd</code> and <code>abd</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/adutils/solvers.jl#L126-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NNFEM.compute_external_force" href="#NNFEM.compute_external_force"><code>NNFEM.compute_external_force</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_external_force(domain::Domain, globdat::GlobalData, ts::Array{Float64})</code></pre><p>Computes the external force (body force, edge force and force due to boundary acceleration).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/732a7a0c20c721d372af70a92c52acf4d986daae/src/adutils/solvers.jl#L149-L153">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../representation/">« Representations of Constitutive Relation</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 14 April 2020 05:52">Tuesday 14 April 2020</span>. Using Julia version 1.4.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
