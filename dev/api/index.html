<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · NNFEM</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NNFEM</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Getting Started</a></li><li class="current"><a class="toctext" href>API Reference</a><ul class="internal"><li><a class="toctext" href="#Elements-1">Elements</a></li><li><a class="toctext" href="#Materials-1">Materials</a></li><li><a class="toctext" href="#Assembly-1">Assembly</a></li><li><a class="toctext" href="#Solvers-1">Solvers</a></li><li><a class="toctext" href="#Utilities-1">Utilities</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>API Reference</a></li></ul><a class="edit-page" href="https://github.com/kailaix/NNFEM.jl/blob/master/docs/src/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API Reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-Reference-1" href="#API-Reference-1">API Reference</a></h1><h2><a class="nav-anchor" id="Elements-1" href="#Elements-1">Elements</a></h2><h2><a class="nav-anchor" id="Materials-1" href="#Materials-1">Materials</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NNFEM.PlaneStressIncompressibleRivlinSaunders" href="#NNFEM.PlaneStressIncompressibleRivlinSaunders"><code>NNFEM.PlaneStressIncompressibleRivlinSaunders</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Pascon, João Paulo.  &quot;Large deformation analysis of plane-stress hyperelastic problems via triangular membrane finite elements.&quot;  International Journal of Advanced Structural Engineering (2019): 1-20.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/2b8fe8455042ceabb880dc4a58f1cf3d86d49d8d/src/materials/PlaneStressIncompressibleRivlinSaunders.jl#L4-L8">source</a></section><h2><a class="nav-anchor" id="Assembly-1" href="#Assembly-1">Assembly</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NNFEM.assembleMassMatrix!-Tuple{GlobalData,Domain}" href="#NNFEM.assembleMassMatrix!-Tuple{GlobalData,Domain}"><code>NNFEM.assembleMassMatrix!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">compute constant mass matrix
due to the time-dependent Dirichlet boundary condition
mass matrix = M,    MID
              MID&#39;  MDD
save M and MID and lump(M)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/2b8fe8455042ceabb880dc4a58f1cf3d86d49d8d/src/fem/assembly.jl#L205-L211">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NNFEM.tfAssembleInternalForce-Tuple{Domain,Function,PyCall.PyObject,PyCall.PyObject,PyCall.PyObject,PyCall.PyObject}" href="#NNFEM.tfAssembleInternalForce-Tuple{Domain,Function,PyCall.PyObject,PyCall.PyObject,PyCall.PyObject,PyCall.PyObject}"><code>NNFEM.tfAssembleInternalForce</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">domain   : finite element domain, for data structure
nn: Neural network constitutive law, with 
E_all    : all strains for the current time-step, with size (neles*nGauss, nstrains)
DE_all   : all strains for the last time-step, with size (neles*nGauss, nstrains)
w∂E∂u_all: multiplication of the Gaussian weight and ∂E∂u^T for current time-step, 
           with size (neles*nGauss, ndofs_per_element, nstrains)
σ0_all   : all stresses for the last time-step, with size (neles*nGauss, nstrains)

compute local internal force f_int and then assemble to F_int</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/2b8fe8455042ceabb880dc4a58f1cf3d86d49d8d/src/fem/assembly.jl#L35-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NNFEM.Domain-Tuple{Array{Float64,N} where N,Array,Int64,Array{Int64,N} where N,Array{Float64,N} where N,Array{Int64,N} where N,Array{Float64,N} where N}" href="#NNFEM.Domain-Tuple{Array{Float64,N} where N,Array,Int64,Array{Int64,N} where N,Array{Float64,N} where N,Array{Int64,N} where N,Array{Float64,N} where N}"><code>NNFEM.Domain</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Creating a finite element domain
nodes: n by 2 float 64, node coordinates
elements: element list
ndims: 2
EBC: n by 2 Int64, nodal Dirichlet boundary condition, -1 time-independent, -2 time-dependent
g: n by 2 Float64, values for nodal time-independent Dirichlet boundary condition
FBC: n by 2 Int64, nodal force boundary condition, -1 time-independent, -2 time-dependent
f: n by 2 Float64, values for nodal force time independent force boundary condition</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/2b8fe8455042ceabb880dc4a58f1cf3d86d49d8d/src/fem/fem.jl#L80-L90">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NNFEM.convertState-Tuple{Domain,Array{Float64,N} where N,String}" href="#NNFEM.convertState-Tuple{Domain,Array{Float64,N} where N,String}"><code>NNFEM.convertState</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">:param self: Domain
:param state : 1D array to convert
:param compress_or_expand  : &quot;Compress&quot; or &quot;Expand&quot; 

&quot;Compress&quot;, the state has all freedoms on all nodes, remove these freedoms on EBC
&quot;Expand&quot;,   the state has only active freedoms on active nodes (active means not prescribed), 
            set these freedoms on EBC to 0

:return:</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/2b8fe8455042ceabb880dc4a58f1cf3d86d49d8d/src/fem/fem.jl#L268-L278">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NNFEM.setNeumannBoundary!-Tuple{Domain,Array{Int64,N} where N,Array{Float64,N} where N}" href="#NNFEM.setNeumannBoundary!-Tuple{Domain,Array{Int64,N} where N,Array{Float64,N} where N}"><code>NNFEM.setNeumannBoundary!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">:param FBC[n, d] is the boundary condition of node n&#39;s dth freedom,
    -1 means fixed force load boundary condition
    -2 means time dependent force load boundary condition
:param f[n, d] is the fixed force load value
:return:</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/2b8fe8455042ceabb880dc4a58f1cf3d86d49d8d/src/fem/fem.jl#L215-L222">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NNFEM.updateDomainStateBoundary!-Tuple{Domain,GlobalData}" href="#NNFEM.updateDomainStateBoundary!-Tuple{Domain,GlobalData}"><code>NNFEM.updateDomainStateBoundary!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Update domain time dependent boundary information.</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/2b8fe8455042ceabb880dc4a58f1cf3d86d49d8d/src/fem/fem.jl#L295-L297">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NNFEM.updateStates!-Tuple{Domain,GlobalData}" href="#NNFEM.updateStates!-Tuple{Domain,GlobalData}"><code>NNFEM.updateStates!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">:param disp: neqs array
:param vel : neqs array

update Dstate in Domain, update state in Domain
:return:</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/2b8fe8455042ceabb880dc4a58f1cf3d86d49d8d/src/fem/fem.jl#L241-L247">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NNFEM.assembleSparseMatrixPattern!-Tuple{Domain}" href="#NNFEM.assembleSparseMatrixPattern!-Tuple{Domain}"><code>NNFEM.assembleSparseMatrixPattern!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">compute constant stiff matrix pattern</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/2b8fe8455042ceabb880dc4a58f1cf3d86d49d8d/src/fem/fem.jl#L372-L375">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NNFEM.getDofs-Tuple{Domain,Int64}" href="#NNFEM.getDofs-Tuple{Domain,Int64}"><code>NNFEM.getDofs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">:param el_nodes: 1d array
:return: the corresponding dofs ids, u0,u1, .., v0, v1, ..</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/2b8fe8455042ceabb880dc4a58f1cf3d86d49d8d/src/fem/fem.jl#L350-L353">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NNFEM.getExternalForce!-Tuple{Domain,GlobalData,Array{Float64,N} where N}" href="#NNFEM.getExternalForce!-Tuple{Domain,GlobalData,Array{Float64,N} where N}"><code>NNFEM.getExternalForce!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">the external force include the Dirichlet boundary condition effect</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/2b8fe8455042ceabb880dc4a58f1cf3d86d49d8d/src/fem/fem.jl#L331-L333">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NNFEM.setDirichletBoundary!-Tuple{Domain,Array{Int64,N} where N,Array{Float64,N} where N}" href="#NNFEM.setDirichletBoundary!-Tuple{Domain,Array{Int64,N} where N,Array{Float64,N} where N}"><code>NNFEM.setDirichletBoundary!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">:param EBC[n, d] is the boundary condition of of node n&#39;s dth freedom,
    -1 means fixed Dirichlet boundary nodes
    -2 means time dependent Dirichlet boundary nodes
:param g[n, d] is the fixed Dirichlet boundary value

:param nbc:
:return:</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/2b8fe8455042ceabb880dc4a58f1cf3d86d49d8d/src/fem/fem.jl#L159-L168">source</a></section><h2><a class="nav-anchor" id="Solvers-1" href="#Solvers-1">Solvers</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NNFEM.DynamicMatLawLoss-Tuple{Domain,Array{Float64,N} where N,Array{Float64,N} where N,Array{Float64,N} where N,Function}" href="#NNFEM.DynamicMatLawLoss-Tuple{Domain,Array{Float64,N} where N,Array{Float64,N} where N,Array{Float64,N} where N,Function}"><code>NNFEM.DynamicMatLawLoss</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">domain   : finite element domain, for data structure
E_all    : all strains for the whole simulation, with size (NT+1, neles*nGauss, nstrains)
w∂E∂u_all: multiplication of the Gaussian weight and ∂E∂u^T for the whole simulation, 
           with size (NT+1, neles*nGauss, ndofs_per_element, nstrains)
F_tot : approximated internal force for the whole simulation, with size(NT, ndofs), 
        from time n=1 to time n=NT

form the loss function, based on dynamic equilibrium 
    (Mddu + fint(NN, E, DE) + MIDddu_bc = fext

loss = ∑ ||fint(NN, E, DE) - (fext - MIDddu_bc - Mddu)||^2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/2b8fe8455042ceabb880dc4a58f1cf3d86d49d8d/src/solvers/NNSolver.jl#L4-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NNFEM.DynamicMatLawLoss-Union{Tuple{S}, Tuple{T}, Tuple{Domain,GlobalData,Array{T,N} where N,Array{S,N} where N,Function,Float64}} where S where T" href="#NNFEM.DynamicMatLawLoss-Union{Tuple{S}, Tuple{T}, Tuple{Domain,GlobalData,Array{T,N} where N,Array{S,N} where N,Function,Float64}} where S where T"><code>NNFEM.DynamicMatLawLoss</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">domain   : finite element domain
globdat  : finite element data structure
state_history : displace history of all time steps and all nodes, 
                a list of NT+1  ndof-displacement vectors, including time 0
                hcat(state_history...) gives a matrix of size(ndof-displacement, NT+1)
fext_history  : external force load of all time steps and all nodes, 
                a list of NT+1 ndof-external-force vectors, including time 0
                hcat(fext_history...) gives a matrix of size(ndof-external-force, NT+1)
nn: Neural network
Δt: time step size

compute loss function from state and external force history</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/2b8fe8455042ceabb880dc4a58f1cf3d86d49d8d/src/solvers/NNSolver.jl#L158-L171">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NNFEM.preprocessing-Tuple{Domain,GlobalData,Array{Float64,N} where N,Float64,Int64}" href="#NNFEM.preprocessing-Tuple{Domain,GlobalData,Array{Float64,N} where N,Float64,Int64}"><code>NNFEM.preprocessing</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>preprocessing(domain::Domain, globdat::GlobalData, F_ext::Array{Float64},Δt::Float64, n::Int64)</p><p>Same as <code>preprocessing</code>, except that only the first <code>n</code> steps are considered</p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/2b8fe8455042ceabb880dc4a58f1cf3d86d49d8d/src/solvers/NNSolver.jl#L277-L281">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NNFEM.preprocessing-Tuple{Domain,GlobalData,Array{Float64,N} where N,Float64}" href="#NNFEM.preprocessing-Tuple{Domain,GlobalData,Array{Float64,N} where N,Float64}"><code>NNFEM.preprocessing</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">compute F_tot ≈ F_int , ane E_all</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/2b8fe8455042ceabb880dc4a58f1cf3d86d49d8d/src/solvers/NNSolver.jl#L199-L201">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NNFEM.AdaptiveSolver-NTuple{6,Any}" href="#NNFEM.AdaptiveSolver-NTuple{6,Any}"><code>NNFEM.AdaptiveSolver</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Adaptive Solver, adjust the time step, if this step fails, redo the step with half of
the time step size

return globdat, domain</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/2b8fe8455042ceabb880dc4a58f1cf3d86d49d8d/src/solvers/Solvers.jl#L272-L277">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NNFEM.ExplicitSolver-Tuple{Any,Any,Any}" href="#NNFEM.ExplicitSolver-Tuple{Any,Any,Any}"><code>NNFEM.ExplicitSolver</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Central Difference Explicit solver for Ma + fint = fext     a, v, u are acceleration, velocity and displacement</p><pre><code class="language-none">u_{n+1} = u_n + dtv_n + dt^2/2 a_n
v_{n+1} = v_n + dt/2(a_n + a_{n+1})

M a_{n+1} + C v_{n+1} + R(u_{n+1}) = P_{n+1}
(M + dt/2 C) a_{n+1} = P_{n+1} - R(u_{n+1}) - C(v_n + dt/2 a_{n})


Alternative, todo:
M a_n + C v_n + R(u_n) = P_n
M(u_{n+1} - 2u_n + u_{n-1}) + dt/2*C(u_{n+1} - u_{n-1}) + dt^2 R(u_n) = dt^2 P_n
(M + dt/2 C) u_{n+1} = dt^2(P_n - R(u_n) + dt/2 C u_{n-1} + M(2u_n - u_{n-1})

For the first step
u_{-1} = u_0 - dt*v_0 + dt^2/2 a_0
a_0 = M^{-1}(-Cv_0 - R(u_0) + P_0)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/2b8fe8455042ceabb880dc4a58f1cf3d86d49d8d/src/solvers/Solvers.jl#L3-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NNFEM.NewmarkSolver" href="#NNFEM.NewmarkSolver"><code>NNFEM.NewmarkSolver</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Implicit solver for Ma + C v + R(u) = P
a, v, u are acceleration, velocity and displacement

u_{n+1} = u_n + dtv_n + dt^2/2 ((1 - 2eta)a_n + 2eta a_{n+1})
v_{n+1} = v_n + dt((1 - gamma)a_n + gamma a_{n+1})

M a_{n+0.5} + fint(u_{n+0.f}) = fext_{n+0.5}

αm = (2ho_oo - 1)/(ho_oo + 1)
αf = ho_oo/(ho_oo + 1)

β2 = 0.5*(1 - αm + αf)^2
γ = 0.5 - αm + αf

absolution error ε = 1e-8, 
relative error ε0 = 1e-8  

return true or false indicating converging or not</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/2b8fe8455042ceabb880dc4a58f1cf3d86d49d8d/src/solvers/Solvers.jl#L63-L82">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NNFEM.StaticSolver" href="#NNFEM.StaticSolver"><code>NNFEM.StaticSolver</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Implicit solver for fint(u) = fext
u is the displacement
Newton iteration, with time-stepping at P
u_{n+1} = u_n -  dR(u)^{-1} *(R(u) - P)

:param app:
:param u_0:
:return: u_{oo}</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/2b8fe8455042ceabb880dc4a58f1cf3d86d49d8d/src/solvers/Solvers.jl#L224-L233">source</a></section><h2><a class="nav-anchor" id="Utilities-1" href="#Utilities-1">Utilities</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NNFEM.gradtest-Tuple{Function,Array{Float64,N} where N}" href="#NNFEM.gradtest-Tuple{Function,Array{Float64,N} where N}"><code>NNFEM.gradtest</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">gradtest(f::Function, x0::Array{Float64}; scale::Float64 = 1.0)</code></pre><p>Testing the gradients of a vector function <code>f</code>. </p></div></div><a class="source-link" target="_blank" href="https://github.com/kailaix/NNFEM.jl/blob/2b8fe8455042ceabb880dc4a58f1cf3d86d49d8d/src/utils/Testsuit.jl#L3-L7">source</a></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Getting Started</span></a></footer></article></body></html>
