var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference-1","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Elements-1","page":"API Reference","title":"Elements","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"Modules = [NNFEM]\nPages   = [\"FiniteStrainContinuum.jl\", \"FiniteStrainContinuum.jl\", \"FiniteStrainContinuum.jl\"]","category":"page"},{"location":"api/#NNFEM.FiniteStrainContinuum","page":"API Reference","title":"NNFEM.FiniteStrainContinuum","text":"FiniteStrainContinuum\n\nImplements the finite strain element. \n\neledim: spatial dimension of the element (default = 2).\nmat: constitutive law, a length #elem vector of materials such as PlaneStress\nelnodes: the node indices in this finite element, an integer array \nprops: property dictionary \ncoords: coordinates of the vertices of the element\ndhdx, weights, hs: data for integral \nstress: stress at each quadrature points\n\n\n\n\n\n","category":"type"},{"location":"api/#Materials-1","page":"API Reference","title":"Materials","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"Modules = [NNFEM]\nPages   = [\"PlaneStress.jl\", \"PlaneStrain.jl\", \"PlaneStressIncompressibleRivlinSaunders.jl\",\n            \"PlaneStressPlasticity\"]","category":"page"},{"location":"api/#NNFEM.PlaneStrain","page":"API Reference","title":"NNFEM.PlaneStrain","text":"\n\n\n\n","category":"type"},{"location":"api/#NNFEM.PlaneStressIncompressibleRivlinSaunders","page":"API Reference","title":"NNFEM.PlaneStressIncompressibleRivlinSaunders","text":"Pascon, João Paulo.  \"Large deformation analysis of plane-stress hyperelastic problems via triangular membrane finite elements.\"  International Journal of Advanced Structural Engineering (2019): 1-20.\n\n\n\n\n\n","category":"type"},{"location":"api/#Assembly-1","page":"API Reference","title":"Assembly","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"Modules = [NNFEM]\nPages   = [\"assembly.jl\", \"fem.jl\"]","category":"page"},{"location":"api/#NNFEM.assembleInternalForce","page":"API Reference","title":"NNFEM.assembleInternalForce","text":"Numerically assemble internal force vector, compute local internal force f_int \nfrom domain.state and then assemble to F_int\n- 'globdat': GlobalData\n- 'domain': Domain, finite element domain, for data structure\n- 'Δt':  Float64, current time step size\nReturn F_int: Float64[neqs], internal force vector\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.assembleMassMatrix!-Tuple{GlobalData,Domain}","page":"API Reference","title":"NNFEM.assembleMassMatrix!","text":"compute constant sparse mass matrix\ndue to the time-dependent Dirichlet boundary condition\nmass matrix = M,    MID\n              MID'  MDD\n\n- 'globdat': GlobalData\n- 'domain': Domain, finite element domain, for data structure\nhere M is Float64[neqns, neqns]\n     MID is Float64[neqns, nd1]\n     Mlumped is Float64[neqns]\n\nupdate M and MID and Mlumpe in globaldat\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.assembleStiffAndForce","page":"API Reference","title":"NNFEM.assembleStiffAndForce","text":"Numerically assemble internal force vector and stiffness matrix, compute local internal force f_int/ \nstiffness matrix Slocal from domain.state and then assemble to F_int/Ksparse\n- 'globdat': GlobalData\n- 'domain': Domain, finite element domain, for data structure\n- 'Δt':  Float64, current time step size\nReturn F_int: Float64[neqs], internal force vector\nReturn Ksparse: Float64[neqs, neqns], sparse stiffness matrix\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.tfAssembleInternalForce-Tuple{Domain,Function,PyCall.PyObject,PyCall.PyObject,PyCall.PyObject,PyCall.PyObject}","page":"API Reference","title":"NNFEM.tfAssembleInternalForce","text":"Tensorflow version of assembling internal force vector, compute local internal \nforce f_int and then assemble to F_int, which generates inverse problem automatically.\n\n- 'domain': Domain, finite element domain, for data structure\n- 'nn': Function strain -> stress, neural network constitutive law function \n- 'E_all': PyObject(Float64)[neles*nGauss, nstrains], neles*nGauss is the number of Gaussian quadrature points, \n           nstrain is the number of strain components. All strains for the current time-step\n- 'DE_all': PyObject(Float64)[neles*nGauss, nstrains], neles*nGauss is the number of Gaussian quadrature points, \n            nstrain is the number of strain components. All strains for the previous time-step\n- 'w∂E∂u_all': PyObject(Float64)[neles*nGauss, ndofs_per_element, nstrains], neles*nGauss is the number of Gaussian quadrature points, \n               ndofs_per_element is the number of freedoms per element, nstrain is the number of strain components.\n               Multiplication of the Gaussian weight and ∂E∂u^T for current time-step, \n        \n- 'σ0_all': PyObject(Float64)[neles*nGauss, nstrains], neles*nGauss is the number of Gaussian quadrature points, \nnstrain is the number of strain components.  All stresses for the last time-step\n\nReturn: internal force vector F_int, PyObject(Float64)[neqns] and the predicted stresses at the \n        current step σ_all, PyObject(Float64)[neles*nGauss, nstrains]\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.Domain","page":"API Reference","title":"NNFEM.Domain","text":"Domain\n\nDate structure for the computatational domain\n\nnnodes: Int64, number of nodes (each quadratical quad element has 9 nodes)\nnodes: Float64[nnodes, ndims], coordinate array of all nodes\nneles: number of elements \nelements: Element[neles], element array, each element is a struct \nndims: Int64, dimension of the problem space \nstate: Float64[nnodes*ndims] current displacement of all nodal freedoms, Float64[1:nnodes] are for the first direction.\nDstate: Float64[nnodes*ndims] previous displacement of all nodal freedoms, Float64[1:nnodes] are for the first direction.\n'LM':  Int64[neles][ndims], LM(e,d) is the global equation number(active freedom number) of element e's d th freedom,         -1 means fixed (time-independent) Dirichlet        -2 means time-dependent Dirichlet\n'DOF': Int64[neles][ndims], DOF(e,d) is the global freedom number of element e's d th freedom\n'ID':  Int64[nnodes, ndims], ID(n,d) is the equation number(active freedom number) of node n's dth freedom,         -1 means fixed (time-independent) Dirichlet        -2 means time-dependent Dirichlet\n'neqs':  Int64,  number of equations or active freedoms\n'eqtodof':  Int64[neqs], map from to equation number(active freedom number) to the freedom number (Int64[1:nnodes] are for the first direction) \n'doftoeq':  Int64[nnodes*ndims], map from freedom number(Int64[1:nnodes] are for the first direction) to active freedoms(equation number)\n'EBC':  Int64[nnodes, ndims], EBC[n,d] is the displacement boundary condition of node n's dth freedom,          -1 means fixed(time-independent) Dirichlet boundary nodes          -2 means time-dependent Dirichlet boundary nodes\n'g':  Float64[nnodes, ndims], values for fixed(time-independent) Dirichlet boundary conditions of node n's dth freedom,\n'FBC': Int64[nnodes, ndims], FBC[n,d] is the force load boundary condition of node n's dth freedom,          -1 means constant(time-independent) force load boundary nodes          -2 means time-dependent force load boundary nodes\n'fext':  Float64[neqs], constant(time-independent) force load boundary conditions for these freedoms\n'time': Float64, current time\n'npoints': Int64, number of points (each quadratical quad element has 4 points, npoints==nnodes, when porder==1)\n'nodetopoint': Int64[nnodes]:map from node number to point point, -1 means the node is not a geometry point\n'ii_stiff': Int64[], first index of the sparse matrix representation of the stiffness matrix\n'jj_stiff': Int64[], second index of the sparse matrix representation of the stiffness matrix\n'vvstiffele_indptr': Int64[], Int64[e] is the first index entry for the e's element of the sparse matrix representation of the stiffness matrix\n'vv_stiff': Float64[], values of the sparse matrix representation of the stiffness matrix\n'iidfintdstress': Int64[], first index of the sparse matrix representation of the dfint_dstress matrix \n'jjdfintdstress': Int64[], second index of the sparse matrix representation of the dfint_dstress matrix\n'vvdfintdstresseleindptr': Int64[], Int64[e] is the first index entry for the e's element of the sparse matrix representation of the dfint_dstress matrix\n'vvdfintdstress': Float64[], values of the sparse matrix representation of the dfint_dstress matrix \n'iidstraindstate': Int64[], first index of the sparse matrix representation of the dstrain_dstate matrix\n'jjdstraindstate': Int64[], second index of the sparse matrix representation of the dstrain_dstate matrix\n'vvdstraindstateeleindptr': Int64[], Int64[e] is the first index entry for the e's element of the sparse matrix representation of the stiffness matrix\n'vvdstraindstate': Float64[], values of the sparse matrix representation of the dstrain_dstate matrix\n'history': Dict{String, Array{Array{Float64}}}, dictionary between string and its time-histories quantity Float64[ntime][]\n\n\n\n\n\n","category":"type"},{"location":"api/#NNFEM.Domain-Tuple{Array{Float64,N} where N,Array,Int64,Array{Int64,N} where N,Array{Float64,N} where N,Array{Int64,N} where N,Array{Float64,N} where N}","page":"API Reference","title":"NNFEM.Domain","text":"Creating a finite element domain\n\n- `nodes`: Float64[nnodes, ndims], coordinate array of all nodes\n- `elements`: Element[neles], element array, each element is a struct \n- `ndims`: Int64, dimension of the problem space \n- 'EBC':  Int64[nnodes, ndims], EBC[n,d] is the displacement boundary condition of node n's dth freedom,\n       -1 means fixed(time-independent) Dirichlet boundary nodes\n       -2 means time-dependent Dirichlet boundary nodes\n- 'g':  Float64[nnodes, ndims], values for fixed(time-independent) Dirichlet boundary conditions of node n's dth freedom,\n- 'FBC': Int64[nnodes, ndims], FBC[n,d] is the force load boundary condition of node n's dth freedom,\n       -1 means constant(time-independent) force load boundary nodes\n       -2 means time-dependent force load boundary nodes\n- 'f':  Float64[nnodes, ndims], values for constant(time-independent) force load boundary conditions of node n's dth freedom,\n\nReturn: Domain, the finite element domain\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.GlobalData","page":"API Reference","title":"NNFEM.GlobalData","text":"GlobalData\n\nStore data for finite element update, assume the problem has n freedoms\n\nstate: Float64[n],  displacement array at the current time, only for active freedoms,   the ordering is based on the equation number, here ndims=2 is the dimension of the problem space\nstate: Float64[n],  displacement array at the previous time\nvelo: Float64[n],  velocity array at the current \nacce: Float64[n],  acceleration array at the current \ntime: float, current time\nM: Float64[n,n] spares mass matrix\nMlumped: Float64[n] lumped mass array\nMID: Float64[n, nd1] off-diagonal part of the mass matrix, between the active freedoms and the time-dependent Dirichlet freedoms, assume there are nd time-dependent Dirichlet freedoms\nEBC_func: function Float64:t-> Float64[n_d1] float array, time-dependent Dirichlet boundary condition (ordering is direction first then node number, u1, u3, ... v1, v4 ...)\nFBC_func: function Float64:t-> Float64[n_t1] float array, time-dependent load boundary condition (ordering is direction first then node number, u1, u3, ... v1, v4 ...)\n\n\n\n\n\n","category":"type"},{"location":"api/#NNFEM.setGeometryPoints!-Tuple{Domain,Int64,Array{Int64,N} where N}","page":"API Reference","title":"NNFEM.setGeometryPoints!","text":"In the constructor \nUpdate the node_to_point map \n\n- `self`: Domain, finit element domain\n- 'npoints': Int64, number of points (each quadratical quad element has 4 points, npoints==nnodes, when porder==1)\n- 'node_to_point': Int64[nnodes]:map from node number to point point, -1 means the node is not a geometry point\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.setNeumannBoundary!-Tuple{Domain,Array{Int64,N} where N,Array{Float64,N} where N}","page":"API Reference","title":"NNFEM.setNeumannBoundary!","text":"In the constructor\nUpdate the external force vector fext\n- 'self': Domain\n- 'FBC': Int64[nnodes, ndims], FBC[n,d] is the force load boundary condition of node n's dth freedom,\n       -1 means constant(time-independent) force load boundary nodes\n       -2 means time-dependent force load boundary nodes\n- 'f':  Float64[nnodes, ndims], values for constant(time-independent) force load boundary conditions of node n's dth freedom,\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.updateDomainStateBoundary!-Tuple{Domain,GlobalData}","page":"API Reference","title":"NNFEM.updateDomainStateBoundary!","text":"Update time dependent boundary of state fext in Domain based on the time-dependent boundary functions in GlobalData.\n\n'self': Domain\n'globaldat': GlobalData\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.updateStates!-Tuple{Domain,GlobalData}","page":"API Reference","title":"NNFEM.updateStates!","text":"At each time step\nUpdate the state and Dstate in Domain from GlobalData\nstate and Dstate in GlobalData are only for active freedoms (equations)\nstate and Dstate in Domain are only for all freedoms, they are used for constructing the internal force and/or stiffness matrix\nupdate the state and acc history of the Domain\n- 'self': Domain\n- 'globaldat': GlobalData\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.assembleSparseMatrixPattern!-Tuple{Domain}","page":"API Reference","title":"NNFEM.assembleSparseMatrixPattern!","text":"Compute constant stiff, dfint_dstress, dstrain_dstate matrix patterns\n- 'self': Domain\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.commitHistory-Tuple{Domain}","page":"API Reference","title":"NNFEM.commitHistory","text":"Update current step strain, stress in the history map of the Domain\nstrain and stress are both Float[ngp, nstrain], ngp is the number of Gaussian quadrature point\nnstrain=1 for 1D and nstrain = 3 for 2D \nThe strain is in Voigt notation\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.getCoords-Tuple{Domain,Array{Int64,N} where N}","page":"API Reference","title":"NNFEM.getCoords","text":"Get the coordinates of several nodes (possibly in one element)\n- 'self': Domain\n- 'el_nodes': Int64[n], node array\n\nReturn: Float64[n, ndims], the coordinates of these nodes\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.getDofs-Tuple{Domain,Int64}","page":"API Reference","title":"NNFEM.getDofs","text":"Get the global freedom numbers of the element\n- 'self': Domain\n- 'iele': Int64, element number\n\nReturn: Int64[], the global freedom numbers of the element (ordering in local element ordering)\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.getDstate-Tuple{Domain,Array{Int64,N} where N}","page":"API Reference","title":"NNFEM.getDstate","text":"Get the displacements of several nodes (possibly in one element) at the previous time step\n- 'self': Domain\n- 'el_nodes': Int64[n], node array\n\nReturn: Float64[n, ndims], the displacements of these nodes at the previous time step\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.getEqns-Tuple{Domain,Int64}","page":"API Reference","title":"NNFEM.getEqns","text":"Get the equation numbers(active freedom numbers) of the element\n- 'self': Domain\n- 'iele': Int64, element number\n\nReturn: Int64[], the equation numbers(active freedom numbers) of the element (ordering in local element ordering)\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.getExternalForce!-Tuple{Domain,GlobalData,Array{Float64,N} where N}","page":"API Reference","title":"NNFEM.getExternalForce!","text":"Compute external force vector, including external force load and time-dependent Dirichlet boundary conditions\nThe function needs to be called after\nfunction updateDomainStateBoundary!(self::Domain, globaldat::GlobalData)\nwhich computes the external force vector from external force load\n\n- 'self': Domain\n- 'globaldat': GlobalData\n- 'fext': Float64[neqs], container for the external force vector\n\nreturn external force vector at the present step\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.getState-Tuple{Domain,Array{Int64,N} where N}","page":"API Reference","title":"NNFEM.getState","text":"Get the displacements of several nodes (possibly in one element)\n- 'self': Domain\n- 'el_nodes': Int64[n], node array\n\nReturn: Float64[n, ndims], the displacements of these nodes\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.setDirichletBoundary!-Tuple{Domain,Array{Int64,N} where N,Array{Float64,N} where N}","page":"API Reference","title":"NNFEM.setDirichletBoundary!","text":"In the constructor \nUpdate the fixed (time-independent Dirichlet boundary) state entries \nBuild LM, and DOF array\n- 'self': Domain\n- 'EBC':  Int64[nnodes, ndims], EBC[n,d] is the displacement boundary condition of node n's dth freedom,\n       -1 means fixed(time-independent) Dirichlet boundary nodes\n       -2 means time-dependent Dirichlet boundary nodes\n- 'g':  Float64[nnodes, ndims], values for fixed(time-independent) Dirichlet boundary conditions of node n's dth freedom,\n''\n\n\n\n\n\n","category":"method"},{"location":"api/#Solvers-1","page":"API Reference","title":"Solvers","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"Modules = [NNFEM]\nPages   = [\"NNSolver.jl\", \"Solvers.jl\"]","category":"page"},{"location":"api/#NNFEM.DynamicMatLawLoss-Tuple{Domain,Array{Float64,N} where N,Array{Float64,N} where N,Array{Float64,N} where N,Function}","page":"API Reference","title":"NNFEM.DynamicMatLawLoss","text":"domain   : finite element domain, for data structure\nE_all    : all strains for the whole simulation, with size (NT+1, neles*nGauss, nstrains)\nw∂E∂u_all: multiplication of the Gaussian weight and ∂E∂u^T for the whole simulation, \n           with size (NT+1, neles*nGauss, ndofs_per_element, nstrains)\nF_tot : approximated internal force for the whole simulation, with size(NT, ndofs), \n        from time n=1 to time n=NT\n\nform the loss function, based on dynamic equilibrium \n    (Mddu + fint(NN, E, DE) + MIDddu_bc = fext\n\nloss = ∑ ||fint(NN, E, DE) - (fext - MIDddu_bc - Mddu)||^2\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.DynamicMatLawLoss-Union{Tuple{S}, Tuple{T}, Tuple{Domain,GlobalData,Array{T,N} where N,Array{S,N} where N,Function,Float64}} where S where T","page":"API Reference","title":"NNFEM.DynamicMatLawLoss","text":"domain   : finite element domain\nglobdat  : finite element data structure\nstate_history : displace history of all time steps and all nodes, \n                a list of NT+1  ndof-displacement vectors, including time 0\n                hcat(state_history...) gives a matrix of size(ndof-displacement, NT+1)\nfext_history  : external force load of all time steps and all nodes, \n                a list of NT+1 ndof-external-force vectors, including time 0\n                hcat(fext_history...) gives a matrix of size(ndof-external-force, NT+1)\nnn: Neural network\nΔt: time step size\n\ncompute loss function from state and external force history\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.LSfittingStress-Tuple{Domain,GlobalData,Array{Float64,N} where N,Array{Float64,N} where N,Float64,String}","page":"API Reference","title":"NNFEM.LSfittingStress","text":"LSfittingStress(domain::Domain, globdat::GlobalData, state_history::Array{Float64}, F_ext::Array{Float64},Δt::Float64, method::String)\n\nFor quadratic element, nx, ny, ... elements in each direction The number of equations are neqs ≈ 2(2nx + 1)(2ny + 1) Plan 1: Assume the stress in each element is constant, the number of unknows are 3nxny Plan 2: Assume the stress in each element is linear, the number of unknows are 3(nx+1)(ny+1) on each nodes\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.LSfittingStressHelper-Tuple{Any,Array{Float64,N} where N,String}","page":"API Reference","title":"NNFEM.LSfittingStressHelper","text":"Compute the stiff and dfintdstress, based on the state in domain and dstraindstate\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.preprocessing-Tuple{Domain,GlobalData,Array{Float64,N} where N,Float64}","page":"API Reference","title":"NNFEM.preprocessing","text":"compute F_tot ≈ F_int , ane E_all\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.AdaptiveSolver-NTuple{6,Any}","page":"API Reference","title":"NNFEM.AdaptiveSolver","text":"Adaptive Solver, solve the whole process, if this step fails, redo the step with half of\nthe time step size, when there are continuing 5 successful steps, double the step size when dt < T/NT\n\n- 'solvername': String,  so far only NewmarkSolver is supported\n- 'globdat', GlobalData\n- 'domain', Domain\n- 'T', Float64, total simulation time\n- 'NT', Int64, planned time steps\n- 'args', Dict{String, Value}, arguments for the solver\n\n\nreturn globdat, domain, ts, here ts is Float64[nteps+1]\n\ntodo For the first time step a0 = M^{-1}(- f^{int}(u0) + f^{ext}_0)\n\nWe assume globdat.acce[:] = a_0 and so far initialized to 0\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.ExplicitSolver-Tuple{Any,Any,Any}","page":"API Reference","title":"NNFEM.ExplicitSolver","text":"Central Difference explicit solver\n\n'Δt': Float64,  time step size \n'globdat', GlobalData\n'domain', Domain\n\nCentral Difference explicit solver for M a + fint(u) = fext(u), with lumped mass matrix (MID = 0) a, v, u are acceleration, velocity and displacement\n\nbeginalign\nu_n+1 = u_n + dtv_n + dt^22 a_n \nv_n+1 = v_n + dt2(a_n + a_n+1) \nM a_n+1 + f^int(u_n+1) = f^ext_n+1 \nM a_n+1 = f^ext_n+1 - f^int(u_n+1) \nendalign\n\nuse the current states a, v, u, time in globdat, and update these stetes to next time step update domain history \n\ntodo For the first time step a0 = M^{-1}(- f^{int}(u0) + f^{ext}_0)\n\nWe assume globdat.acce[:] = a_0 and so far initialized to 0\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.NewmarkSolver","page":"API Reference","title":"NNFEM.NewmarkSolver","text":"NewmarkSolver (Generalized-alpha) implicit solver\n\n'Δt': Float64,  time step size \n'globdat', GlobalData\n'domain', Domain\n'αm', Float64\n'αf', Float64 \n'ε', Float64, absolute error for Newton convergence\n'ε0', Float64, relative error for Newton convergence\n'maxiterstep', Int64, maximum iteration number for Newton convergence\n'η', Float64, Newton step size at the first iteration\n'failsafe', Bool, if failsafe is true, when the Newton fails to converge,              revert back, and return false\n\nImplicit solver for Ma  + fint(u) = fext a, v, u are acceleration, velocity and displacement respectively.\n\nu_n+1 = u_n + dtv_n + dt^22 ((1 - 2beta)a_n + 2beta a_n+1)\nv_n+1 = v_n + dt((1 - gamma)a_n + gamma a_n+1)\n2beta = 05*(1 - αm + αf)^2\ngamma = 05 - alpha_m + alpha_f\n\n\na_n+1-alpha_m = (1-alpha_m)a_n+1 + alpha_m a_n \nv_n+1-alpha_f = (1-alpha_f)v_n+1 + alpha_f v_n\nu_n+1-alpha_f = (1-alpha_f)u_n+1 + alpha_f u_n\nM a_n+1-alpha_m + f^int(u_n+1-alpha_f) = f^ext_n+1-alpha_f\n\n'a_{n+1}' is solved by \n\nM ((1-alpha_m)a_n+1 + alpha_m a_n)  \n+ f^int((1-alpha_f)(u_n + dtv_n + dt^22 ((1 - 2beta)a_n + 2beta a_n+1))) + alpha_f u_n) \n= f^ext_n+1-alpha_f\n\nAs for '\\alpham' and '\\alphaf'\n\nalpha_m = (2rho_infty - 1)(rho_infty + 1)\nalpha_f = rho_infty(rho_infty + 1)\n\nuse the current states a, v, u, time in globdat, and update these stetes to next time step update domain history \n\ntodo For the first time step a0 = M^{-1}(- f^{int}(u0) + f^{ext}_0)\n\nWe assume globdat.acce[:] = a_0 and so far initialized to 0 We also assume the external force is conservative (it does not depend on the current deformation)\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.StaticSolver","page":"API Reference","title":"NNFEM.StaticSolver","text":"Static implicit solver\n\n'globdat', GlobalData\n'domain', Domain\n'loaditerstep', Int64, load stepping steps\n'ε', Float64, absolute error for Newton convergence\n'maxiterstep', Int64, maximum iteration number for Newton convergence\n\nSolver for fint(u) = fext with load stepping, u is the displacement. Iteratively solve u_{i}\n\nf^int(u_i) = iloaditerstep f^ext\n\ntodo We assume the external force is conservative (it does not depend on the current deformation)\n\n\n\n\n\n","category":"function"},{"location":"api/#Utilities-1","page":"API Reference","title":"Utilities","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"Modules = [NNFEM]\nPages   = [\"io.jl\", \"matrix.jl\", \"shapeFunctions\", \"Testsuit.jl\", \"Visualize.jl\", \"linearConstitutiveLaw.jl\"]","category":"page"},{"location":"api/#NNFEM.orthotropic_H-Tuple{PyCall.PyObject}","page":"API Reference","title":"NNFEM.orthotropic_H","text":"orthotropic_H(y::PyObject)\northotropic_H(o::Array)\n\nCreates a symmetric matrix from 4 parameters\n\nH = beginbmatrix\ny_1  y_2  0 \ny_2  y_3  0  \n0  0  y_4\nendbmatrix\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.spd_Chol_Orth-Tuple{Array}","page":"API Reference","title":"NNFEM.spd_Chol_Orth","text":"spd_Chol_Orth(o::Array)\nspd_Chol_Orth(o::PyObject)\n\nCreates a SPD matrix from 4 scalars. \n\nA = LL\n\nwhere\n\nL = beginbmatrix\no_1   \no_2  o_3  \n    o_4 \nendbmatrix\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.spd_Cholesky-Tuple{Array}","page":"API Reference","title":"NNFEM.spd_Cholesky","text":"spd_Cholesky(o::Array)\nspd_Cholesky(o::PyObject)\n\nCreates a SPD matrix from 6 scalars. \n\nA = LL\n\nwhere\n\nL = beginbmatrix\no_1    \no_2  o_4  \no_3  o_5  o_6 \nendbmatrix\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.spd_H-Tuple{PyCall.PyObject,Array{Float64,2}}","page":"API Reference","title":"NNFEM.spd_H","text":"spd_H(o::PyObject, H0::Array{Float64,2})\nspd_H(o::Array, H0::Array)\n\nCreates a SPD matrix from 3 scalars\n\nH = H_0 - fracH_0nnH_01+nH_0n\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.spd_zero_to_H-Tuple{PyCall.PyObject,Array{Float64,2}}","page":"API Reference","title":"NNFEM.spd_zero_to_H","text":"spd_zero_to_H(o::Array)\nspd_zero_to_H(o::Array, H0inv::Array{Float64,2})\n\nCreates a SPD matrix from 4 scalars. \n\nA = (H_0^-1 +LL)^-1\n\nwhere\n\nL =  beginbmatrix\no_1   \no_2  o_3  \n    o_4\nendbmatrix\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.sym_H-Tuple{PyCall.PyObject}","page":"API Reference","title":"NNFEM.sym_H","text":"sym_H(y::PyObject)\nsym_H(o::Array)\n\nCreates a symmetric matrix from 6 parameters\n\nH = beginbmatrix\ny_1  y_2  y_3 \ny_2  y_4  y_5  \ny_3  y_5  y_6\nendbmatrix\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.gradtest-Tuple{Function,Array{Float64,N} where N}","page":"API Reference","title":"NNFEM.gradtest","text":"gradtest(f::Function, x0::Array{Float64}; scale::Float64 = 1.0)\n\nTesting the gradients of a vector function f.  Here x0 is n-dimensional vector, f takes an n-dimensional vector as inputs, and outputs a m dimensional vector. The function tests the second order convergence of f\n\nf(x_0+gamma c) - f(x_0) - gamma nabla f(x_0) c_2 = mathcalO(gamma^2)\n\n\n\n\n\n","category":"method"},{"location":"hyperelasticity/#Hyperelasticity-1","page":"Hyperelasticity","title":"Hyperelasticity","text":"","category":"section"},{"location":"hyperelasticity/#","page":"Hyperelasticity","title":"Hyperelasticity","text":"Parameter Value\nT 0.2 (hyperelasticity), 200 (plasticity)\nNT 200\nn_x^f n_y^f (20,10)\nn_x n_y (10,5)\nL_x L_y (0.1,0.05)\n \n ","category":"page"},{"location":"hyperelasticity/#Instruction-for-Reproducing-Results-in-the-Paper-1","page":"Hyperelasticity","title":"Instruction for Reproducing Results in the Paper","text":"","category":"section"},{"location":"hyperelasticity/#","page":"Hyperelasticity","title":"Hyperelasticity","text":"Step 1: Generate Data","category":"page"},{"location":"hyperelasticity/#","page":"Hyperelasticity","title":"Hyperelasticity","text":"sh GenerateData.sh ","category":"page"},{"location":"hyperelasticity/#","page":"Hyperelasticity","title":"Hyperelasticity","text":"Step 2: Train the Neural Network","category":"page"},{"location":"hyperelasticity/#","page":"Hyperelasticity","title":"Hyperelasticity","text":"sh TrainNN.sh","category":"page"},{"location":"hyperelasticity/#","page":"Hyperelasticity","title":"Hyperelasticity","text":"Step 1: Generate Data","category":"page"},{"location":"hyperelasticity/#","page":"Hyperelasticity","title":"Hyperelasticity","text":"sh GenerateData.sh ","category":"page"},{"location":"hyperelasticity/#","page":"Hyperelasticity","title":"Hyperelasticity","text":"Step 2: Use small stress data to train a linear estimate (this is only done once)","category":"page"},{"location":"hyperelasticity/#","page":"Hyperelasticity","title":"Hyperelasticity","text":"julia Linear_Train_NNPlatePull.jl","category":"page"},{"location":"hyperelasticity/#","page":"Hyperelasticity","title":"Hyperelasticity","text":"Step 3: Prefit the neural network","category":"page"},{"location":"hyperelasticity/#","page":"Hyperelasticity","title":"Hyperelasticity","text":"sh NNPrefit.sh","category":"page"},{"location":"hyperelasticity/#","page":"Hyperelasticity","title":"Hyperelasticity","text":"Step 4: Train the neural network ","category":"page"},{"location":"hyperelasticity/#","page":"Hyperelasticity","title":"Hyperelasticity","text":"sh TrainNN.sh","category":"page"},{"location":"instructions/#Instructions-for-Running-Benchmarks-1","page":"Instructions for Running Benchmarks","title":"Instructions for Running Benchmarks","text":"","category":"section"},{"location":"instructions/#Plate/MustiScale2-1","page":"Instructions for Running Benchmarks","title":"Plate/MustiScale2","text":"","category":"section"},{"location":"instructions/#","page":"Instructions for Running Benchmarks","title":"Instructions for Running Benchmarks","text":"Generate Data with GenerateData.sh. \nPretrain NN with Linear Models","category":"page"},{"location":"instructions/#","page":"Instructions for Running Benchmarks","title":"Instructions for Running Benchmarks","text":"julia NNPreLSfit.jl","category":"page"},{"location":"instructions/#","page":"Instructions for Running Benchmarks","title":"Instructions for Running Benchmarks","text":"Check NNPreLSfit.jl results","category":"page"},{"location":"instructions/#","page":"Instructions for Running Benchmarks","title":"Instructions for Running Benchmarks","text":"julia Adj_Loss.jl","category":"page"},{"location":"instructions/#","page":"Instructions for Running Benchmarks","title":"Instructions for Running Benchmarks","text":"","category":"page"},{"location":"method/#Problem-and-Methodology-1","page":"Problem and Methodology","title":"Problem and Methodology","text":"","category":"section"},{"location":"method/#Hyper-elasticity-1","page":"Problem and Methodology","title":"Hyper-elasticity","text":"","category":"section"},{"location":"method/#","page":"Problem and Methodology","title":"Problem and Methodology","text":"In the hyperelasticity case, the constitutive relation is given by the general form ","category":"page"},{"location":"method/#","page":"Problem and Methodology","title":"Problem and Methodology","text":"sigma = f(varepsilon) ","category":"page"},{"location":"method/#","page":"Problem and Methodology","title":"Problem and Methodology","text":"In our approach, this relation is modeled by ","category":"page"},{"location":"method/#","page":"Problem and Methodology","title":"Problem and Methodology","text":"sigma = H_theta(varepsilon) (varepsilon-varepsilon_0) + sigma_0 tag1","category":"page"},{"location":"method/#","page":"Problem and Methodology","title":"Problem and Methodology","text":"where varepsilon_0 and sigma_0 are strain and stress at the last time step and H_theta  is a neural network with weights and biases theta. H_theta(varepsilon) is constrained to a SPD matrix, which can be achieved by using a custom layer for the output of the neural network ","category":"page"},{"location":"method/#","page":"Problem and Methodology","title":"Problem and Methodology","text":"H_theta(varepsilon) = LLquad L = beginbmatrix\no_1(varepsilontheta)  0  0\no_2(varepsilontheta)  o_3(varepsilontheta)  0\no_4(varepsilontheta)  o_5(varepsilontheta)  o_6(varepsilontheta)\nendbmatrix","category":"page"},{"location":"method/#","page":"Problem and Methodology","title":"Problem and Methodology","text":"Here o_i are the outputs of a fully connected neural network; in other words, the first part of the neural network takes varepsilon as input and outputs a 6D vector o_i. ","category":"page"},{"location":"method/#","page":"Problem and Methodology","title":"Problem and Methodology","text":"(Image: )","category":"page"},{"location":"method/#","page":"Problem and Methodology","title":"Problem and Methodology","text":"We choose the form (1) based on the observation that if varepsilon=varepsilon_0 then we must have sigma=sigma_0. Additionally, H_theta(varepsilon) is the tangent matrix of the constitutive relation and that's why we assume SPD for H_theta. ","category":"page"},{"location":"method/#Plasticity-1","page":"Problem and Methodology","title":"Plasticity","text":"","category":"section"},{"location":"method/#","page":"Problem and Methodology","title":"Problem and Methodology","text":"In the plasticity case, the constitutive relation is more complicated. In general, the strain is decomposed into the elastic strain and plastic strain","category":"page"},{"location":"method/#","page":"Problem and Methodology","title":"Problem and Methodology","text":"varepsilon = varepsilon^e + varepsilon^p","category":"page"},{"location":"method/#","page":"Problem and Methodology","title":"Problem and Methodology","text":"The constitutive relations for both strains are described by (alpha is called the  internal variable.)","category":"page"},{"location":"method/#","page":"Problem and Methodology","title":"Problem and Methodology","text":"Strain Component Constitutive Relation\nvarepsilon^e sigma = Evarepsilon^e\nvarepsilon^p beginaligneddot varepsilon^e = dotlambda fracpartial f(sigma alpha)partial sigma lambda f(sigmaalpha) = 0 quad f(sigmaalpha)leq 0 quad lambda geq 0 dotalpha  =  h(sigma alpha)endaligned","category":"page"},{"location":"method/#","page":"Problem and Methodology","title":"Problem and Methodology","text":"In contract to hyperelasticity, the plasticity constitutive relation is history dependent, i.e., the current tangent matrix does not only depdent on varepsilon but also varepsilon_0, sigma_0 and sigma_0 (The subscription \"0\" denotes values at last time step). Additionally, in plasticity, when the strain (or stress) is very small, the material undergoes elasticity; therefore, we expect a certain \"elasticity regime\". This motivates us to model the plasticity relation by ","category":"page"},{"location":"method/#","page":"Problem and Methodology","title":"Problem and Methodology","text":"sigma = Big(eta(sigma_0)H_0  + (1-eta(sigma_0))H_theta(varepsilon varepsilon_0 sigma_0 alpha_0)Big)  (varepsilon-varepsilon_0) + sigma_0","category":"page"},{"location":"method/#","page":"Problem and Methodology","title":"Problem and Methodology","text":"where eta(sigma_0) is close to 1 when sigma_0 is small and thus the tangent matrix is approximately H_0 (a constant matrix independent of the strain and the stress). In practice, we found that ignoring the internal variable does not affect our results too much and therefore the model we use is ","category":"page"},{"location":"method/#","page":"Problem and Methodology","title":"Problem and Methodology","text":"sigma = Big(eta(sigma_0)H_0  + (1-eta(sigma_0))H_theta(varepsilon varepsilon_0 sigma_0)Big)  (varepsilon-varepsilon_0) + sigma_0 tag2","category":"page"},{"location":"method/#Multiscale-1","page":"Problem and Methodology","title":"Multiscale","text":"","category":"section"},{"location":"method/#","page":"Problem and Methodology","title":"Problem and Methodology","text":"The constitutive relation model (2) is also used for the multiscale case, where the material is a mixture of plasticity materials and elasticity materials. ","category":"page"},{"location":"method/#","page":"Problem and Methodology","title":"Problem and Methodology","text":"note: Note\n","category":"page"},{"location":"method/#","page":"Problem and Methodology","title":"Problem and Methodology","text":"​\tIf the problem can be reduced to 1D, we can construct a neural network that takes a 3D vector (varepsilon varepsilon_0 sigma_0) as inputs and outputs a stress scalar sigma. Here varepsilon_0 and sigma_0 are strains  and stresses at last time step. We do not have use the special neural network structure as that in the high dimensional case because the 1D constitutive relation is much simpler. ","category":"page"},{"location":"plasticity/#Plasticity-1","page":"Plasticity","title":"Plasticity","text":"","category":"section"},{"location":"plasticity/#Training-and-Testing-Set-1","page":"Plasticity","title":"Training and Testing Set","text":"","category":"section"},{"location":"plasticity/#","page":"Plasticity","title":"Plasticity","text":"We generate 10 sets of data for training the neural network (100, 101, 102, 103, 104, 200, 201, 202, 203, 204), 4 sets of data for validating (105, 106, 205, 206) and 1 set of data for testing (300). The setting are as follows (the arrows represents force direction but may indicate different force magnitude; the shaded area indicates fixed sides). ","category":"page"},{"location":"plasticity/#","page":"Plasticity","title":"Plasticity","text":"(Image: )","category":"page"},{"location":"plasticity/#","page":"Plasticity","title":"Plasticity","text":"(Image: )","category":"page"},{"location":"plasticity/#","page":"Plasticity","title":"Plasticity","text":"(Image: )","category":"page"},{"location":"plasticity/#Visualization-1","page":"Plasticity","title":"Visualization","text":"","category":"section"},{"location":"plasticity/#","page":"Plasticity","title":"Plasticity","text":"Here we show the stress and displacements at the corner of the training and testing data.","category":"page"},{"location":"plasticity/#","page":"Plasticity","title":"Plasticity","text":"ID Stress u_x u_y\n100 (Image: ) (Image: ) (Image: )\n101 (Image: ) (Image: ) (Image: )\n102 (Image: ) (Image: ) (Image: )\n103 (Image: ) (Image: ) (Image: )\n104 (Image: ) (Image: ) (Image: )\n105 (Image: ) (Image: ) (Image: )\n106 (Image: ) (Image: ) (Image: )\n200 (Image: ) (Image: ) (Image: )\n201 (Image: ) (Image: ) (Image: )\n202 (Image: ) (Image: ) (Image: )\n203 (Image: ) (Image: ) (Image: )\n204 (Image: ) (Image: ) (Image: )\n205 (Image: ) (Image: ) (Image: )\n206 (Image: ) (Image: ) (Image: )\n300 (Image: ) (Image: ) (Image: )","category":"page"},{"location":"#Getting-Started-1","page":"Getting Started","title":"Getting Started","text":"","category":"section"}]
}
