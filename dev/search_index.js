var documenterSearchIndex = {"docs":
[{"location":"ex_simulation/#Simulaton-Code-Structure","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"","category":"section"},{"location":"ex_simulation/","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"We use the Newmark method or the generalized alpha scheme to solve the dynamics equation numerically. ","category":"page"},{"location":"ex_simulation/","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"mddot mathbfu + gammadotmathbfu + kmathbfu = mathbff","category":"page"},{"location":"ex_simulation/","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"The discretized form is ","category":"page"},{"location":"ex_simulation/","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"Mmathbfa + Cmathbf v + K mathbf d = mathbf F","category":"page"},{"location":"ex_simulation/","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"For a detailed description of the generalized alpha scheme, see this post. ","category":"page"},{"location":"ex_simulation/","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"NNFEM.jl supports two types of boundary conditions, the Dirichlet boundary condition and the Neumann boundary condition. Both boundary conditions can be time independent or dependent. Read [] for how to specify time dependent boundary conditions and [] for how to specify time independent boundary conditions. ","category":"page"},{"location":"ex_simulation/","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"Here is a script for simulation using an explicit solver. ","category":"page"},{"location":"ex_simulation/","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"NT = 100\nΔt = 1.0e-2\nT = NT * Δt\n\nm, n =  20, 10\nh = 0.1\n\n# Create a very simple mesh\nelements = SmallStrainContinuum[]\nprop = Dict(\"name\"=> \"PlaneStrain\", \"rho\"=> 0.0876584, \"E\"=>0.07180760098, \"nu\"=>0.4)\ncoords = zeros((m+1)*(n+1), 2)\nfor j = 1:n\n    for i = 1:m\n        idx = (m+1)*(j-1)+i \n        elnodes = [idx; idx+1; idx+1+m+1; idx+m+1]\n        ngp = 3\n        nodes = [\n            (i-1)*h (j-1)*h\n            i*h (j-1)*h\n            i*h j*h\n            (i-1)*h j*h\n        ]\n        coords[elnodes, :] = nodes\n        push!(elements, SmallStrainContinuum(nodes, elnodes, prop, ngp))\n    end\nend\n\n# fixed on the bottom, push on the right\nEBC = zeros(Int64, (m+1)*(n+1), 2)\nFBC = zeros(Int64, (m+1)*(n+1), 2)\ng = zeros((m+1)*(n+1), 2)\nf = zeros((m+1)*(n+1), 2)\nfor i = 1:m+1\n    for j = 1:n+1\n        idx = (j-1)*(m+1) + i \n        if j==n+1\n            EBC[idx,:] .= -1\n        end\n        if i==m+1 && j!=n+1\n            FBC[idx,1] = -1\n            f[idx,1] = -0.001\n        end\n    end\nend\nndims = 2\ndomain = Domain(coords, elements, ndims, EBC, g, FBC, f)\n\n\nDstate = zeros(domain.neqs)\nstate = zeros(domain.neqs)\nvelo = zeros(domain.neqs)\nacce = zeros(domain.neqs)\ngt = nothing\nft = nothing\nglobdat = GlobalData(state, Dstate, velo, acce, domain.neqs, gt, ft)\n\n\nassembleMassMatrix!(globdat, domain)\nupdateStates!(domain, globdat)\n\nfor i = 1:NT\n@info i \n    global globdat, domain = ExplicitSolverStep(globdat, domain, Δt)\nend\nvisualize_displacement(domain)\nvisualize_von_mises_stress(domain)","category":"page"},{"location":"ex_simulation/","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"The explicit solver is implemented as follows","category":"page"},{"location":"ex_simulation/","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"function ExplicitSolverStep(globdat::GlobalData, domain::Domain, Δt::Float64)\n    u = globdat.state[:]\n    ∂u  = globdat.velo[:]\n    ∂∂u = globdat.acce[:]\n\n    globdat.time  += Δt\n    fext = getExternalForce(domain, globdat)\n\n    u += Δt*∂u + 0.5*Δt*Δt*∂∂u\n    ∂u += 0.5*Δt * ∂∂u\n    \n    domain.state[domain.eq_to_dof] = u[:]\n    fint  = assembleInternalForce( globdat, domain, Δt)\n    ∂∂up = globdat.M\\(fext - fint)\n\n    ∂u += 0.5 * Δt * ∂∂up\n\n    globdat.Dstate = globdat.state[:]\n    globdat.state = u[:]\n    globdat.velo = ∂u[:]\n    globdat.acce = ∂∂up[:]\n    \n    commitHistory(domain)\n    updateStates!(domain, globdat)\n\n    return globdat, domain\nend","category":"page"},{"location":"ex_simulation/","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"We show the follow chart of the implementation. Note inside the ExplicitSolverStep function, the data is exchanged between globdat and domain. In general, globdat saves only the active components of the degrees of freedom (excluding Dirichlet boundary nodes) while domain maintains the full information. ","category":"page"},{"location":"ex_simulation/","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"(Image: image-20200409172855057)","category":"page"},{"location":"ex_simulation/#Updating-the-Boundary-Conditions","page":"Simulaton Code Structure","title":"Updating the Boundary Conditions","text":"","category":"section"},{"location":"ex_simulation/","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"We give a short description on how the boundary conditions are tackled in NNFEM. In general, we have two kinds of boundary conditions; namely, they are Dirichlet boundary conditions (also known as essential boundary conditions) and Neumann boundary conditions (also known as natural boundary conditions). They can be both time dependent or time independent. ","category":"page"},{"location":"ex_simulation/#Dirichlet-Boundary-Conditions","page":"Simulaton Code Structure","title":"Dirichlet Boundary Conditions","text":"","category":"section"},{"location":"ex_simulation/","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"The basic idea for tackling Dirichlet boundary conditions is to trim the coefficient matrices M and K, and update the right hand side force vectors (consider a linear problem)","category":"page"},{"location":"ex_simulation/","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"M ddot mathbfu + K mathbfu = mathbff","category":"page"},{"location":"ex_simulation/","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"We have","category":"page"},{"location":"ex_simulation/","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"M_II ddot mathbfu_I + M_ID ddot mathbfu_D + K_I mathbfu = mathbff","category":"page"},{"location":"ex_simulation/","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"Here I stands for the active DOF, and D stands for time-dependent Dirichlet boundary condition DOF. Note ddotmathbfu = mathbf0 for time-independent Dirichlet nodes. ","category":"page"},{"location":"ex_simulation/","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"assembleMassMatrix! computes and stores M_{II} and M_{ID} in GlobalData. In the time stepping, when getExternalForce is called, M_ID ddot mathbfu_D is computed and substracted from right hand side. ","category":"page"},{"location":"ex_simulation/","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"For the stiffness matrix K_I mathbfu, in every iteration, given a candidate mathbfu, assembleStiffAndForce computes ","category":"page"},{"location":"ex_simulation/","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"K_II K_I mathbfu","category":"page"},{"location":"ex_simulation/","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"This information is sufficient to solve for ddot mathbfu or mathbfu. ","category":"page"},{"location":"qanda/#Q-and-A","page":"Q&A","title":"Q&A","text":"","category":"section"},{"location":"qanda/","page":"Q&A","title":"Q&A","text":"Q: How can I get the number of Dirichlet boundary nodes (including directions)?","category":"page"},{"location":"qanda/","page":"Q&A","title":"Q&A","text":"sum(domain.EBC[:].!=0)","category":"page"},{"location":"static1d/#Static-1D-Problem","page":"Static 1D Problem","title":"Static 1D Problem","text":"","category":"section"},{"location":"solvers/#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"There are two types of solvers: AD-free solvers, which does not support automatic differentiation but in general more efficient due to less bookkeeping; and AD-capable solvers, which has automatic differentiation so you can use them to solve inverse problems.","category":"page"},{"location":"solvers/#AD-free-Solvers","page":"Solvers","title":"AD-free Solvers","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"AD-free solvers are located in src/fem/solvers/Solver.jl and src/fem/solver/SolverV2.jl. These solvers are implemented in pure Julia. ","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"LinearStaticSolver","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Consider a static linear elasticity problem ","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"beginaligned\ntextdivsigma = f  (xy) in Omega \nsigma = Hepsilon  \nu(xy) = u_0(xy)  (xy) in partial Omega\nendaligned","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"on a unit square domain Omega. We can compare the result with PoreFlow.jl. ","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"using Markdown\nMarkdown.parse(\"```julia\\\\n\"*String(read(\"../../test/solvers/linearstatic.jl\"))*\"```\")","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Here shows the result for PoreFlow (left: PoreFlow, right: Exact)","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"(Image: )","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Here shows the result for NNFEM (left: NNFEM, right: Exact)","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"(Image: )","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"ExplicitSolverStep\nImplicitStaticSolver\nGeneralizedAlphaSolverStep","category":"page"},{"location":"solvers/#AD-capable-Solvers","page":"Solvers","title":"AD-capable Solvers","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"AD-capable solver are located in src/adutils/solvers.jl. These solvers are implemented with highly optimized C++ kernels. The usage of these solvers are different from AD-free solvers, where all data structures are wrapped in domain and globaldata. Here users need to provide variables such as displacement, velocity, acceleration, stress, strain, etc., explicitly to the solvers. To this end, the following utiltity functions are provided: ","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"compute_boundary_info\ncompute_external_force\nExplicitSolverTime\nGeneralizedAlphaSolverTime","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"A list of available:","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"LinearStaticSolver","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"We consider the same linear elasticity problem problem used in AD-free solvers.","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"using Markdown\nMarkdown.parse(\"```julia\\\\n\"*String(read(\"../../test/solvers/linearstatic_ad.jl\"))*\"```\")","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"(Image: )","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"ExplicitSolver\nGeneralizedAlphaSolver\nExplicitStaticSolver\nImplicitStaticSolver","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Core-Data-Structure","page":"API Reference","title":"Core Data Structure","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Domain\nDomain(nodes::Array{Float64}, elements::Array, ndims::Int64 = 2,\n    EBC::Union{Missing, Array{Int64}} = missing, g::Union{Missing, Array{Float64}} = missing, FBC::Union{Missing, Array{Int64}} = missing, \n    f::Union{Missing, Array{Float64}} = missing, edge_traction_data::Array{Int64,2}=zeros(Int64,0,3))\nGlobalData\nGlobalData(state::Union{Array{Float64,1},Missing},Dstate::Union{Array{Float64,1},Missing},\n        velo::Union{Array{Float64,1},Missing},acce::Union{Array{Float64,1},Missing}, \n        neqs::Int64,\n        EBC_func::Union{Function, Nothing}=nothing, FBC_func::Union{Function, Nothing}=nothing,\n        Body_func::Union{Function,Nothing}=nothing, Edge_func::Union{Function,Nothing}=nothing)","category":"page"},{"location":"api/#NNFEM.Domain","page":"API Reference","title":"NNFEM.Domain","text":"Domain\n\nDate structure for the computatational domain.\n\nnnodes: Int64, number of nodes (each quadratical quad element has 9 nodes)\nnodes: Float64[nnodes, ndims], coordinate array of all nodes\nneles: number of elements \nelements: a list of neles element arrays, each element is a struct \nndims: Int64, dimension of the problem space \nstate: a matrix of size nnodes×ndims. Current displacement of all nodal freedoms, state[1:nnodes] are for the first direction.\nDstate: nnodes×ndims. Previous displacement of all nodal freedoms, Dstate[1:nnodes] are for the first direction.\nLM:  Int64[neles][ndims], LM(e,d) is the global equation number (active freedom number) of element e's d th freedom, \n   ∘ -1 means fixed (time-independent) Dirichlet\n\n   ∘ -2 means time-dependent Dirichlet\n\n   ∘ >0 means the global equation number\nDOF: a matrix of size neles×ndims, DOF(e,d) is the global freedom (including both active and inactive DOFs) number of element e's d th freedom.\nID:  a matrix of size nnodes×ndims. ID(n,d) is the equation number (active freedom number) of node n's d-th freedom, \n   ∘ -1 means fixed (time-independent) Dirichlet\n\n   ∘ -2 means time-dependent Dirichlet\n\n   ∘ >0 means the global equation number\nneqs:  Int64,  number of equations, a.k.a., active freedoms\neq_to_dof:  an integer vector of length neqs, map from to equation number (active freedom number) to the freedom number (Int64[1:nnodes] are for the first direction) \ndof_to_eq:  a bolean array of size nnodes×ndims, map from freedom number(Int64[1:nnodes] are for the first direction) to booleans (active freedoms(equation number) are true)\nEBC:  Int64[nnodes, ndims], EBC[n,d] is the displacement boundary condition of node n's dth freedom,          -1 means fixed(time-independent) Dirichlet boundary nodes          -2 means time-dependent Dirichlet boundary nodes\ng:  Float64[nnodes, ndims], values for fixed(time-independent) Dirichlet boundary conditions of node n's dth freedom,\nFBC: Int64[nnodes, ndims], FBC[n,d]` is the force load boundary condition of node n's dth freedom,          -1 means constant(time-independent) force load boundary nodes          -2 means time-dependent force load boundary nodes\nfext:  Float64[neqs], constant (time-independent) nodal forces on these freedoms\nEdge_Traction_Data: n × 3 integer matrix for natural boundary conditions.\n\nEdge_Traction_Data[i,1] is the element id,\nEdge_Traction_Data[i,2] is the local edge id in the element, where the force is exterted (should be on the boundary, but not required)\nEdge_Traction_Data[i,3] is the force id, which should be consistent with the last component of the Edge_func in the Globdat\n\ntime: Float64, current time\nnpoints: Int64, number of points (each quadratical quad element has 4 points, npoints==nnodes, when porder==1)\nnode_to_point: Int64[nnodes]:map from node number to point point, -1 means the node is not a geometry point\n\n\n\n\n\n","category":"type"},{"location":"api/#NNFEM.Domain-2","page":"API Reference","title":"NNFEM.Domain","text":"Domain(nodes::Array{Float64}, elements::Array, ndims::Int64 = 2,\nEBC::Union{Missing, Array{Int64}} = missing, g::Union{Missing, Array{Float64}} = missing, FBC::Union{Missing, Array{Int64}} = missing, \nf::Union{Missing, Array{Float64}} = missing, edge_traction_data::Array{Int64,2}=zeros(Int64,0,3))\n\nCreating a finite element domain.\n\nnodes: coordinate array of all nodes, a nnodes × 2 matrix\nelements: element array. Each element is a material struct, e.g., PlaneStrain. \nndims: dimension of the problem space. For 2D problems, ndims = 2. \nEBC:  nnodes × ndims integer matrix for essential boundary conditions   EBC[n,d]is the displacement boundary condition of noden`'s d-th freedom,\n∘ -1: fixed (time-independent) Dirichlet boundary nodes\n∘ -2: time-dependent Dirichlet boundary nodes\ng:  nnodes × ndims double matrix, values for fixed (time-independent) Dirichlet boundary conditions of node n's d-th freedom,\nFBC: nnodes × ndims integer matrix for nodal force boundary conditions.\n\nFBC[n,d] is the force load boundary condition of node n's dth freedom,\n\n∘ -1 means constant(time-independent) force load boundary nodes\n\n∘ -2 means time-dependent force load boundary nodes\n\nf:  nnodes × ndims double matrix, values for constant (time-independent) force load boundary conditions of node n's d-th freedom,\nEdge_Traction_Data: n × 3 integer matrix for natural boundary conditions.\n\nEdge_Traction_Data[i,1] is the element id, Edge_Traction_Data[i,2] is the local edge id in the element, where the force is exterted (should be on the boundary, but not required) Edge_Traction_Data[i,3] is the force id, which should be consistent with the last component of the Edge_func in the Globdat\n\nFor time-dependent boundary conditions (EBC or FBC entries are -2), the corresponding f or g entries are not used.\n\n\n\n\n\n","category":"type"},{"location":"api/#NNFEM.GlobalData","page":"API Reference","title":"NNFEM.GlobalData","text":"GlobalData\n\nStore data for finite element updates. Assume the problem has n freedoms,\n\nstate: a vector of length n. Displacement array at the current time, only for active freedoms.  The ordering is based on the equation number.\nDstate: a vector of length n. Displacement array at the previous time.\nvelo: a vector of length n. Velocity array at the current time.\nacce: a vector of length n. Acceleration array at the current time.\ntime: float, current time.\nM: a matrix of size ntimes n spares mass matrix\nMlumped: a vector of length n lumped mass array\nMID: Float64[n, nd1] off-diagonal part of the mass matrix, between the active freedoms and the time-dependent Dirichlet freedoms, assume there are nd time-dependent Dirichlet freedoms\nEBC_func: displacement d, velocity v, and acceleration a from time-dependent Dirichlet boundary conditions \n\nd v a = textEBC_func(texttime)\n\nThe length of each output is the same as number of \"-2\" in EBC array. The ordering is direction major, i.e., u_1 u_3 ldots v_1 v_3 ldots \n\nFBC_func: time-dependent load boundary condition. \n\nf = textFBC_func(texttime)\n\nHere f is a vector. Its length is the same as number of \"-2\" in FBC array. The ordering is direction major, i.e., u_1 u_3 ldots v_1 v_3 ldots \n\nBody_func: time-dependent/independent body force function. \n\nf = textBody_func(x_textarray y_textarray texttime)\n\nHere f is a vector or a matrix (second dimension is 2) depending on the dimension of state variables.  The output is a Ntimes n_textdim matrix, where N is the length of x_textarray or y_textarray, and n_textdim is the dimension of the problem (1 or 2).\n\nEdge_func: time-dependent/independent traction load. \n\nf = textEdge_func(x_textarray y_textarray texttime textid)\n\nHere f is a vector. Its length is the same as the length of x_textarray or y_textarray.\n\n\n\n\n\n","category":"type"},{"location":"api/#NNFEM.GlobalData-2","page":"API Reference","title":"NNFEM.GlobalData","text":"GlobalData(state::Union{Array{Float64,1},Missing},\n        Dstate::Union{Array{Float64,1},Missing},\n        velo::Union{Array{Float64,1},Missing},\n        acce::Union{Array{Float64,1},Missing}, \n        neqs::Int64,\n        EBC_func::Union{Function, Nothing}=nothing, FBC_func::Union{Function, Nothing}=nothing,\n        Body_func::Union{Function,Nothing}=nothing, Edge_func::Union{Function,Nothing}=nothing)\n\nThe size of state, Dstate, velo, acce must be neqs, i.e., the active DOFs. If they are missing, they are treated as zeros. \n\nstate, Dstate, velo, acce can be missing, in which case they are interpreted as zeros. \n\n\n\n\n\n","category":"type"},{"location":"api/#Domain","page":"API Reference","title":"Domain","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"getEqns\ngetDofs\ngetCoords\ngetNGauss\ngetGaussPoints\ngetState(domain::Domain, el_dofs::Array{Int64})\ngetStrain(domain::Domain)\ngetDStrain(domain::Domain)\ngetStress(domain::Domain, Δt::Float64 = 0.0; save_trace::Bool = false)\ngetElems\ngetStressHistory\ngetStrainHistory\ngetStateHistory","category":"page"},{"location":"api/#NNFEM.getEqns","page":"API Reference","title":"NNFEM.getEqns","text":"getEqns(domain::Domain, iele::Int64)\n\nGets the equation numbers (active freedom numbers) of the element.  This excludes both the time-dependent and time-independent Dirichlet boundary conditions. \n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.getDofs","page":"API Reference","title":"NNFEM.getDofs","text":"getDofs(domain::Domain, iele::Int64)\n\nGet the global freedom numbers of the element\n\ndomain: Domain\niele: Int64, element number\n\nReturn: Int64[], the global freedom numbers of the element (ordering in local element ordering)\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.getCoords","page":"API Reference","title":"NNFEM.getCoords","text":"getCoords(domain::Domain, el_nodes::Array{Int64})\n\nGet the coordinates of several nodes (possibly in one element)\n\ndomain: Domain\nel_nodes: Int64[n], node array\n\nReturn: Float64[n, ndims], the coordinates of these nodes\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.getNGauss","page":"API Reference","title":"NNFEM.getNGauss","text":"getNGauss(domain::Domain)\n\nGets the total number of Gauss quadrature points. \n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.getGaussPoints","page":"API Reference","title":"NNFEM.getGaussPoints","text":"getGaussPoints(elem::Continuum)\n\nReturns the Gauss quadrature nodes of the element in the undeformed domain\n\n\n\n\n\ngetGaussPoints(domain::Domain)\n\nReturns all Gauss points as a n_gtimes 2 matrix, where n_g is the total number of Gauss points.\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.getState-Tuple{Domain,Array{Int64,N} where N}","page":"API Reference","title":"NNFEM.getState","text":"getState(domain::Domain, el_dofs::Array{Int64})\n\nGet the displacements of several nodes (possibly in one element)\n\ndomain: Domain\nel_nodes: Int64[n], node array\n\nReturn: Float64[n, ndims], the displacements of these nodes\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.getStrain-Tuple{Domain}","page":"API Reference","title":"NNFEM.getStrain","text":"getStrain(domain::Domain)\n\nComputes the strain from the domain data. The output is n_gtimes 3 matrix, where n_g is the total number of Gauss points.  Each row is the strain tensor beginbmatrix epsilon_xx  epsilon_yy  gamma_xy endbmatrix\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.getDStrain-Tuple{Domain}","page":"API Reference","title":"NNFEM.getDStrain","text":"getDStrain(domain::Domain)\n\nComputes the strain at last time step from the domain data. The output is n_gtimes 3 matrix, where n_g is the total number of Gauss points.  Each row is the strain tensor beginbmatrix epsilon_xx  epsilon_yy  gamma_xy endbmatrix\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.getStress","page":"API Reference","title":"NNFEM.getStress","text":"getStress(domain::Domain, Δt::Float64 = 0.0; save_trace::Bool = false)\n\nReturns the stress based on domain.state and domain.Dstate. If save_trace is true,  the stress is also saved to domain.stress, which is useful for visualization. \n\nThe output is n_gtimes 3 matrix, where n_g is the total number of Gauss points.  Each row is the strain tensor beginbmatrix sigma_xx  sigma_yy  sigma_xy endbmatrix\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.getElems","page":"API Reference","title":"NNFEM.getElems","text":"getElems(domain::Domain)\n\nReturns the element connectivity matrix n_e times 4. This function implicitly assumes that all elements are quadrilateral.\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.getStressHistory","page":"API Reference","title":"NNFEM.getStressHistory","text":"getStressHistory(domain::Domain)\n\nReturns the stress history.\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.getStrainHistory","page":"API Reference","title":"NNFEM.getStrainHistory","text":"getStrainHistory(domain::Domain)\n\nReturns the strain history.\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.getStateHistory","page":"API Reference","title":"NNFEM.getStateHistory","text":"getStateHistory(domain::Domain)\n\nReturns the state history.\n\n\n\n\n\n","category":"function"},{"location":"api/#Elements","page":"API Reference","title":"Elements","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"getEdgeForce\ngetBodyForce\ngetMassMatrix\ngetNodes\ngetGaussPoints\ncommitHistory","category":"page"},{"location":"api/#NNFEM.getEdgeForce","page":"API Reference","title":"NNFEM.getEdgeForce","text":"getEdgeForce(elem::Continuum, iedge::Float64, fvalue::Array{Float64,2})\n\nReturns the force imposed by boundary tractions.\n\nfvalue is a n_edge_gausstimes 2 matrix, which is ordered the same as the     Gaussian points in undeformed parent edge element.\n\n    The element nodes are ordered as \n    #   4 ---- 3             #   4 --7-- 3\n    #                        #   8   9   6 \n    #   1 ---- 2             #   1 --5-- 2\n    for porder=1     or          porder=2\n    iedge 1, 2, 3, 4 are (1,2), (2,3), (3,4), (4,1)\n                    are (1,2,5), (2,3,6), (3,4,7), (4,1,8)\n\nReturns the nodal force due to the traction on the iedge-th edge of the element int_s mathbff(mathbfx)cdot delta mathbfu(mathbfx) d s    = int_e mathbff(xi)cdot delta mathbfu(xi)    fracpartial mathbfxpartial xi d xi\n\ntodo: Todo\nThis function imposes force in the undeformed domain. Add force in the deformed domain in the future.\n\n\n\n\n\ngetEdgeForce(domain::Domain, globdat::GlobalData, time::Float64)\n\nComputes the edge force vector F_mathrmedge defined in domain.edge_traction_data\n\nglobdat: GlobalData\ndomain: Domain, finite element domain, for data structure\ntime:  Float64, current time step size\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.getBodyForce","page":"API Reference","title":"NNFEM.getBodyForce","text":"getBodyForce(elem::Continuum, fvalue::Array{Float64,2})\n\nReturns the body force. \n\nfvalue is a n_gausstimes 2 matrix, which is ordered the same as    Gaussian points in the undeformed parent element.\n\nReturns the nodal force due to the body force int_e mathbff(mathbfx)cdot delta mathbfu(mathbfx) d mathbfx    = int_e mathbff(mathbfxi)cdot delta mathbfu(mathbfxi)    fracpartial mathbfxpartial mathbfxi d mathbfxi\n\ntodo: Todo\nAdd force in the deformed domain.\n\n\n\n\n\ngetBodyForce(elem::Continuum, fvalue::Array{Float64, 1})\n\nReturns \n\nint_A f delta v dx \n\non a specific element A fvalue has the same length as number of Gauss points. \n\n\n\n\n\ngetBodyForce(domain::Domain, globdat::GlobalData, time::Float64)\n\nComputes the body force vector F_mathrmbody of length neqs\n\nglobdat: GlobalData\ndomain: Domain, finite element domain, for data structure\nΔt:  Float64, current time step size\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.getMassMatrix","page":"API Reference","title":"NNFEM.getMassMatrix","text":"getMassMatrix(elem::Continuum)\n\nReturns the mass matrix and lumped mass matrix of the element elem.\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.getNodes","page":"API Reference","title":"NNFEM.getNodes","text":"getNodes(elem::Continuum)\n\nAlias for elem.elnodes\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.commitHistory","page":"API Reference","title":"NNFEM.commitHistory","text":"commitHistory(elem::Continuum)\n\nUpdates the historic parameters in the material properties. \n\n\n\n\n\ncommitHistory(domain::Domain)\n\nUpdate current step strain and stress in the history map of the domain.  This is essential for visualization and time dependent constitutive relations. \n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [NNFEM]\nPages   = [\"FiniteStrainContinuum.jl\", \"SmallStrainContinuum.jl\", \"FiniteStrainTruss.jl\"]","category":"page"},{"location":"api/#NNFEM.FiniteStrainContinuum","page":"API Reference","title":"NNFEM.FiniteStrainContinuum","text":"FiniteStrainContinuum(coords::Array{Float64}, elnodes::Array{Int64}, props::Dict{String, Any}, ngp::Int64=2)\n\n\n\n\n\n","category":"type"},{"location":"api/#NNFEM.FiniteStrainContinuum-2","page":"API Reference","title":"NNFEM.FiniteStrainContinuum","text":"FiniteStrainContinuum\n\nConstructs a finite strain element. \n\neledim: spatial dimension of the element (default = 2).\nmat: constitutive law, a length #elem vector of materials such as PlaneStress\nelnodes: the node indices in this finite element, an integer array \nprops: property dictionary \ncoords: coordinates of the vertices of the element\ndhdx, weights, hs: data for integral \nstress: stress at each quadrature points\n\nExample\n\n#   Local degrees of freedom \n#   4 ---- 3\n#\n#   1 ---- 2\n\nnx = 10\nny = 5\nh = 0.1\nelement = FiniteStrainContinuum[]\nprop = Dict(\"name\"=> \"PlaneStrain\", \"rho\"=> 0.0876584, \"E\"=>0.07180760098, \"nu\"=>0.4)\nfor j = 1:ny\n    for i = 1:nx \n        n = (nx+1)*(j-1) + (i-1)+1\n        elnodes = [n, n + 1, n + 1 + (nx + 1), n + (nx + 1)]\n        ngp = 3 # 3 x 3 Gauss points per element \n        coords = [(i-1)*h (j-1)*h\n                    i*h (j-1)*h\n                    i*h j*h\n                    (i-1)*h j*h]\n        push!(element, FiniteStrainContinuum(coords,elnodes, prop, ngp))\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"api/#NNFEM.SmallStrainContinuum","page":"API Reference","title":"NNFEM.SmallStrainContinuum","text":"SmallStrainContinuum(coords::Array{Float64}, elnodes::Array{Int64}, props::Dict{String, Any}, ngp::Int64=2)\n\n\n\n\n\n","category":"type"},{"location":"api/#NNFEM.SmallStrainContinuum-2","page":"API Reference","title":"NNFEM.SmallStrainContinuum","text":"SmallStrainContinuum\n\nConstructs a small strain element. \n\neledim: spatial dimension of the element (default = 2).\nmat: constitutive law, a length #elem vector of materials such as PlaneStress\nelnodes: the node indices in this finite element, an integer array \nprops: property dictionary \ncoords: coordinates of the vertices of the element\ndhdx: list of ngp shape functions for first order derivatives nabla phi(x) (ndof×2) on the Gaussian points\nweights: weight vector of length n_gauss_points, for numerical quadrature\nhs: list of ngp shape functions for function values phi(x) (length ndof vectors) on the Gaussian points\nstress: stress at each quadrature points; this field is reserved for visualization. \n\nExample\n\n#   Local degrees of freedom \n#   4 ---- 3\n#\n#   1 ---- 2\n\nnx = 10\nny = 5\nh = 0.1\nelement = SmallStrainContinuum[]\nprop = Dict(\"name\"=> \"PlaneStrain\", \"rho\"=> 0.0876584, \"E\"=>0.07180760098, \"nu\"=>0.4)\nfor j = 1:ny\n    for i = 1:nx \n        n = (nx+1)*(j-1) + (i-1)+1\n        elnodes = [n, n + 1, n + 1 + (nx + 1), n + (nx + 1)]\n        ngp = 3 # 3 x 3 Gauss points per element \n        coords = [(i-1)*h (j-1)*h\n                    i*h (j-1)*h\n                    i*h j*h\n                    (i-1)*h j*h]\n        push!(element, SmallStrainContinuum(coords,elnodes, prop, ngp))\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"api/#NNFEM.getInternalForce-Tuple{SmallStrainContinuum,Array{Float64,N} where N,Array{Float64,N} where N,Float64}","page":"API Reference","title":"NNFEM.getInternalForce","text":"getInternalForce(elem::SmallStrainContinuum, state::Array{Float64}, Dstate::Array{Float64}, Δt::Float64)\n\nReturns the internal force term. state and Dstate are restriction of full state variables to this element. \n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.getStiffAndForce-Tuple{SmallStrainContinuum,Array{Float64,N} where N,Array{Float64,N} where N,Float64}","page":"API Reference","title":"NNFEM.getStiffAndForce","text":"getStiffAndForce(elem::SmallStrainContinuum, state::Array{Float64}, Dstate::Array{Float64}, Δt::Float64)\n\nReturns the internal force term and the stiffness matrix. state and Dstate are restriction of full state variables to this element. \n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.getStiffAndForce1-Tuple{SmallStrainContinuum,Array{Float64,N} where N,Array{Float64,N} where N,Float64}","page":"API Reference","title":"NNFEM.getStiffAndForce1","text":"getStiffAndForce(elem::SmallStrainContinuum, state::Array{Float64}, Dstate::Array{Float64}, Δt::Float64)\n\nReturns the internal force term and the stiffness matrix. state and Dstate are restriction of full state variables to this element. \n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.getStrain-Tuple{SmallStrainContinuum,Array{Float64,N} where N}","page":"API Reference","title":"NNFEM.getStrain","text":"getStrain(elem::SmallStrainContinuum, state::Array{Float64})\n\nReturns the strain of this element.  state is restricted to this variable. \n\n\n\n\n\n","category":"method"},{"location":"api/#Materials","page":"API Reference","title":"Materials","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [NNFEM]\nPages   = [\"PlaneStress.jl\", \"PlaneStrain.jl\", \"PlaneStressIncompressibleRivlinSaunders.jl\",\n            \"PlaneStressPlasticity\"]","category":"page"},{"location":"api/#NNFEM.PlaneStress","page":"API Reference","title":"NNFEM.PlaneStress","text":"PlaneStress\n\nCreates a plane stress element\n\nH: Linear elasticity matrix, 3times3\nE: Young's modulus\nν: Poisson's ratio \nρ: density \nσ0: stress at the last time step \nσ0_: (for internal use), stress to be updated in commitHistory\nε0: strain at the last time step \nε0_: (for internal use), strain to be updated in commitHistory\n\nExample\n\nprop = Dict(\"name\"=> \"PlaneStress\", \"rho\"=> 0.0876584, \"E\"=>0.07180760098, \"nu\"=>0.4)\nmat = PlaneStress(prop)\n\n\n\n\n\n","category":"type"},{"location":"api/#NNFEM.PlaneStress-Tuple{Dict{String,Any}}","page":"API Reference","title":"NNFEM.PlaneStress","text":"PlaneStress(prop::Dict{String, Any})\n\nprop should contain at least the following three fields: E, nu, rho\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.PlaneStrain","page":"API Reference","title":"NNFEM.PlaneStrain","text":"PlaneStrain\n\nCreates a plane strain element\n\nH: Linear elasticity matrix, 3times3\nE: Young's modulus\nν: Poisson's ratio \nρ: density \nσ0: stress at the last time step \nσ0_: (for internal use), stress to be updated in commitHistory\nε0: strain at the last time step \nε0_: (for internal use), strain to be updated in commitHistory\n\nExample\n\nprop = Dict(\"name\"=> \"PlaneStrain\", \"rho\"=> 0.0876584, \"E\"=>0.07180760098, \"nu\"=>0.4)\nmat = PlaneStrain(prop)\n\n\n\n\n\n","category":"type"},{"location":"api/#NNFEM.PlaneStrain-Tuple{Dict{String,Any}}","page":"API Reference","title":"NNFEM.PlaneStrain","text":"PlaneStrain(prop::Dict{String, Any})\n\nprop should contain at least the following three fields: E, nu, rho\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.PlaneStressIncompressibleRivlinSaunders","page":"API Reference","title":"NNFEM.PlaneStressIncompressibleRivlinSaunders","text":"Pascon, João Paulo.  \"Large deformation analysis of plane-stress hyperelastic problems via triangular membrane finite elements.\"  International Journal of Advanced Structural Engineering (2019): 1-20.\n\n\n\n\n\n","category":"type"},{"location":"api/#Matrix-and-Vector-Assembly","page":"API Reference","title":"Matrix and Vector Assembly","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"assembleInternalForce\nassembleStiffAndForce\nassembleMassMatrix!\ngetBodyForce\ngetExternalForce","category":"page"},{"location":"api/#NNFEM.assembleInternalForce","page":"API Reference","title":"NNFEM.assembleInternalForce","text":"assembleInternalForce(domain::Domain, Δt::Float64 = 0.0)\n\nComputes the internal force vector F_mathrmint of length neqs\n\nglobdat: GlobalData\ndomain: Domain, finite element domain, for data structure\nΔt:  Float64, current time step size\n\nOnly the information in domain is used for computing internal force.  Therefore, the boundary conditions in domain must be set appropriately.\n\n\n\n\n\nassembleInternalForce(domain::Domain, nn::Function, E_all::PyObject, DE_all::PyObject, w∂E∂u_all::PyObject, σ0_all::PyObject)\n\nComputes local internal force fint and then assemble to Fint, which generates inverse problem automatically.\n\ndomain: finite element domain\nnn: constitutive relation for expressing stress = f(strain), assuming stress and strain are defined on Gauss points ((neles*nGauss) × nstrains).\nE_all: strain data of size (neles*nGauss) × nstrains at the current time step.\nDE_all: strain data of size (neles*nGauss) × nstrains at the last time step.\nw∂E∂u_all: sensitivity matrix of size (neles*nGauss) x ndofs_per_element x nstrains; neles*nGauss is the number of Gaussian quadrature points,  ndofs_per_element is the number of freedoms per element, and nstrain is the number of strain components. The sensitivity matrix already considers the quadrature weights. \n\ns_gji^e = w_g^efracpartial epsilon_g^epartial u_j^e\n\nwhere e is the element index, g is the Gaussian index. \n\nσ0_all: stress data of size neles*nGauss×nstrains at the last time step. \n\nReturn: \n\nF_mathrmint\n:  internal force vector of length neqns\nsigma_mathrmall\n: predicted stress at current step, a matrix of size (neles*nGauss) × nstrains\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.assembleStiffAndForce","page":"API Reference","title":"NNFEM.assembleStiffAndForce","text":"assembleStiffAndForce(domain::Domain, Δt::Float64 = 0.0)\n\nComputes the internal force and stiffness matrix. \n\ndomain: Domain, finite element domain, for data structure\nΔt:  Float64, current time step size\n\nReturns a length neqs vector F_mathrmint and neqs×neqs sparse stiffness matrix. \n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.assembleMassMatrix!","page":"API Reference","title":"NNFEM.assembleMassMatrix!","text":"assembleMassMatrix!(globaldat::GlobalData, domain::Domain)\n\nComputes the constant sparse mass matrix M_mathrmmass, the lumped mass matrix M_mathrmlump due to time-dependent Dirichlet boundary conditions, and store them in globaldat. \n\nM_mathrmmassbeginbmatrix\nM  M_ID \nM_ID^T  M_DD \nendbmatrix\n\nHere M is a neqns×neqns matrix, and M_ID is a neqns×nd matrix. M_mathrmlump assumes that the local mass matrix is a diagonal matrix. \n\nglobdat: GlobalData\ndomain: Domain, finite element domain, for data structure\n\n(Image: )\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.getExternalForce","page":"API Reference","title":"NNFEM.getExternalForce","text":"getExternalForce(self::Domain, globaldat::GlobalData, fext::Union{Missing,Array{Float64}}=missing)\n\nComputes external force vector at globaldat.time,  This includes all the body force, external load, and internal force caused by acceleration.\n\n\n\n\n\n","category":"function"},{"location":"api/#State-Updates","page":"API Reference","title":"State Updates","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"This set of functions include boundary condition updates, data transfer, and other bookkeeping utilities.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"commitHistory\nsetConstantDirichletBoundary!\nsetConstantNodalForces!\nupdateStates!\nupdateTimeDependentEssentialBoundaryCondition!","category":"page"},{"location":"api/#NNFEM.setConstantDirichletBoundary!","page":"API Reference","title":"NNFEM.setConstantDirichletBoundary!","text":"setConstantDirichletBoundary!(self::Domain, EBC::Array{Int64}, g::Array{Float64})\n\nBookkeepings for time-independent Dirichlet boundary conditions. Only called once in the constructor of domain.  It updates the fixed (time-independent Dirichlet boundary) state entries and builds both LM and DOF arrays.\n\nself: Domain\nEBC:  Int64[nnodes, ndims], EBC[n,d] is the displacement boundary condition of node n's dth freedom,\n∘ -1 means fixed(time-independent) Dirichlet boundary nodes\n∘ -2 means time-dependent Dirichlet boundary nodes\ng:  Float64[nnodes, ndims], values for fixed (time-independent) Dirichlet boundary conditions of node n's dth freedom,\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.setConstantNodalForces!","page":"API Reference","title":"NNFEM.setConstantNodalForces!","text":"Bookkeepings for time-independent Nodal force boundary conditions. Only called once in the constructor of domain.  It updates the fixed (time-independent Nodal forces) state entries and builds both LM and DOF arrays.\n\nself: Domain\nFBC:  Int64[nnodes, ndims], FBC[n,d] is the displacement boundary condition of node n's dth freedom,\n∘ -1 means fixed (time-independent) Nodal force freedoms\n∘ -2 means time-dependent Nodal force freedoms\nf:  Float64[nnodes, ndims], values for fixed (time-independent) Neumann boundary conditions of node n's dth freedom,\n\n#The name is misleading\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.updateStates!","page":"API Reference","title":"NNFEM.updateStates!","text":"updateStates!(domain::Domain, globaldat::GlobalData)\nupdate time-dependent Dirichlet boundary condition to globaldat.time\n\nUpdate state and Dstate in domain. This includes \n\nCopy state variable values for active DOFs from globaldat\nSet time-dependent essential boundary conditions using globaldat.EBC\n\nThe time-independent boundary conditions are inherented from last time step.\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.updateTimeDependentEssentialBoundaryCondition!","page":"API Reference","title":"NNFEM.updateTimeDependentEssentialBoundaryCondition!","text":"updateTimeDependentEssentialBoundaryCondition!(domain::Domain, globaldat::GlobalData)\n\nIf there exists time-dependent Dirichlet boundary conditions, updateTimeDependentEssentialBoundaryCondition! must be called to update  the boundaries in domain. This function is called by updateStates!\n\nThis function updates state data in domain.\n\n\n\n\n\n","category":"function"},{"location":"api/#Solvers","page":"API Reference","title":"Solvers","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"ExplicitSolverStep\nGeneralizedAlphaSolverStep\nImplicitStaticSolver\nSolverInitial!\nSolverInitial","category":"page"},{"location":"api/#NNFEM.ExplicitSolverStep","page":"API Reference","title":"NNFEM.ExplicitSolverStep","text":"ExplicitSolverStep(globdat::GlobalData, domain::Domain, Δt::Float64)\n\nCentral Difference explicit solver for M a + fint(u) = fext(u). a, v, u are acceleration, velocity and displacement.\n\nbeginaligned\nu_n+1 = u_n + dtv_n + dt^22 a_n \nv_n+1 = v_n + dt2(a_n + a_n+1) \nM a_n+1 + f^int(u_n+1) = f^ext_n+1 \nM a_n+1 = f^ext_n+1 - f^int(u_n+1) \nendaligned\n\ninfo: Info\nYou need to call SolverInitial! before the first time step, if f^ext_0 neq 0.  Otherwise we assume the initial acceleration globdat.acce[:] = 0.\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.GeneralizedAlphaSolverStep","page":"API Reference","title":"NNFEM.GeneralizedAlphaSolverStep","text":"GeneralizedAlphaSolverStep(globdat::GlobalData, domain::Domain, Δt::Float64, \nρ::Float64 = 0.0, ε::Float64 = 1e-8, ε0::Float64 = 1e-8, maxiterstep::Int64=100, \nη::Float64 = 1.0, failsafe::Bool = false, verbose::Bool = false)\n\nImplicit solver for  Ma  + f_int(u) = fext Here a, v, u are acceleration, velocity and displacement respectively.\n\nρ: controls the damping effect of the α-scheme, ρ∈[0,1], ρ=1 corresponds to the maximum damping\nε: Float64, absolute error for Newton convergence\nε0: Float64, relative error for Newton convergence\nmax_iter: Int64, maximum iteration number for Newton convergence\nη: Float64, Newton step size at the first iteration\nfailsafe: Bool, if failsafe is true, when the Newton fails to converge,              revert back, and return false\n\nThe nonlinear alpha\n\nu_n+1 = u_n + dtv_n + dt^22 ((1 - 2beta)a_n + 2beta a_n+1)\nv_n+1 = v_n + dt((1 - gamma)a_n + gamma a_n+1)\n2beta = 05*(1 - αm + αf)^2\ngamma = 05 - alpha_m + alpha_f\n\na_n+1-alpha_m = (1-alpha_m)a_n+1 + alpha_m a_n \nv_n+1-alpha_f = (1-alpha_f)v_n+1 + alpha_f v_n\nu_n+1-alpha_f = (1-alpha_f)u_n+1 + alpha_f u_n\nM a_n+1-alpha_m + f^int(u_n+1-alpha_f) = f^ext_n+1-alpha_f\n\n'a_{n+1}' is solved by \n\nM ((1-alpha_m)a_n+1 + alpha_m a_n)  \n+ f^int((1-alpha_f)(u_n + dtv_n + dt^22 ((1 - 2beta)a_n + 2beta a_n+1))) + alpha_f u_n) \n= f^ext_n+1-alpha_f\n\nAs for \\alpha_m and alpha_f\n\nalpha_m = (2rho_infty - 1)(rho_infty + 1)\nalpha_f = rho_infty(rho_infty + 1)\n\nuse the current states a, v, u, time in globdat, and update these stetes to next time step update domain history, when failsafe is true, and Newton's solver fails, nothing will be changed.\n\nYou need to call SolverInitial! before the first time step, if f^{ext}0 != 0. SolverInitial! updates a0 in the globdat.acce a0 = M^{-1}(- f^{int}(u0) + f^{ext}_0)\n\nWe assume globdat.acce[:] = a_0 and so far initialized to 0 We also assume the external force is conservative (it does not depend on the current deformation)\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.ImplicitStaticSolver","page":"API Reference","title":"NNFEM.ImplicitStaticSolver","text":"ImplicitStaticSolver(globdat::GlobalData, domain::Domain; \n    N::Int64 = 10, ε::Float64 = 1.e-6, maxiterstep::Int64=100)\n\nSolves  K(u) = F using the incremental load method. Specifically, at step i, we solve \n\nf^int(u_i) = fraciN f^ext\n\nglobdat, GlobalData\ndomain, Domain\nN, an integer, load stepping steps\nε, Float64, absolute error for Newton convergence\nmaxiterstep, Int64, maximum iteration number for Newton convergence\n\n\n\n\n\nImplicitStaticSolver(globdat::GlobalData, domain::Domain,\n    d0::Union{Array{Float64, 1}, PyObject}, \n    nn::Function, θ::Union{Array{Float64, 1}, PyObject},\n    Fext::Union{Array{Float64, 1}, PyObject, Missing}=missing)\n\nSolves the static problem \n\nK(u) = F\n\nusing Newton's method. Users provide nn, which is a function that outputs stress and stress sensitivity given the strain tensor. \n\nsigma fracpartial sigmapartial epsilon = mathrmnn(epsilon theta)\n\nd0: a vector of length 2domain.nnodes, the fixed Dirichlet DOF should be populated with boundary values. \nFext: external force, a vector of length domain.neqs\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.SolverInitial!","page":"API Reference","title":"NNFEM.SolverInitial!","text":"SolverInitial!(Δt::Float64, globdat::GlobalData, domain::Domain)\n\nYou need to call SolverInitial! before the first time step, if f^ext_0 neq 0\n\na_0 = M^-1(- f^int(u_0) + f^ext_0)\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.SolverInitial","page":"API Reference","title":"NNFEM.SolverInitial","text":"SolverInitial(Δt::Float64, globdat::GlobalData, domain::Domain)\n\nSimilar to SolverInitial!, but returns the (displacement, velocity, acceleartion) tuple. \n\n\n\n\n\n","category":"function"},{"location":"api/#Mesh-Utilities","page":"API Reference","title":"Mesh Utilities","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"meshread\npsread","category":"page"},{"location":"api/#NNFEM.meshread","page":"API Reference","title":"NNFEM.meshread","text":"meshread(gmshfile::String)\n\nReads a gmsh file gmshfile and return (nodes, elements) tuple.\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.psread","page":"API Reference","title":"NNFEM.psread","text":"psread(gmshfile::String)\n\nReads the physical group information from gmshfile. Returns a dictionary\n\nPhysicalGroupName => Index\n\nIndex is a ntimes 2 coordinate matrix.   We do not output indices because there may be postprocessing procedures after creating the mesh. \n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [NNFEM]\nPages   = [\"utils/gmsh.jl\"]","category":"page"},{"location":"api/#NNFEM.addCurveLoop","page":"API Reference","title":"NNFEM.addCurveLoop","text":"Add a curve loop (a closed wire) formed by the curves curveTags.\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.addPhysicalGroup","page":"API Reference","title":"NNFEM.addPhysicalGroup","text":"Forms a physical group of dimension dim and tag tag with name name\n\n\n\n\n\n","category":"function"},{"location":"api/#Visualization","page":"API Reference","title":"Visualization","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [NNFEM]\nPages   = [\"utils/Visualize2.jl\"]","category":"page"},{"location":"api/#NNFEM.visualize_boundary","page":"API Reference","title":"NNFEM.visualize_boundary","text":"visualize_boundary(domain::Domain, direction::String=\"x\")\n\nVisualizes the boundary conditions. The boundary configuration is shown in the direction direction.\n\n(Image: )\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.visualize_displacement-Tuple{Domain}","page":"API Reference","title":"NNFEM.visualize_displacement","text":"visualize_displacement(domain::Domain)\nvisualize_displacement(u::Array{Float64, 2}, domain::Domain)\n\nAnimation of displacements using points. \n\n(Image: )\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.visualize_mesh-Tuple{Array{Float64,2},Array{Int64,2}}","page":"API Reference","title":"NNFEM.visualize_mesh","text":"visualize_displacement(domain::Domain)\nvisualize_displacement(nodes::Array{Float64,2}, elems::Array{Int64, 2})\n\nVisualizes the mesh. (Image: )\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.visualize_scalar_on_scoped_body-Tuple{Array{Float64,1},Array{Float64,1},Domain}","page":"API Reference","title":"NNFEM.visualize_scalar_on_scoped_body","text":"visualize_scalar_on_scoped_body(d::Array{Float64}, domain::Domain, kwargs...)\nvisualize_scalar_on_scoped_body(s::Array{Float64, 1}, d::Array{Float64,1}, domain::Domain;\n    scale_factor::Float64 = -1.0, kwargs...)\n\nPlot the scalar on scoped body. For example, s can be the von Mises stress tensor. \n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.visualize_scalar_on_undeformed_body-Tuple{Array{Float64,1},Domain}","page":"API Reference","title":"NNFEM.visualize_scalar_on_undeformed_body","text":"visualize_scalar_on_undeformed_body(s::Array{Float64, 1}, domain::Domain; kwargs...)\nvisualize_scalar_on_undeformed_body(s::Array{Float64, 2}, domain::Domain; frames::Int64 = 20, kwargs...)\n\nPlots or animates scalar values s on the domain domain\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.visualize_total_deformation_on_scoped_body-Tuple{Array{Float64,2},Domain}","page":"API Reference","title":"NNFEM.visualize_total_deformation_on_scoped_body","text":"visualize_total_deformation_on_scoped_body(d_all::Array{Float64,2}, domain::Domain;\nscale_factor::Float64 = 1.0, frames::Int64 = 20)\n\nVisualizes the total deformation\n\nsqrtu_x^2 + u_y^2\n\n(Image: )\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.visualize_von_mises_stress-Tuple{Domain,Int64}","page":"API Reference","title":"NNFEM.visualize_von_mises_stress","text":"visualize_von_mises_stress(domain::Domain, t_step::Int64; kwargs...)\n\nPlot of von Mises stress tensors at time step t_step.\n\n(Image: )\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.visualize_von_mises_stress-Tuple{Domain}","page":"API Reference","title":"NNFEM.visualize_von_mises_stress","text":"visualize_von_mises_stress(domain::Domain; frames::Int64 = 20, kwargs...)\n\nAnimation of von Mises stress tensors. \n\n(Image: )\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.visualize_von_mises_stress_on_scoped_body-Tuple{Array{Float64,2},Domain}","page":"API Reference","title":"NNFEM.visualize_von_mises_stress_on_scoped_body","text":"visualize_von_mises_stress_on_scoped_body(d_all::Array{Float64,2}, domain::Domain;\nscale_factor::Real = -1.0, frames::Int64 = 20)\n\nSimilar to visualize_von_mises_stress, but the domain can be a deformed body. \n\n(Image: )\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.visualize_x_deformation_on_scoped_body-Tuple{Array{Float64,2},Domain}","page":"API Reference","title":"NNFEM.visualize_x_deformation_on_scoped_body","text":"visualize_x_deformation_on_scoped_body(d_all::Array{Float64,2}, domain::Domain;\nscale_factor::Real = 1.0, frames::Int64 = 20, kwargs...)\n\nVisualizes the x directional displacement. \n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.visualize_y_deformation_on_scoped_body-Tuple{Array{Float64,2},Domain}","page":"API Reference","title":"NNFEM.visualize_y_deformation_on_scoped_body","text":"visualize_y_deformation_on_scoped_body(d_all::Array{Float64,2}, domain::Domain;\nscale_factor::Real = 1.0, frames::Int64 = 20, kwargs...)\n\nVisualizes the y directional displacement. \n\n\n\n\n\n","category":"method"},{"location":"api/#Automatic-Differentiation","page":"API Reference","title":"Automatic Differentiation","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"init_nnfem\ns_eval_strain_on_gauss_points\ns_compute_stiffness_matrix\ns_compute_internal_force_term\nf_eval_strain_on_gauss_points\nf_compute_internal_force_term\nExplicitSolver\nExplicitSolverTime\nGeneralizedAlphaSolver\nGeneralizedAlphaSolverTime\ncompute_boundary_info\ncompute_external_force\ncompute_stress_rivlin_saunders\ns_compute_stiffness_matrix1","category":"page"},{"location":"api/#NNFEM.init_nnfem","page":"API Reference","title":"NNFEM.init_nnfem","text":"init_nnfem(domain::Domain)\n\nPrepares domain for use in custom operators.\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.s_eval_strain_on_gauss_points","page":"API Reference","title":"NNFEM.s_eval_strain_on_gauss_points","text":"s_eval_strain_on_gauss_points(state::Union{Array{Float64,1}, PyObject})\n\nComputes the strain on Gauss points in the small strain case. state is the full displacement vector. \n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.s_compute_stiffness_matrix","page":"API Reference","title":"NNFEM.s_compute_stiffness_matrix","text":"s_compute_stiffness_matrix(k::Union{Array{Float64,3}, PyObject})\n\nComputes the small strain stiffness matrix. k is a ntimes 3times 3 matrix, where n is the total number of Gauss points. Returns a SparseTensor. \n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.s_compute_internal_force_term","page":"API Reference","title":"NNFEM.s_compute_internal_force_term","text":"s_compute_internal_force_term(stress::Union{Array{Float64,2}, PyObject})\n\nComputes the internal force int_Omega sigma  delta epsilon dx Only active DOFs are considered. \n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.f_eval_strain_on_gauss_points","page":"API Reference","title":"NNFEM.f_eval_strain_on_gauss_points","text":"f_eval_strain_on_gauss_points(state::Union{Array{Float64,1}, PyObject})\n\nComputes the strain on Gauss points in the finite strain case. state is the full displacement vector. \n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.f_compute_internal_force_term","page":"API Reference","title":"NNFEM.f_compute_internal_force_term","text":"f_compute_internal_force_term(stress::Union{Array{Float64,2}, PyObject}, \n    state::Union{Array{Float64,1}, PyObject},\n    domain::Domain)\n\nComputes the internal force for finite strain continuum\n\nint_Omega sigma  delta epsilon dx\n\nOnly active DOFs are considered. \n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.ExplicitSolver","page":"API Reference","title":"NNFEM.ExplicitSolver","text":"ExplicitSolver(globdat::GlobalData, domain::Domain,\n    d0::Union{Array{Float64, 1}, PyObject}, \n    v0::Union{Array{Float64, 1}, PyObject}, \n    a0::Union{Array{Float64, 1}, PyObject}, \n    Δt::Float64, NT::Int64, \n    H::Union{Array{Float64, 3}, Array{Float64, 2}, PyObject},\n    Fext::Union{Array{Float64, 2}, PyObject, Missing}=missing,\n    ubd::Union{Array{Float64, 2}, PyObject, Missing}=missing,\n    abd::Union{Array{Float64, 2}, PyObject, Missing}=missing; strain::String = \"small\")\n\nDifferentiable Explicit Solver. \n\nd0, v0, a0: initial full displacement, velocity, and acceleration. \nΔt: time step \nHs: linear elasticity matrix at each Gauss point \nFext: external force, mathrmNTtimes n, where n is the active dof.  The external force includes all body forces, external load forces (also called edge forces in NNFEM) and boundary acceleration-induced forces.\nubd, abd: boundary displacementt and acceleration, mathrmNTtimes m, where m is time-dependent boundary DOF.   Time-independent boundary conditions are extracted from domain. \nstrain_type (default = \"small\"): small strain or finite strain\n\n\n\n\n\nExplicitSolver(globdat::GlobalData, domain::Domain,\n    d0::Union{Array{Float64, 1}, PyObject}, \n    v0::Union{Array{Float64, 1}, PyObject}, \n    a0::Union{Array{Float64, 1}, PyObject}, \n    Δt::Float64, NT::Int64, \n    nn::Function,\n    Fext::Union{Array{Float64, 2}, PyObject, Missing}=missing,\n    ubd::Union{Array{Float64, 2}, PyObject, Missing}=missing,\n    abd::Union{Array{Float64, 2}, PyObject, Missing}=missing; strain_type::String = \"small\"))\n\nSimilar to ExplicitSolver; however, the constituve relation from epsilon to sigma must be provided by  the function nn.\n\n\n\n\n\nExplicitSolver(globdat::GlobalData, domain::Domain,\n    d0::Union{Array{Float64, 1}, PyObject}, \n    v0::Union{Array{Float64, 1}, PyObject}, \n    a0::Union{Array{Float64, 1}, PyObject}, \n    σ0::Union{Array{Float64, 1}, PyObject}, \n    ε0::Union{Array{Float64, 1}, PyObject}, \n    Δt::Float64, NT::Int64, \n    nn::Function,\n    Fext::Union{Array{Float64, 2}, PyObject, Missing}=missing,\n    ubd::Union{Array{Float64, 2}, PyObject, Missing}=missing,\n    abd::Union{Array{Float64, 2}, PyObject, Missing}=missing; strain_type::String = \"small\")\n\nSimilar to ExplicitSolver; however, the constitutive relation has the form \n\nsigma^n+1 = mathrmnn(epsilon^n+1 epsilon^n sigma^n)\n\nHere the strain and stress are n times 3 tensors. n is the total number of Gaussian points and can be  obtained via getNGauss(domain).\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.ExplicitSolverTime","page":"API Reference","title":"NNFEM.ExplicitSolverTime","text":"ExplicitSolverTime(Δt::Float64, NT::Int64)\n\nReturns the times for explicit solver. Boundary conditions and external forces should be given at these times.\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.GeneralizedAlphaSolver","page":"API Reference","title":"NNFEM.GeneralizedAlphaSolver","text":"GeneralizedAlphaSolver(globdat::GlobalData, domain::Domain,\n    d0::Union{Array{Float64, 1}, PyObject}, \n    v0::Union{Array{Float64, 1}, PyObject}, \n    a0::Union{Array{Float64, 1}, PyObject}, \n    Δt::Float64, NT::Int64, \n    Hs::Union{Array{Float64, 3}, Array{Float64, 2}, PyObject},\n    Fext::Union{Array{Float64, 2}, PyObject, Missing}=missing,\n    ubd::Union{Array{Float64, 2}, PyObject, Missing}=missing,\n    abd::Union{Array{Float64, 2}, PyObject, Missing}=missing; ρ::Float64 = 0.0)\n\nDifferentiable Generalized alpha scheme. This is an extension of αscheme provided in ADCME. This function does not support damping and variable time step (for efficiency). \n\nd0, v0, a0: initial full displacement, velocity, and acceleration. \nΔt: time step \nHs: linear elasticity matrix at each Gauss point \nFext: external force, mathrmNTtimes n, where n is the active dof.  The external force includes all body forces, external load forces (also called edge forces in NNFEM) and boundary acceleration-induced forces.\nubd, abd: boundary displacementt and acceleration, mathrmNTtimes m, where m is boundary DOF.  Time-independent boundary conditions are extracted from domain. \n\nGeneralizedAlphaSolver does not support finite-strain continuum yet.  \n\n\n\n\n\nGeneralizedAlphaSolver(globdat::GlobalData, domain::Domain,\n    d0::Union{Array{Float64, 1}, PyObject}, \n    v0::Union{Array{Float64, 1}, PyObject}, \n    a0::Union{Array{Float64, 1}, PyObject}, \n    Δt::Float64, NT::Int64, \n    Cs::Union{Array{Float64, 3}, Array{Float64, 2}, PyObject},\n    Hs::Union{Array{Float64, 3}, Array{Float64, 2}, PyObject},\n    Fext::Union{Array{Float64, 2}, PyObject, Missing}=missing,\n    ubd::Union{Array{Float64, 2}, PyObject, Missing}=missing,\n    abd::Union{Array{Float64, 2}, PyObject, Missing}=missing; ρ::Float64 = 0.0)\n\nSolve linear dynamical structural problem using a generalized alpha solver.  Cs and Hs are the corresponding linear viscosity and linear elasticity matrix. \n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.GeneralizedAlphaSolverTime","page":"API Reference","title":"NNFEM.GeneralizedAlphaSolverTime","text":"GeneralizedAlphaSolverTime(Δt::Float64, NT::Int64;ρ::Float64 = 0.0)\n\nReturns the times for the generalized alpha solver. Boundary conditions and external forces should be given at these times.\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.compute_boundary_info","page":"API Reference","title":"NNFEM.compute_boundary_info","text":"compute_boundary_info(domain::Domain, globdat::GlobalData, ts::Array{Float64})\n\nComputes the boundary information ubd and abd\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.compute_external_force","page":"API Reference","title":"NNFEM.compute_external_force","text":"compute_external_force(domain::Domain, globdat::GlobalData, ts::Union{Array{Float64}, Missing} = missing)\n\nComputes the external force (body force, edge force and force due to boundary acceleration).\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.compute_stress_rivlin_saunders","page":"API Reference","title":"NNFEM.compute_stress_rivlin_saunders","text":"compute_stress_rivlin_saunders(strain::Union{PyObject, Array{Float64,2}},c1::Union{PyObject, Float64},c2::Union{PyObject, Float64})\n\nComputes the stress using the plane stress incompressible Rivlin Saunders model. \n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.s_compute_stiffness_matrix1","page":"API Reference","title":"NNFEM.s_compute_stiffness_matrix1","text":"s_compute_stiffness_matrix1(k::Union{PyObject, Array{Float64,3}}, domain::Domain)\n\nComputes the stiffness matrix \n\n\\int_\\Omega (K\\nabla u) \\cdot \\nabla \\delta u dx \n\n\n\n\n\n","category":"function"},{"location":"representation/#Representations-of-Constitutive-Relation","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"","category":"section"},{"location":"representation/#Constitutive-Theory","page":"Representations of Constitutive Relation","title":"Constitutive Theory","text":"","category":"section"},{"location":"representation/","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"To characterize material mechanics, we usually need to provide relations between kinematic and dynamic quantities. For example, the balance of linear momentum provides a constraint on the material mechanics. Another important relation is the constitutive relation, which describes the material's response to deformation. To describe the constitutive relations, the strain and stress tensors are useful. The strain tensor is automatic symmetric. The stress tensor can be shown to be symmetric based on the balance of angular momentum. ","category":"page"},{"location":"representation/","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"Mathematically, let mathcalC denote the constitutive quantity, then the most general constitutive relation for mathcalC is given by a functional of the form ","category":"page"},{"location":"representation/","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"mathcalC(X t) = mathcalF_Yin mathcalB -infty  sleq  t (rho(Y s) chi(Y s) theta(Y s) Y t)","category":"page"},{"location":"representation/","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"Here mathcalF is the constitutive function, mathcalB is the region of influence for X. rho, chi, theta are te density, the motion, and the temperature. For pure mechanical processes, the constitutive quantity mathcalC can be the stress tensor, the heat flux or the internal energy. ","category":"page"},{"location":"representation/","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"Not all relations are valid constitutive relations. In the following, we consider some common assumptions on the constitutive relation. ","category":"page"},{"location":"representation/","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"Principle of Determinism. This means the current state of a material is determined tthrough the current motion and the entire motion-history of all other material points of the continuum body. \nPrinciple of Material Objectivity. This is also known as observer or frame indifference. A material equation must not depend on the choice of the reference frame or observer. An observer deduces a physical law in his or her coordinate mathbfx, and another observer, who is in another coordinate system mathbfx^*, deduces another physical law for the same physical quantities. ","category":"page"},{"location":"representation/","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"mathbfx^* = Q(t) mathbfx + mathbfx(t) qquad Q(t)Q(t)^T = Q(t)^TQ(t)=mathbfI mathrmdet(Q(t)) = pm 1","category":"page"},{"location":"representation/","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"Theses two laws should be consistent with each other. For example, the law might be the Newton's second law, which states that the acceleration is proportional to the external force. ","category":"page"},{"location":"representation/","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"Non-local Materials. The physical action at the point X is determined by the action at all other points Y of the body, and the region of influence is only restricted to the neighborhood of X. This assumption allows us to describe the physical law using the Taylor series of the state variables. For example, for the motion chi(Y t), we have ","category":"page"},{"location":"representation/","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"chi(Y t) = chi(X t) + frac11fracpartial chi(X t)partial chiDelta X +frac12(Delta X)^Tfracpartial^2 chi(X t)partial chi^2Delta X +ldots","category":"page"},{"location":"representation/","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"note: Note\nWe can classify the material by the number of terms in the Taylor expansion above. A material is said to have grade N if its constitutive relation is described N+1 terms in the Taylor expansion. ","category":"page"},{"location":"representation/","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"note: Note\nNonlocal constitutive relations, such as peridynamics, are also considered in literature. ","category":"page"},{"location":"representation/","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"Material Symmetry. In the case of material symmetries, we can further reduce the general constitutive relation. For example, for hyperelasticity materials, the material symmetry reduces the constitutive relation between strain and stress to isotropic functions. ","category":"page"},{"location":"representation/#Enforcing-Physical-Constraints-in-Constitutive-Relations","page":"Representations of Constitutive Relation","title":"Enforcing Physical Constraints in Constitutive Relations","text":"","category":"section"},{"location":"representation/","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"In NNFEM, we provide a set of tools to enforce physical constraints. ","category":"page"},{"location":"representation/","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"Isotropic functions for on tensor","category":"page"},{"location":"representation/","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"isotropic_function","category":"page"},{"location":"representation/#NNFEM.isotropic_function","page":"Representations of Constitutive Relation","title":"NNFEM.isotropic_function","text":"isotropic_function(coef::Union{Array{Float64,2}, PyObject},strain::Union{Array{Float64,2}, PyObject})\n\nIsotropic function of a symmetric tensor.\n\nT = s_0 I + s_1 A + s_2 A^2\n\nHere \n\ntextttcoef(i) = s_0 s_1 s_2\n\nA = leftbeginmatrix\nS_i1  S_i32 \nS_i32  S_i2\nendmatrixright\n\nwhere S_ij is the i-th row and j-th column of strain\n\n\n\n\n\n","category":"function"},{"location":"representation/","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"info: Info\nTo construct a constitutive relation that has the form T = s_0(sigma_1 sigma_2)  + s_1(sigma_1 sigma_2) S  + s_2(sigma_1 sigma_2) S^2Here sigma_1 and sigma_2 are the two eigenvalues of S, we can use strain_voigt_to_tensor to extract eigenvalues.using NNFEM, ADCME\nstrain = rand(100,3)\nstrain_tensor = strain_voigt_to_tensor(strain)\ne, v = tf.linalg.eigh(strain_tensor)\ncoef = ae(e, [20,20,20,3])\nstress = isotropic_function(coef, strain)","category":"page"},{"location":"representation/","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"Isotropic functions for two tensors","category":"page"},{"location":"representation/","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"bi_isotropic_function","category":"page"},{"location":"representation/#NNFEM.bi_isotropic_function","page":"Representations of Constitutive Relation","title":"NNFEM.bi_isotropic_function","text":"bi_isotropic_function(coef::Union{Array{Float64,2}, PyObject},strain::Union{Array{Float64,2}, PyObject},\nstrainrate::Union{Array{Float64,2}, PyObject})\n\nIsotropic function of two symmetric tensors A and B\n\nbeginaligned\nT(A B) = gamma_0 I + gamma_1 A + gamma_2 B + gamma_3 A^2 + gamma_4 (A*B+B*A) \n + gamma_5 B^2 + gamma_6 (A^2 B + BA^2) + gamma_7 (AB^2 + B^2 A) + gamma_8 (A^2B^2+B^2A^2)\nendaligned\n\nThis is useful for rate-dependent constitutive relation. For example, \n\nsigma^n+1 = mathcalC(epsilon^n+1 dotepsilon^n+1)\n\nHere \n\ncoef: Ntimes 9 coefficient array\nstrain: Ntimes 3 strain tensor in Voigt notation\nstrainrate: Ntimes 3 strain rate tensor in Voigt notation\n\n\n\n\n\n","category":"function"},{"location":"representation/","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"Similar to the isotropic function for one tensor, we can construct a constitutive relation that is an isotropic function of two tensors. ","category":"page"},{"location":"representation/","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"using NNFEM, ADCME\nstrain = rand(100,3)\nstrain_rate = rand(100,3)\nstrain_tensor = strain_voigt_to_tensor(strain)\nstrain_rate_tensor = strain_voigt_to_tensor(strain_rate)\ne1, v = tf.linalg.eigh(strain_tensor)\ne2, v = tf.linalg.eigh(strain_rate_tensor)\ncoef = ae([e1 e2], [20,20,20,9])\nstress = isotropic_function(coef, strain)","category":"page"},{"location":"representation/","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"Plasticity ","category":"page"},{"location":"representation/","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"consistent_tangent_matrix","category":"page"},{"location":"representation/#NNFEM.consistent_tangent_matrix","page":"Representations of Constitutive Relation","title":"NNFEM.consistent_tangent_matrix","text":"consistent_tangent_matrix(inputs::Union{Array{Float64, 2}, PyObject},Dc::Union{Array{Float64,2}, PyObject})\n\nReturns the consistent tangent matrices. The size of the return is Ntimes 3 times 3. \n\nD_c^ep = D_c - fracD_cfracpartial gpartial sigmaleft(fracpartial fpartial sigma right)^T D_c E_p + fracpartial gpartial sigma Dc left(fracpartial fpartial sigma right)^T\n\nHere inputs is a Ntimes 7 matrix, where each row is \n\nleftfracpartial gpartial sigma fracpartial fpartial sigma E_pright\n\nDc is a 3times 3 row-major matrix; each row is a linear elasticity matrix.  \n\ninfo: Info\nThe gradients with respect to both inputs and H are available. \n\n\n\n\n\n","category":"function"},{"location":"ex_ad/#Automatic-Differentiation","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"","category":"section"},{"location":"ex_ad/#Data-Structure","page":"Automatic Differentiation","title":"Data Structure","text":"","category":"section"},{"location":"ex_ad/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"To facilitate implementing custom operators, we made a shared library for storing all FEM data structures that do not participate in automatic differentiation. In the shared library, there are mainly two data structures","category":"page"},{"location":"ex_ad/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"domain\nclass Domain{\npublic:\n    MatrixXd nodes;\n    int neqs;\n    int nnodes;\n    int neles;\n    int ngauss;\n};\nHere \nnodes: coordinates of all nodes, a n_vtimes 2 matrix.\nneqs: number of all active DOFs among 2n_v equations.\nnnodes: number of nodes, n_v\nneles: number of elements n_e, which is also the size of mesh vector (see below). \nngauss: total number of Gauss points. It is equal to getNGauss(domain) in Julia. \ncontinuum\nclass Continuum{\npublic:\n    VectorXi elnodes;\n    MatrixXd coords;\n    vector<MatrixXd> dhdx;\n    Eigen::VectorXd weights;\n    vector<VectorXd> hs;\n    VectorXi el_eqns_active;\n    VectorXi el_eqns;\n    int nGauss;\n    int nnodes;\n\n    Continuum(const int *elnodes_, const double *coords_, \n        const double *dhdx_, const double *weights_, const double *hs_, int n_nodes, int n_gauss,\n        const int *el_eqns_active, int n_active, const int *el_eqns);\n};\nelnodes: the global index of the nodes for this specific element, n^e_v.\ncoords: coordinates of the element vertices, it is of size n^e_vtimes2\ndhdx: a list (length = n_g) of  n_v^etimes 2 matrices, representing the contribution of  nabla phi_i(x) to each nodes. n_g is the number of Gauss points.\nweights: weight vector of Gauss quadrature\nhs: a list (length = n_g) of length n_v^e  vector representing the contribution of  phi_i(x) to each nodes. n_g is the number of Gauss points.\nel_eqns: global indices of active DOFs for each vertex and each direction (u and v). It has length 2n_v^e and each value is within 01ldots 2n_v-1. \nel_eqns_active: local indices of actives DOFs for each vertex and each direction (u and v). It has length at most 2n_v^e and each value is within 01ldots 2n_v^e-1. A typical  usuage is \n// fint: local internal force\n// Fint: global internal force\nfor(int i = 0; i< elem.el_eqns_active.size(); i++){\n  int ix = elem.el_eqns_active[i];\n  int eix = elem.el_eqns[ix];\n  Fint[eix] += fint[ix];\n}","category":"page"},{"location":"ex_ad/#A-Typical-Simulation-Routine","page":"Automatic Differentiation","title":"A Typical Simulation Routine","text":"","category":"section"},{"location":"ex_ad/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"Make an instance of Domain and GlobalData\nAssemble mass matrices using assembleMassMatrix!\nCompute boundary information using compute_boundary_info\nCompute the external force (body force + external load force + boundary-acceleration-induced force) using compute_external_force\nCompute initial a_0 using SolverInitial\nInvoke solver ExplicitSolver or GeneralizedAlphaSolver","category":"page"},{"location":"ex_ad/#Examples","page":"Automatic Differentiation","title":"Examples","text":"","category":"section"},{"location":"ex_ad/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"using NNFEM\n\n\ndomain = example_domain()\nglobaldata = example_global_data(domain)\ninit_nnfem(domain)  # IMPORTANT: initialize the NNFEM session\n\n# total number of gauss points\nngauss = length(domain.elements[1].weights) * domain.neles\nH = constant(rand(ngauss, 3, 3)) # linear elasticity matrix \nK = s_compute_stiffness_matrix(H, domain) # stiffness matrix\nassembleMassMatrix!(globaldata, domain)\nM = SparseTensor(globaldata.M) # mass matrix\n\na = 0.1\nb = 0.2\nA = a * K + b * M\n\nrhs = constant(rand(size(K,2)))\nsol = A\\rhs","category":"page"},{"location":"ex_ad/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"sol can be differentiated with respect to rhs","category":"page"},{"location":"ex_ad/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"julia> gradients(sum(sol), rhs)\nPyObject <tf.Tensor 'gradients_1/IdentityN_12_grad/SparseSolverGrad:3' shape=(242,) dtype=float64>","category":"page"},{"location":"ex_ad/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"sol can be differentiated with respect to H","category":"page"},{"location":"ex_ad/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"julia> gradients(sum(sol), H)\nPyObject <tf.Tensor 'gradients_2/IdentityN_11_grad/SmallContinuumStiffnessGrad:0' shape=(400, 3, 3) dtype=float64>","category":"page"},{"location":"ex_ad/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"","category":"page"},{"location":"ex_ad/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"Given the stress stress, we can compute the internal force and evaluate its gradients","category":"page"},{"location":"ex_ad/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"stress = constant(rand(ngauss, 3))\nfint = s_compute_internal_force_term(stress, domain)\ngradients(sum(fint), stress)","category":"page"},{"location":"ex_ad/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"Expected","category":"page"},{"location":"ex_ad/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"PyObject <tf.Tensor 'gradients_3/IdentityN_13_grad/SmallContinuumFintGrad:0' shape=(400, 3) dtype=float64>","category":"page"},{"location":"ex_ad/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"","category":"page"},{"location":"ex_ad/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"Given the displacement, we can evaluate the strain and evaluate the gradients","category":"page"},{"location":"ex_ad/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"state = constant(rand(domain.nnodes*2))\nstrain = s_eval_strain_on_gauss_points(state, domain)\ngradients(sum(strain), state)","category":"page"},{"location":"ex_ad/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"Expected","category":"page"},{"location":"ex_ad/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"PyObject <tf.Tensor 'gradients_4/IdentityN_14_grad/SmallContinuumStrainGrad:0' shape=(242,) dtype=float64>","category":"page"},{"location":"verify_linear/#Linear-Elasticity","page":"Linear Elasticity","title":"Linear Elasticity","text":"","category":"section"},{"location":"verify_linear/","page":"Linear Elasticity","title":"Linear Elasticity","text":"In this example, we consider the linear elasticity problem. The strain stress relation is given by ","category":"page"},{"location":"verify_linear/","page":"Linear Elasticity","title":"Linear Elasticity","text":"sigma = H epsilon","category":"page"},{"location":"verify_linear/","page":"Linear Elasticity","title":"Linear Elasticity","text":"where the linear elasticity matrix H is given by ","category":"page"},{"location":"verify_linear/","page":"Linear Elasticity","title":"Linear Elasticity","text":"H = elements[1].mat[1].H","category":"page"},{"location":"verify_linear/","page":"Linear Elasticity","title":"Linear Elasticity","text":"The data and geometry settings are from this section.","category":"page"},{"location":"verify_linear/#Analytical-Solution","page":"Linear Elasticity","title":"Analytical Solution","text":"","category":"section"},{"location":"verify_linear/","page":"Linear Elasticity","title":"Linear Elasticity","text":"We can use SymPy.jl to generate the analytical solution","category":"page"},{"location":"verify_linear/","page":"Linear Elasticity","title":"Linear Elasticity","text":"using SymPy\nH = elements[1].mat[1].H\nx, y, t = @vars x y t\nu = 0.1*(1-y^2)*(x^2+y^2)*exp(-t)\nv = 0.1* (1-y^2)*(x^2-y^2)*exp(-t)\nux = diff(u,x)\nuy = diff(u,y)\nvx = diff(v,x)\nvy = diff(v,y)\nϵ = [ux;vy;uy+vx]\nσ = H * ϵ\nf1 = u - (diff(σ[1], x) + diff(σ[3], y))\nf2 = v - (diff(σ[3], x) + diff(σ[2], y))\nprintln(replace(replace(sympy.julia_code(f1), \".*\"=>\"*\"), \".^\"=>\"^\"))\nprintln(replace(replace(sympy.julia_code(f2), \".*\"=>\"*\"), \".^\"=>\"^\"))\n\nS = [σ[1] σ[3]\n\tσ[3] σ[2]]\n# edge function on domain 0\nt1 = S * [-1.0;0.0]\n# edge function on domain 1\nt2 = S * [0;-1.0]\n\nprintln(replace(replace(sympy.julia_code(t1[1]), \".*\"=>\"*\"), \".^\"=>\"^\"))\nprintln(replace(replace(sympy.julia_code(t1[2]), \".*\"=>\"*\"), \".^\"=>\"^\"))\n\nprintln(replace(replace(sympy.julia_code(t2[1]), \".*\"=>\"*\"), \".^\"=>\"^\"))\nprintln(replace(replace(sympy.julia_code(t2[2]), \".*\"=>\"*\"), \".^\"=>\"^\"))\n\n","category":"page"},{"location":"verify_linear/#Forward-Computation","page":"Linear Elasticity","title":"Forward Computation","text":"","category":"section"},{"location":"verify_linear/","page":"Linear Elasticity","title":"Linear Elasticity","text":"To conduct forward computation using AD-enabled kernels, we need to precompute some data. This includes the boundary conditions and external force","category":"page"},{"location":"verify_linear/","page":"Linear Elasticity","title":"Linear Elasticity","text":"# linear elasticity matrix at each Gauss point\nHs = zeros(domain.neles*length(domain.elements[1].weights), 3, 3)\nfor i = 1:size(Hs,1)\n    Hs[i,:,:] = elements[1].mat[1].H\nend\n\n# Construct Edge_func\nfunction Edge_func_linear_elasticity(x, y, t, idx)\n  if idx==0\n      f1 = @. -6.41975308641975*x*(0.1 - 0.1*y^2)*exp(-t) + 3.45679012345679*y*(0.1 - 0.1*y^2)*exp(-t) + 0.345679012345679*y*(x^2 - y^2)*exp(-t)\n      f2 = @. -1.48148148148148*x*(0.1 - 0.1*y^2)*exp(-t) - 1.48148148148148*y*(0.1 - 0.1*y^2)*exp(-t) + 0.148148148148148*y*(x^2 + y^2)*exp(-t)\n    elseif idx==1\n      f1 = @. -1.48148148148148*x*(0.1 - 0.1*y^2)*exp(-t) - 1.48148148148148*y*(0.1 - 0.1*y^2)*exp(-t) + 0.148148148148148*y*(x^2 + y^2)*exp(-t)\n      f2 = @. -3.45679012345679*x*(0.1 - 0.1*y^2)*exp(-t) + 6.41975308641975*y*(0.1 - 0.1*y^2)*exp(-t) + 0.641975308641975*y*(x^2 - y^2)*exp(-t)\n    end\n    return [f1 f2] \nend\nglobaldata.Edge_func = Edge_func_linear_elasticity\n  \n\n","category":"page"},{"location":"verify_linear/","page":"Linear Elasticity","title":"Linear Elasticity","text":"Finally, we can carry out forward computation","category":"page"},{"location":"verify_linear/","page":"Linear Elasticity","title":"Linear Elasticity","text":"ts = ExplicitSolverTime(Δt, NT)\nubd, abd = compute_boundary_info(domain, globaldata, ts)\nFext = compute_external_force(domain, globaldata, ts) \nd, v, a= ExplicitSolver(globaldata, domain, d0, v0, a0, Δt, NT, Hs, Fext, ubd, abd)\n\n# # NOTE: You can also use the implicit alpha solvers\n# ts = GeneralizedAlphaSolverTime(Δt, NT)\n# ubd, abd = compute_boundary_info(domain, globaldata, ts)\n# Fext = compute_external_force(domain, globaldata, ts) \n# d, v, a= GeneralizedAlphaSolver(globaldata, domain, d0, v0, a0, Δt, NT, Hs, Fext, ubd, abd)\n\nsess = Session(); init(sess)\nd_, v_, a_ = run(sess, [d,v,a])","category":"page"},{"location":"verify_linear/","page":"Linear Elasticity","title":"Linear Elasticity","text":"The computation can be verified by comparing with exact solutions ","category":"page"},{"location":"verify_linear/","page":"Linear Elasticity","title":"Linear Elasticity","text":"using Random; Random.seed!(233)\nfor k = 1:5\n    i = rand(1:m+1)\n    j = rand(1:n+1)\n    if k==1\n        plot(d_[:,(j-1)*(m+1)+i], color = \"C$k\", label=\"Computed\")\n    else\n        plot(d_[:,(j-1)*(m+1)+i], color = \"C$k\")\n    end\n    x0 = (i-1)*h \n    y0 = (j-1)*h\n\n    if k==1\n        plot((@. (1-y0^2)*(x0^2+y0^2)*exp(-ts))*0.1 ,\"--\", color=\"C$k\", label=\"Reference\")\n    else\n        plot((@. (1-y0^2)*(x0^2+y0^2)*exp(-ts))*0.1 ,\"--\", color=\"C$k\")\n    end\nend\nlegend()","category":"page"},{"location":"verify_linear/","page":"Linear Elasticity","title":"Linear Elasticity","text":"Generalized alpha Scheme (Implicit) Explicit Solver\n(Image: ) (Image: )","category":"page"},{"location":"verify_linear/#Calibration","page":"Linear Elasticity","title":"Calibration","text":"","category":"section"},{"location":"verify_linear/","page":"Linear Elasticity","title":"Linear Elasticity","text":"Now assume that we do not know the Poisson's ratio or Young's modulus. To calibrate them, suppose we can collect data from the top left point. The inversion can be done within just a few lines of codes:","category":"page"},{"location":"verify_linear/","page":"Linear Elasticity","title":"Linear Elasticity","text":"E = Variable(1.0)\nν = Variable(0.0)\nH11 = E*(1. -ν)/((1+ν)*(1. -2. *ν));\nH12 = H11*ν/(1-ν);\nH21 = H12;\nH22 = H11;\nH33 = H11*0.5*(1. -2. *ν)/(1. -ν);\nH = tensor(\n  [H11 H12 0.0\n  H21 H22 0.0\n  0.0 0.0 H33]\n)\nd, v, a= ExplicitSolver(globaldata, domain, d0, v0, a0, Δt, NT, H, Fext, ubd, abd)\nidx = [1;domain.nnodes+1]\nloss = sum((d[:, idx] - d_[:, idx])^2)\nsess = Session(); init(sess)\nBFGS!(sess, loss, var_to_bounds=Dict(E=>(0.0,100.0), ν=>(-0.5,0.49)))\nrun(sess, [E, ν])","category":"page"},{"location":"verify_linear/","page":"Linear Elasticity","title":"Linear Elasticity","text":"The estimated values are","category":"page"},{"location":"verify_linear/","page":"Linear Elasticity","title":"Linear Elasticity","text":"E_est = 19999999977827019 nu_est = 03500000005217777","category":"page"},{"location":"verify_linear/","page":"Linear Elasticity","title":"Linear Elasticity","text":"The true values are ","category":"page"},{"location":"verify_linear/","page":"Linear Elasticity","title":"Linear Elasticity","text":"E^* = 20 nu^* = 035","category":"page"},{"location":"gmsh/#Creating-Mesh-for-FEM","page":"Creating Mesh for FEM","title":"Creating Mesh for FEM","text":"","category":"section"},{"location":"gmsh/","page":"Creating Mesh for FEM","title":"Creating Mesh for FEM","text":"NNFEM has a built-in mesh generation module, and users can  generate unstructured quadrilateral meshes directly from NNFEM. The backend is Gmsh. In the following, we will present several examples to illustrate how to generate mesh using the mesh module. ","category":"page"},{"location":"gmsh/","page":"Creating Mesh for FEM","title":"Creating Mesh for FEM","text":"The NNFEM mesh module provides a set of functions to create the geometry:","category":"page"},{"location":"gmsh/","page":"Creating Mesh for FEM","title":"Creating Mesh for FEM","text":"Create 0D Entities: addPoint\nCreate 1D Entities: addLine, addCircleArc\nCreate 1D Closed Curve: addCurveLoop, addDisk\nCreate 2D Entities: addPlaneSurface","category":"page"},{"location":"gmsh/","page":"Creating Mesh for FEM","title":"Creating Mesh for FEM","text":"A common workflow for using the mesh module is ","category":"page"},{"location":"gmsh/","page":"Creating Mesh for FEM","title":"Creating Mesh for FEM","text":"Initialize a session by calling init_gmsh.\nBuild planar suface from lower dimensional entities using the functions shown above.\nGenerate mesh by running finalize_gmsh. A .msh file is created and the file path is returned. This file can be read by meshread","category":"page"},{"location":"gmsh/","page":"Creating Mesh for FEM","title":"Creating Mesh for FEM","text":"Here we show some examples:","category":"page"},{"location":"gmsh/#Making-a-Rectangle-Mesh","page":"Creating Mesh for FEM","title":"Making a Rectangle Mesh","text":"","category":"section"},{"location":"gmsh/","page":"Creating Mesh for FEM","title":"Creating Mesh for FEM","text":"using NNFEM\ninit_gmsh()\np1 = addPoint(0, 0)\np2 = addPoint(2, 0)\np3 = addPoint(2, 1)\np4 = addPoint(0, 1)\nl1 = addLine(p1, p2)\nl2 = addLine(p2, p3)\nl3 = addLine(p3, p4)\nl4 = addLine(p4, p1)\ncl = addCurveLoop([l1,l2,l3,l4])\ns = addPlaneSurface([cl])\n# finalize_gmsh takes 0 or 1 argument. If the argument is `true`, then the mesh is shown. The default is false.\nfinalize_gmsh(true)","category":"page"},{"location":"gmsh/","page":"Creating Mesh for FEM","title":"Creating Mesh for FEM","text":"(Image: )","category":"page"},{"location":"gmsh/#Making-a-Rectangle-Mesh-with-a-Hole","page":"Creating Mesh for FEM","title":"Making a Rectangle Mesh with a Hole","text":"","category":"section"},{"location":"gmsh/","page":"Creating Mesh for FEM","title":"Creating Mesh for FEM","text":"using NNFEM\n\ninit_gmsh()\npts = [\n    addPoint(0,0),\n    addPoint(2,0),\n    addPoint(2,1),\n    addPoint(0,1),\n    addPoint(0.5,0.5),\n    addPoint(1.5,0.5),\n    addPoint(1.0, 0.5)\n]\nrectangle = addCurveLoop([\n    addLine(pts[1], pts[2]),\n    addLine(pts[2], pts[3]),\n    addLine(pts[3], pts[4]),\n    addLine(pts[4], pts[1])\n])\nhole = addCurveLoop(\n    [\n        addLine(pts[5], pts[6]),\n        addCircleArc(pts[6], pts[7],pts[5])\n    ]\n)\ns = addPlaneSurface([rectangle, hole])\nfinalize_gmsh(true)","category":"page"},{"location":"gmsh/","page":"Creating Mesh for FEM","title":"Creating Mesh for FEM","text":"(Image: )","category":"page"},{"location":"gmsh/#Embed-an-Entity-in-the-Surface","page":"Creating Mesh for FEM","title":"Embed an Entity in the Surface","text":"","category":"section"},{"location":"gmsh/","page":"Creating Mesh for FEM","title":"Creating Mesh for FEM","text":"NNFEM also allows you to embed a point in a line or a surface, or embed a line in a surface.","category":"page"},{"location":"gmsh/","page":"Creating Mesh for FEM","title":"Creating Mesh for FEM","text":"using NNFEM\n\ninit_gmsh()\npts = [\n    addPoint(0,0),\n    addPoint(2,0),\n    addPoint(2,1),\n    addPoint(0,1),\n    addPoint(0.3,1.0),\n    addPoint(0.8,0.5)\n]\nrectangle = addPlaneSurface(\n    [addCurveLoop([\n        addLine(1,2),\n        addLine(2,3),\n        addLine(3,4),\n        addLine(4,1)\n    ])]\n)\nline = addLine(5,6)\nembedLine([line], rectangle)\nfinalize_gmsh(true)","category":"page"},{"location":"gmsh/","page":"Creating Mesh for FEM","title":"Creating Mesh for FEM","text":"(Image: )","category":"page"},{"location":"gmsh/#Control-Mesh-Size","page":"Creating Mesh for FEM","title":"Control Mesh Size","text":"","category":"section"},{"location":"gmsh/","page":"Creating Mesh for FEM","title":"Creating Mesh for FEM","text":"Note the third argument of addPoint can be used to specify the mesh size at the specific point. Another method is to use meshsize.","category":"page"},{"location":"gmsh/","page":"Creating Mesh for FEM","title":"Creating Mesh for FEM","text":"using NNFEM\n\ninit_gmsh()\npts = [\n    addPoint(0,0),\n    addPoint(2,0),\n    addPoint(2,1),\n    addPoint(0,1)\n]\nrectangle_loop = addCurveLoop([\n        addLine(1,2),\n        addLine(2,3),\n        addLine(3,4),\n        addLine(4,1)\n    ])\ndisk_loop = addCircle(1.0,0.5,0.3)\nrectangle_with_hole = addPlaneSurface([rectangle_loop, -disk_loop])\n# meshsize takes a string as argument, which is a C++ syntax function\nmeshsize(\"0.1 *((x-1.0)*(x-1.0) + (y-0.5)*(y-0.5))\")\nfinalize_gmsh(true)","category":"page"},{"location":"gmsh/","page":"Creating Mesh for FEM","title":"Creating Mesh for FEM","text":"(Image: )","category":"page"},{"location":"gmsh/#Add-Physical-Group-Names","page":"Creating Mesh for FEM","title":"Add Physical Group Names","text":"","category":"section"},{"location":"gmsh/","page":"Creating Mesh for FEM","title":"Creating Mesh for FEM","text":"We can use addPhysicalGroup to add physical groups. ","category":"page"},{"location":"gmsh/","page":"Creating Mesh for FEM","title":"Creating Mesh for FEM","text":"using NNFEM\n\ninit_gmsh()\npts = [\n    addPoint(0,0),\n    addPoint(2,0),\n    addPoint(2,1),\n    addPoint(0,1),\n    addPoint(0.3,1.0),\n    addPoint(0.8,0.5)\n]\nrectangle = addPlaneSurface(\n    [addCurveLoop([\n        addLine(1,2),\n        addLine(2,3),\n        addLine(3,4),\n        addLine(4,1)\n    ])]\n)\nline = addLine(5,6)\naddPhysicalGroup(1, line, \"Neunmann\")\naddPhysicalGroup(0, [pts[end]], \"Neunmann\")\naddPhysicalGroup(0, [6,pts[1]], \"Dirichlet\")\nembedLine([line], rectangle)\np = finalize_gmsh(false)","category":"page"},{"location":"gmsh/","page":"Creating Mesh for FEM","title":"Creating Mesh for FEM","text":"Once we created the mesh file, we can read the physical group using ","category":"page"},{"location":"gmsh/","page":"Creating Mesh for FEM","title":"Creating Mesh for FEM","text":"psread(p)","category":"page"},{"location":"gmsh/","page":"Creating Mesh for FEM","title":"Creating Mesh for FEM","text":"Expected output:","category":"page"},{"location":"gmsh/","page":"Creating Mesh for FEM","title":"Creating Mesh for FEM","text":"Dict{String,Array{Float64,2}} with 2 entries:\n  \"Dirichlet\" => [0.0 0.0]\n  \"Neunmann\"  => [0.8 0.5; 0.3625 0.9375; … ; 0.55 0.75; 0.675 0.625]","category":"page"},{"location":"hyperelasticity/#Hyperelasticity","page":"Hyperelasticity","title":"Hyperelasticity","text":"","category":"section"},{"location":"hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"In this section, we consider the simulation of hyperelasticity material. We use the following settings:","category":"page"},{"location":"hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"The constitutive relation is given by the plane stress incompressible Rivlin Saunders model. \nWe use finite strain for numerical discretization. \nWe fix the right and bottom side of a plate, and impose verticle pressure from the top. The left side is subject to traction-free boundary condition. \n(Image: )","category":"page"},{"location":"hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"The follows shows the simulation code","category":"page"},{"location":"hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"using Revise\nusing NNFEM \nusing PyPlot\nusing LinearAlgebra\nusing ADCME\nusing ADCMEKit\n\nNT = 100\nΔt = 1/NT \n\nn = 10\nm = 2n \nh = 1/n\n\n# Create a very simple mesh\nelements = FiniteStrainContinuum[]\nprop = Dict(\"name\"=> \"PlaneStressIncompressibleRivlinSaunders\", \"rho\"=> 1.0,  \"C1\"=>1e-3, \"C2\"=>1e-1)\ncoords = zeros((m+1)*(n+1), 2)\nfor j = 1:n\n    for i = 1:m\n        idx = (m+1)*(j-1)+i \n        elnodes = [idx; idx+1; idx+1+m+1; idx+m+1]\n        ngp = 3\n        nodes = [\n            (i-1)*h (j-1)*h\n            i*h (j-1)*h\n            i*h j*h\n            (i-1)*h j*h\n        ]\n        coords[elnodes, :] = nodes\n        push!(elements, FiniteStrainContinuum(nodes, elnodes, prop, ngp))\n    end\nend\n\n# impose force on the top\nEdge_Traction_Data = Array{Int64}[]\nfor i = 1:m \n  elem = elements[i]\n  for k = 1:4\n    if elem.coords[k,2]<0.001 && elem.coords[k+1>4 ? 1 : k+1,2]<0.001\n      push!(Edge_Traction_Data, [i, k, 1])\n    end\n  end\nend\nEdge_Traction_Data = hcat(Edge_Traction_Data...)'|>Array\n\n# fixed Dirichlet boundaries on the bottom and right \nEBC = zeros(Int64, (m+1)*(n+1), 2)\nFBC = zeros(Int64, (m+1)*(n+1), 2)\ng = zeros((m+1)*(n+1), 2)\nf = zeros((m+1)*(n+1), 2)\nfor j = 1:n+1\n    idx = (j-1)*(m+1) + m+1\n    EBC[idx,:] .= -1 # fixed boundary, right\nend\nfor i = 1:m+1\n    idx = n*(m+1) + i \n    EBC[idx,:] .= -1 # fixed boundary, bottom\nend\n\ndimension = 2\ndomain = Domain(coords, elements, dimension, EBC, g, FBC, f, Edge_Traction_Data)\n\n# Set initial condition: at rest\nDstate = zeros(domain.neqs) \nstate = zeros(domain.neqs)\nvelo = zeros(domain.neqs)\nacce = zeros(domain.neqs)\nEBC_func = nothing \nFBC_func = nothing \nBody_func = nothing \n# Construct Edge_func\nfunction Edge_func_hyperelasticity(x, y, t, idx)\n  return [zeros(length(x)) ones(length(x))] * sin(π/2 * t)\nend\nglobaldata = GlobalData(state, Dstate, velo, acce, domain.neqs, EBC_func, FBC_func,Body_func, Edge_func_hyperelasticity)\n\nassembleMassMatrix!(globaldata, domain)\n# initial acceleration is not known, and therefore must be computed using the balance equation\nSolverInitial!(Δt, globaldata, domain)\n\nupdateStates!(domain, globaldata)\nfor i = 1:NT\n    @info i \n    # global globaldata, domain = GeneralizedAlphaSolverStep(globaldata, domain, Δt)\n    global globaldata, domain = ExplicitSolverStep(globaldata, domain, Δt)\nend\nd_ = hcat(domain.history[\"state\"]...)'|>Array\n\n# p = visualize_displacement(d_, domain)\n# saveanim(p, \"hyperelasticity_exp.gif\")","category":"page"},{"location":"hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"note: Note\nFor explicit solvers, it is very important that the time step size is sufficiently small. NNFEM provides a function for estimation of the step size:ω = EigenMode(Δt, globaldata, domain)\n@show \"stable time step is \", 0.8 * 2/ω, \" current time step is \", Δt","category":"page"},{"location":"hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"The following figures show the result using both implicit and explicit schemes","category":"page"},{"location":"hyperelasticity/","page":"Hyperelasticity","title":"Hyperelasticity","text":"Explicit Solver Implicit Solver\n(Image: ) (Image: )","category":"page"},{"location":"verify/#Dynamic-Problems","page":"Dynamic Problems","title":"Dynamic Problems","text":"","category":"section"},{"location":"verify/","page":"Dynamic Problems","title":"Dynamic Problems","text":"NNFEM can be used to solve the folowing dynamical problem","category":"page"},{"location":"verify/","page":"Dynamic Problems","title":"Dynamic Problems","text":"ddot u - textdivsigma  = f xin Omega tag1","category":"page"},{"location":"verify/","page":"Dynamic Problems","title":"Dynamic Problems","text":"where u is the 2D displacement vector, sigma is the stress, and f is the body force. The dynamical equation is supplemented with two kinds of boundary conditions: Dirichlet boundary conditions and Neumann boundary conditions. For each type of conditions, we consider two types: time-dependent and time-independent. The following matrix shows all possible boundary conditions supported by NNFEM. ","category":"page"},{"location":"verify/","page":"Dynamic Problems","title":"Dynamic Problems","text":"Types Dirichlet Neumann\nTime-independent u(xt) = u_1(x) xin Gamma_D^1 sigma(xt)n(x) = t_1(x) xin Gamma_N^1\nTime-dependent u(xt) = u_2(xt) xin Gamma_D^2 sigma(xt)n(x) = t_2(x) xin Gamma_N^2","category":"page"},{"location":"verify/","page":"Dynamic Problems","title":"Dynamic Problems","text":"The weak form of Equation 1 can be written as ","category":"page"},{"location":"verify/","page":"Dynamic Problems","title":"Dynamic Problems","text":"int_Omega u delta u dx  + int_Omega sigma delta epsilon dx = int_Omega f delta u dx + int_Gamma_N t delta u dx tag2","category":"page"},{"location":"verify/","page":"Dynamic Problems","title":"Dynamic Problems","text":"Here ","category":"page"},{"location":"verify/","page":"Dynamic Problems","title":"Dynamic Problems","text":"int_Gamma_N t delta u dx =int_Gamma_N^1 t_1 delta u dx + int_Gamma_N^2 t_2 delta u dx","category":"page"},{"location":"verify/","page":"Dynamic Problems","title":"Dynamic Problems","text":"In NNFEM, the boundary information are marked in EBC and FBC arrays in the geometry information Domain, respectively. These arrays have size n_vtimes 2, corresponding to n_v nodes and x-/y-directions. -1 represents time-independent boundaries and -2 represents time-dependent boundaries. Time indepdent boundary conditions g and fext are precomputed and fed to Domain, while time independent bounary conditions can be evaluated online with EBC_func and FBC_func in GlobalData. In the case the external load is provided as t(xt) = sigma(xt)n(x), we can use Edge_func and Edge_Traction_Data to provide the information instead of  FBC_func. ","category":"page"},{"location":"verify/","page":"Dynamic Problems","title":"Dynamic Problems","text":"If we express Equation 2 in terms of matrices, we have","category":"page"},{"location":"verify/","page":"Dynamic Problems","title":"Dynamic Problems","text":"M ddotmathbfu + K (mathbfu) = mathbff + mathbft","category":"page"},{"location":"verify/","page":"Dynamic Problems","title":"Dynamic Problems","text":"Here K(mathbfu) can be nonlinear. ","category":"page"},{"location":"verify/","page":"Dynamic Problems","title":"Dynamic Problems","text":"There are two solver implemented in NNFEM: the explicit solver and the generalized alpha solver. Both solvers support automatic differentiation for a linear K. The explicit solver also supports automatic differentiation for nonlinear K. ","category":"page"},{"location":"verify/","page":"Dynamic Problems","title":"Dynamic Problems","text":"To get started, you can study the following examples. Most likely you only need to modify the script to meet your own needs. ","category":"page"},{"location":"verify/#Settings","page":"Dynamic Problems","title":"Settings","text":"","category":"section"},{"location":"verify/","page":"Dynamic Problems","title":"Dynamic Problems","text":"In the following examples, we consider the following domain. ","category":"page"},{"location":"verify/","page":"Dynamic Problems","title":"Dynamic Problems","text":"(Image: Untitled)","category":"page"},{"location":"verify/","page":"Dynamic Problems","title":"Dynamic Problems","text":"The manufactured is given by ","category":"page"},{"location":"verify/","page":"Dynamic Problems","title":"Dynamic Problems","text":"u(x y t) = 01(1-y^2)(x^2+y^2) e^-t v(x y t)=01(1-y^2)(x^2-y^2)e^-t","category":"page"},{"location":"verify/","page":"Dynamic Problems","title":"Dynamic Problems","text":"The domain for small strain can be constructed as follows","category":"page"},{"location":"verify/","page":"Dynamic Problems","title":"Dynamic Problems","text":"NT = 100\nΔt = 1/NT \n\nn = 10\nm = 2n \nh = 1/n\n\n# Create a very simple mesh\nelements = SmallStrainContinuum[]\nprop = Dict(\"name\"=> \"PlaneStrain\", \"rho\"=> 1.0, \"E\"=>2.0, \"nu\"=>0.35)\ncoords = zeros((m+1)*(n+1), 2)\nfor j = 1:n\n    for i = 1:m\n        idx = (m+1)*(j-1)+i \n        elnodes = [idx; idx+1; idx+1+m+1; idx+m+1]\n        ngp = 3\n        nodes = [\n            (i-1)*h (j-1)*h\n            i*h (j-1)*h\n            i*h j*h\n            (i-1)*h j*h\n        ]\n        coords[elnodes, :] = nodes\n        push!(elements, SmallStrainContinuum(nodes, elnodes, prop, ngp))\n    end\nend\n\nEdge_Traction_Data = Array{Int64}[]\nfor i = 1:m \n  elem = elements[i]\n  for k = 1:4\n    if elem.coords[k,2]<0.001 && elem.coords[k+1>4 ? 1 : k+1,2]<0.001\n      push!(Edge_Traction_Data, [i, k, 1])\n    end\n  end\nend\n\nfor i = 1:n\n  elem = elements[(i-1)*m+1]\n  for k = 1:4\n    if elem.coords[k,1]<0.001 && elem.coords[k+1>4 ? 1 : k+1,1]<0.001\n      push!(Edge_Traction_Data, [(i-1)*m+1, k, 0])\n    end\n  end\nend\n\nEdge_Traction_Data = hcat(Edge_Traction_Data...)'|>Array\n\n# fixed on the bottom, push on the right\nEBC = zeros(Int64, (m+1)*(n+1), 2)\nFBC = zeros(Int64, (m+1)*(n+1), 2)\ng = zeros((m+1)*(n+1), 2)\nf = zeros((m+1)*(n+1), 2)\nfor j = 1:n+1\n    idx = (j-1)*(m+1) + m+1\n    EBC[idx,:] .= -2 # time-dependent boundary, right\nend\nfor i = 1:m+1\n    idx = n*(m+1) + i \n    EBC[idx,:] .= -1 # fixed boundary, bottom\nend\n\ndimension = 2\ndomain = Domain(coords, elements, dimension, EBC, g, FBC, f, Edge_Traction_Data)\n\nxy = domain.nodes[domain.dof_to_eq]\nn_ = div(length(xy),2)\nx = xy[1:n_,1]\ny = xy[n_+1:end,1]\n# Set initial condition \nDstate = zeros(domain.neqs) # d at last step \nstate = [(@. (1-y^2)*(x^2+y^2)); (@. (1-y^2)*(x^2-y^2))] * 0.1 \nvelo = -[(@. (1-y^2)*(x^2+y^2)); (@. (1-y^2)*(x^2-y^2))] * 0.1 \nacce = [(@. (1-y^2)*(x^2+y^2)); (@. (1-y^2)*(x^2-y^2))] * 0.1 \ngt = nothing\nft = nothing\n\nEBC_DOF = findall(EBC[:,1] .== -2)\nx_EBC = domain.nodes[EBC_DOF,1]\ny_EBC = domain.nodes[EBC_DOF,2]\nfunction EBC_func(t)\n  out = [(@. 0.1*(1-y_EBC^2)*(x_EBC^2+y_EBC^2)*exp(-t));\n    (@. 0.1*(1-y_EBC^2)*(x_EBC^2-y_EBC^2)*exp(-t))]\n  \n  out, -out, out\nend\n\nfunction Body_func_linear_elasticity(x, y, t)\n    f1 = @. 0.987654320987654*x*y*exp(-t) + 0.592592592592593*y^2*exp(-t) + (0.1 - 0.1*y^2)*(x^2 + y^2)*exp(-t) - (0.148148148148148 - 0.148148148148148*y^2)*exp(-t) - (0.641975308641975 - 0.641975308641975*y^2)*exp(-t) - (-0.148148148148148*x^2 - 0.148148148148148*y^2)*exp(-t)\n    f2 = @. 0.987654320987654*x*y*exp(-t) - 2.5679012345679*y^2*exp(-t) + (0.1 - 0.1*y^2)*(x^2 - y^2)*exp(-t) - (0.148148148148148 - 0.148148148148148*y^2)*exp(-t) - (-0.641975308641975*x^2 + 0.641975308641975*y^2)*exp(-t) - (0.641975308641975*y^2 - 0.641975308641975)*exp(-t)\n    [f1 f2] \nend\n\nFBC_func = nothing \nEdge_func = nothing\nglobaldata = GlobalData(state, Dstate, velo, acce, domain.neqs, EBC_func, FBC_func,Body_func_linear_elasticity, Edge_func)","category":"page"},{"location":"verify/","page":"Dynamic Problems","title":"Dynamic Problems","text":"The setting of the domain can be visualized as follows","category":"page"},{"location":"verify/","page":"Dynamic Problems","title":"Dynamic Problems","text":"visualize_boundary(domain)\ngca().invert_yaxis()","category":"page"},{"location":"verify/","page":"Dynamic Problems","title":"Dynamic Problems","text":"(Image: Untitled)","category":"page"},{"location":"verify/","page":"Dynamic Problems","title":"Dynamic Problems","text":"At this point, we can precompute some quantities","category":"page"},{"location":"verify/","page":"Dynamic Problems","title":"Dynamic Problems","text":"x = domain.nodes[:,1]\ny = domain.nodes[:,2]\nd0 = [(@. (1-y^2)*(x^2+y^2)); (@. (1-y^2)*(x^2-y^2))] * 0.1 \nv0 = -[(@. (1-y^2)*(x^2+y^2)); (@. (1-y^2)*(x^2-y^2))] * 0.1 \na0 = [(@. (1-y^2)*(x^2+y^2)); (@. (1-y^2)*(x^2-y^2))] * 0.1 \nassembleMassMatrix!(globaldata, domain)","category":"page"},{"location":"verify_function/#Helper-Functions","page":"Helper Functions","title":"Helper Functions","text":"","category":"section"},{"location":"verify_function/","page":"Helper Functions","title":"Helper Functions","text":"There are many helper functions for facilitating forward computation. This note can serve as examples how to use them as well as a way to verify the results. ","category":"page"},{"location":"verify_function/#compute_boundary_info","page":"Helper Functions","title":"compute_boundary_info","text":"","category":"section"},{"location":"verify_function/","page":"Helper Functions","title":"Helper Functions","text":"This function prepares the boundary information. Only time-dependent displacement and accelration are implemented. ","category":"page"},{"location":"verify_function/","page":"Helper Functions","title":"Helper Functions","text":"ts = ExplicitSolverTime(Δt, NT)\nubd0, abd0 = compute_boundary_info(domain, globaldata, ts)\n\nidx = findall(domain.EBC[:,1].==-2)\nx = domain.nodes[idx,1]\ny = domain.nodes[idx,2]\nfor i = 1:NT\n    t = ts[i]\n    ubd[i,:] = [\n        @. (1-y^2)*(x^2+y^2)*0.1*exp(-t)\n        @. (1-y^2)*(x^2-y^2)*0.1*exp(-t)\n    ]\n    abd[i,:] = [\n        @. (1-y^2)*(x^2+y^2)*0.1*exp(-t)\n        @. (1-y^2)*(x^2-y^2)*0.1*exp(-t)\n    ]\nend\n\n@show maximum(abs.(ubd0-ubd))\n@show maximum(abs.(abd0-abd))","category":"page"},{"location":"verify_function/#compute_external_force","page":"Helper Functions","title":"compute_external_force","text":"","category":"section"},{"location":"verify_function/","page":"Helper Functions","title":"Helper Functions","text":"compute_external_force returns the external force we need to add to the right hand side of the equation. ","category":"page"},{"location":"verify_function/","page":"Helper Functions","title":"Helper Functions","text":"This includes the body force, the edge force, and the force due to acceleration. ","category":"page"},{"location":"verify_function/","page":"Helper Functions","title":"Helper Functions","text":"ts = ExplicitSolverTime(Δt, NT)\nfext = compute_external_force(domain, globaldata, ts)\n\nfor i = 1:NT\n    t = ts[i]\n    globaldata.time = t\n    Fext[i,:] = getExternalForce(domain, globaldata)\nend\n@show maximum(abs.(fext-Fext))","category":"page"},{"location":"verify_function/#getEdgeForce","page":"Helper Functions","title":"getEdgeForce","text":"","category":"section"},{"location":"verify_function/","page":"Helper Functions","title":"Helper Functions","text":"m = 10\nn = 5\nh = 1.0\ndomain = example_domain(m, n, h)\nglobaldata = example_global_data(domain)\nedge_traction_data = zeros(Int64, m, 3)\nfor i = 1:m \n  edge_traction_data[i,:] = [i;1;0]\nend\ndomain.edge_traction_data = edge_traction_data\nfunction edge_func(x, y, t, idx)\n  return [(@. x^2+y^2) (@. x^2-y^2)]\nend\nglobaldata.Edge_func = edge_func\nF = getEdgeForce(domain, globaldata, 0.0)","category":"page"},{"location":"verify_function/","page":"Helper Functions","title":"Helper Functions","text":"To verify the results, we can use PoreFlow.jl","category":"page"},{"location":"verify_function/","page":"Helper Functions","title":"Helper Functions","text":"using PoreFlow\nbdedge = bcedge(\"upper\", m, n, h)\nt = zeros(m, 2)\nfor i = 1:m\n  x = (i-0.5)*h\n  y = 0\n  t[i,:] = [x^2+y^2;x^2-y^2]\nend\nv = compute_fem_traction_term(t, bdedge, m, n, h)","category":"page"},{"location":"verify_function/","page":"Helper Functions","title":"Helper Functions","text":"We can visualize the both force vectors","category":"page"},{"location":"verify_function/","page":"Helper Functions","title":"Helper Functions","text":"plot(v, \"-\", label=\"compute_fem_traction_term\")\nplot(F, \"--\", label=\"getEdgeForce\")\nxlabel(\"Index\")\nlegend()","category":"page"},{"location":"verify_function/","page":"Helper Functions","title":"Helper Functions","text":"(Image: )","category":"page"},{"location":"#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Getting Started","title":"Getting Started","text":"Under Construction. ","category":"page"}]
}
