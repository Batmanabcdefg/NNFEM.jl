var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference-1","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Elements-1","page":"API Reference","title":"Elements","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"Modules = [NNFEM]\nPages   = [\"FiniteStrainContinuum.jl\", \"FiniteStrainContinuum.jl\", \"FiniteStrainContinuum.jl\"]","category":"page"},{"location":"api/#NNFEM.FiniteStrainContinuum","page":"API Reference","title":"NNFEM.FiniteStrainContinuum","text":"FiniteStrainContinuum\n\nImplements the finite strain element. \n\neledim: spatial dimension of the element (default = 2).\nmat: constitutive law, a length #elem vector of materials such as PlaneStress\nelnodes: the node indices in this finite element, an integer array \nprops: property dictionary \ncoords: coordinates of the vertices of the element\ndhdx, weights, hs: data for integral \nstress: stress at each quadrature points\n\n\n\n\n\n","category":"type"},{"location":"api/#Materials-1","page":"API Reference","title":"Materials","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"Modules = [NNFEM]\nPages   = [\"PlaneStress.jl\", \"PlaneStrain.jl\", \"PlaneStressIncompressibleRivlinSaunders.jl\",\n            \"PlaneStressPlasticity\"]","category":"page"},{"location":"api/#NNFEM.PlaneStrain","page":"API Reference","title":"NNFEM.PlaneStrain","text":"\n\n\n\n","category":"type"},{"location":"api/#NNFEM.PlaneStressIncompressibleRivlinSaunders","page":"API Reference","title":"NNFEM.PlaneStressIncompressibleRivlinSaunders","text":"Pascon, João Paulo.  \"Large deformation analysis of plane-stress hyperelastic problems via triangular membrane finite elements.\"  International Journal of Advanced Structural Engineering (2019): 1-20.\n\n\n\n\n\n","category":"type"},{"location":"api/#Assembly-1","page":"API Reference","title":"Assembly","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"Modules = [NNFEM]\nPages   = [\"assembly.jl\", \"fem.jl\"]","category":"page"},{"location":"api/#NNFEM.assembleInternalForce","page":"API Reference","title":"NNFEM.assembleInternalForce","text":"Numerically assemble internal force vector, compute local internal force f_int \nfrom domain.state and then assemble to F_int\n- 'globdat': GlobalData\n- 'domain': Domain, finite element domain, for data structure\n- 'Δt':  Float64, current time step size\nReturn F_int: Float64[neqs], internal force vector\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.assembleMassMatrix!-Tuple{GlobalData,Domain}","page":"API Reference","title":"NNFEM.assembleMassMatrix!","text":"compute constant sparse mass matrix\ndue to the time-dependent Dirichlet boundary condition\nmass matrix = M,    MID\n              MID'  MDD\n\n- 'globdat': GlobalData\n- 'domain': Domain, finite element domain, for data structure\nhere M is Float64[neqns, neqns]\n     MID is Float64[neqns, nd1]\n     Mlumped is Float64[neqns]\n\nupdate M and MID and Mlumpe in globaldat\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.assembleStiffAndForce","page":"API Reference","title":"NNFEM.assembleStiffAndForce","text":"Numerically assemble internal force vector and stiffness matrix, compute local internal force f_int/ \nstiffness matrix Slocal from domain.state and then assemble to F_int/Ksparse\n- 'globdat': GlobalData\n- 'domain': Domain, finite element domain, for data structure\n- 'Δt':  Float64, current time step size\nReturn F_int: Float64[neqs], internal force vector\nReturn Ksparse: Float64[neqs, neqns], sparse stiffness matrix\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.tfAssembleInternalForce-Tuple{Domain,Function,PyCall.PyObject,PyCall.PyObject,PyCall.PyObject,PyCall.PyObject}","page":"API Reference","title":"NNFEM.tfAssembleInternalForce","text":"Tensorflow version of assembling internal force vector, compute local internal \nforce f_int and then assemble to F_int, which generates inverse problem automatically.\n\n- 'domain': Domain, finite element domain, for data structure\n- 'nn': Function strain -> stress, neural network constitutive law function \n- 'E_all': PyObject(Float64)[neles*nGauss, nstrains], neles*nGauss is the number of Gaussian quadrature points, \n           nstrain is the number of strain components. All strains for the current time-step\n- 'DE_all': PyObject(Float64)[neles*nGauss, nstrains], neles*nGauss is the number of Gaussian quadrature points, \n            nstrain is the number of strain components. All strains for the previous time-step\n- 'w∂E∂u_all': PyObject(Float64)[neles*nGauss, ndofs_per_element, nstrains], neles*nGauss is the number of Gaussian quadrature points, \n               ndofs_per_element is the number of freedoms per element, nstrain is the number of strain components.\n               Multiplication of the Gaussian weight and ∂E∂u^T for current time-step, \n        \n- 'σ0_all': PyObject(Float64)[neles*nGauss, nstrains], neles*nGauss is the number of Gaussian quadrature points, \nnstrain is the number of strain components.  All stresses for the last time-step\n\nReturn: internal force vector F_int, PyObject(Float64)[neqns] and the predicted stresses at the \n        current step σ_all, PyObject(Float64)[neles*nGauss, nstrains]\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.Domain","page":"API Reference","title":"NNFEM.Domain","text":"Domain\n\nDate structure for the computatational domain\n\nnnodes: Int64, number of nodes (each quadratical quad element has 9 nodes)\nnodes: Float64[nnodes, ndims], coordinate array of all nodes\nneles: number of elements \nelements: Element[neles], element array, each element is a struct \nndims: Int64, dimension of the problem space \nstate: Float64[nnodes*ndims] current displacement of all nodal freedoms, Float64[1:nnodes] are for the first direction.\nDstate: Float64[nnodes*ndims] previous displacement of all nodal freedoms, Float64[1:nnodes] are for the first direction.\n'LM':  Int64[neles][ndims], LM(e,d) is the global equation number(active freedom number) of element e's d th freedom,         -1 means fixed (time-independent) Dirichlet        -2 means time-dependent Dirichlet\n'DOF': Int64[neles][ndims], DOF(e,d) is the global freedom number of element e's d th freedom\n'ID':  Int64[nnodes, ndims], ID(n,d) is the equation number(active freedom number) of node n's dth freedom,         -1 means fixed (time-independent) Dirichlet        -2 means time-dependent Dirichlet\n'neqs':  Int64,  number of equations or active freedoms\n'eqtodof':  Int64[neqs], map from to equation number(active freedom number) to the freedom number (Int64[1:nnodes] are for the first direction) \n'doftoeq':  Bool[nnodes*ndims], map from freedom number(Int64[1:nnodes] are for the first direction) to booleans (active freedoms(equation number) are true)\n'EBC':  Int64[nnodes, ndims], EBC[n,d] is the displacement boundary condition of node n's dth freedom,          -1 means fixed(time-independent) Dirichlet boundary nodes          -2 means time-dependent Dirichlet boundary nodes\n'g':  Float64[nnodes, ndims], values for fixed(time-independent) Dirichlet boundary conditions of node n's dth freedom,\n'FBC': Int64[nnodes, ndims], FBC[n,d] is the force load boundary condition of node n's dth freedom,          -1 means constant(time-independent) force load boundary nodes          -2 means time-dependent force load boundary nodes\n'fext':  Float64[neqs], constant(time-independent) force load boundary conditions for these freedoms\n'time': Float64, current time\n'npoints': Int64, number of points (each quadratical quad element has 4 points, npoints==nnodes, when porder==1)\n'nodetopoint': Int64[nnodes]:map from node number to point point, -1 means the node is not a geometry point\n'ii_stiff': Int64[], first index of the sparse matrix representation of the stiffness matrix\n'jj_stiff': Int64[], second index of the sparse matrix representation of the stiffness matrix\n'vvstiffele_indptr': Int64[], Int64[e] is the first index entry for the e's element of the sparse matrix representation of the stiffness matrix\n'vv_stiff': Float64[], values of the sparse matrix representation of the stiffness matrix\n'iidfintdstress': Int64[], first index of the sparse matrix representation of the dfint_dstress matrix \n'jjdfintdstress': Int64[], second index of the sparse matrix representation of the dfint_dstress matrix\n'vvdfintdstresseleindptr': Int64[], Int64[e] is the first index entry for the e's element of the sparse matrix representation of the dfint_dstress matrix\n'vvdfintdstress': Float64[], values of the sparse matrix representation of the dfint_dstress matrix \n'iidstraindstate': Int64[], first index of the sparse matrix representation of the dstrain_dstate matrix\n'jjdstraindstate': Int64[], second index of the sparse matrix representation of the dstrain_dstate matrix\n'vvdstraindstateeleindptr': Int64[], Int64[e] is the first index entry for the e's element of the sparse matrix representation of the stiffness matrix\n'vvdstraindstate': Float64[], values of the sparse matrix representation of the dstrain_dstate matrix\n'history': Dict{String, Array{Array{Float64}}}, dictionary between string and its time-histories quantity Float64[ntime][]\n\n\n\n\n\n","category":"type"},{"location":"api/#NNFEM.Domain-Tuple{Array{Float64,N} where N,Array,Int64,Array{Int64,N} where N,Array{Float64,N} where N,Array{Int64,N} where N,Array{Float64,N} where N}","page":"API Reference","title":"NNFEM.Domain","text":"Creating a finite element domain\n\n- `nodes`: Float64[nnodes, ndims], coordinate array of all nodes\n- `elements`: Element[neles], element array, each element is a struct \n- `ndims`: Int64, dimension of the problem space \n- 'EBC':  Int64[nnodes, ndims], EBC[n,d] is the displacement boundary condition of node n's dth freedom,\n       -1 means fixed(time-independent) Dirichlet boundary nodes\n       -2 means time-dependent Dirichlet boundary nodes\n- 'g':  Float64[nnodes, ndims], values for fixed(time-independent) Dirichlet boundary conditions of node n's dth freedom,\n- 'FBC': Int64[nnodes, ndims], FBC[n,d] is the force load boundary condition of node n's dth freedom,\n       -1 means constant(time-independent) force load boundary nodes\n       -2 means time-dependent force load boundary nodes\n- 'f':  Float64[nnodes, ndims], values for constant(time-independent) force load boundary conditions of node n's dth freedom,\n\nReturn: Domain, the finite element domain\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.GlobalData","page":"API Reference","title":"NNFEM.GlobalData","text":"GlobalData\n\nStore data for finite element update, assume the problem has n freedoms\n\nstate: Float64[n],  displacement array at the current time, only for active freedoms,   the ordering is based on the equation number, here ndims=2 is the dimension of the problem space\nstate: Float64[n],  displacement array at the previous time\nvelo: Float64[n],  velocity array at the current \nacce: Float64[n],  acceleration array at the current \ntime: float, current time\nM: Float64[n,n] spares mass matrix\nMlumped: Float64[n] lumped mass array\nMID: Float64[n, nd1] off-diagonal part of the mass matrix, between the active freedoms and the time-dependent Dirichlet freedoms, assume there are nd time-dependent Dirichlet freedoms\nEBC_func: function Float64:t-> Float64[n_d1] float array, time-dependent Dirichlet boundary condition (ordering is direction first then node number, u1, u3, ... v1, v4 ...)\nFBC_func: function Float64:t-> Float64[n_t1] float array, time-dependent load boundary condition (ordering is direction first then node number, u1, u3, ... v1, v4 ...)\n\n\n\n\n\n","category":"type"},{"location":"api/#NNFEM.setGeometryPoints!-Tuple{Domain,Int64,Array{Int64,N} where N}","page":"API Reference","title":"NNFEM.setGeometryPoints!","text":"In the constructor \nUpdate the node_to_point map \n\n- `self`: Domain, finit element domain\n- 'npoints': Int64, number of points (each quadratical quad element has 4 points, npoints==nnodes, when porder==1)\n- 'node_to_point': Int64[nnodes]:map from node number to point point, -1 means the node is not a geometry point\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.setNeumannBoundary!-Tuple{Domain,Array{Int64,N} where N,Array{Float64,N} where N}","page":"API Reference","title":"NNFEM.setNeumannBoundary!","text":"In the constructor\nUpdate the external force vector fext\n- 'self': Domain\n- 'FBC': Int64[nnodes, ndims], FBC[n,d] is the force load boundary condition of node n's dth freedom,\n       -1 means constant(time-independent) force load boundary nodes\n       -2 means time-dependent force load boundary nodes\n- 'f':  Float64[nnodes, ndims], values for constant(time-independent) force load boundary conditions of node n's dth freedom,\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.updateDomainStateBoundary!-Tuple{Domain,GlobalData}","page":"API Reference","title":"NNFEM.updateDomainStateBoundary!","text":"Update time dependent boundary of state fext in Domain based on the time-dependent boundary functions in GlobalData.\n\n'self': Domain\n'globaldat': GlobalData\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.updateStates!-Tuple{Domain,GlobalData}","page":"API Reference","title":"NNFEM.updateStates!","text":"At each time step\nUpdate the state and Dstate in Domain from GlobalData\nstate and Dstate in GlobalData are only for active freedoms (equations)\nstate and Dstate in Domain are only for all freedoms, they are used for constructing the internal force and/or stiffness matrix\nupdate the state and acc history of the Domain\n- 'self': Domain\n- 'globaldat': GlobalData\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.assembleSparseMatrixPattern!-Tuple{Domain}","page":"API Reference","title":"NNFEM.assembleSparseMatrixPattern!","text":"Compute constant stiff, dfint_dstress, dstrain_dstate matrix patterns\n- 'self': Domain\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.commitHistory-Tuple{Domain}","page":"API Reference","title":"NNFEM.commitHistory","text":"Update current step strain, stress in the history map of the Domain\nstrain and stress are both Float[ngp, nstrain], ngp is the number of Gaussian quadrature point\nnstrain=1 for 1D and nstrain = 3 for 2D \nThe strain is in Voigt notation\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.getCoords-Tuple{Domain,Array{Int64,N} where N}","page":"API Reference","title":"NNFEM.getCoords","text":"Get the coordinates of several nodes (possibly in one element)\n- 'self': Domain\n- 'el_nodes': Int64[n], node array\n\nReturn: Float64[n, ndims], the coordinates of these nodes\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.getDofs-Tuple{Domain,Int64}","page":"API Reference","title":"NNFEM.getDofs","text":"Get the global freedom numbers of the element\n- 'self': Domain\n- 'iele': Int64, element number\n\nReturn: Int64[], the global freedom numbers of the element (ordering in local element ordering)\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.getDstate-Tuple{Domain,Array{Int64,N} where N}","page":"API Reference","title":"NNFEM.getDstate","text":"Get the displacements of several nodes (possibly in one element) at the previous time step\n- 'self': Domain\n- 'el_nodes': Int64[n], node array\n\nReturn: Float64[n, ndims], the displacements of these nodes at the previous time step\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.getEqns-Tuple{Domain,Int64}","page":"API Reference","title":"NNFEM.getEqns","text":"Get the equation numbers(active freedom numbers) of the element\n- 'self': Domain\n- 'iele': Int64, element number\n\nReturn: Int64[], the equation numbers(active freedom numbers) of the element (ordering in local element ordering)\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.getExternalForce!-Tuple{Domain,GlobalData,Array{Float64,N} where N}","page":"API Reference","title":"NNFEM.getExternalForce!","text":"Compute external force vector, including external force load and time-dependent Dirichlet boundary conditions\nThe function needs to be called after\nfunction updateDomainStateBoundary!(self::Domain, globaldat::GlobalData)\nwhich computes the external force vector from external force load\n\n- 'self': Domain\n- 'globaldat': GlobalData\n- 'fext': Float64[neqs], container for the external force vector\n\nreturn external force vector at the present step\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.getState-Tuple{Domain,Array{Int64,N} where N}","page":"API Reference","title":"NNFEM.getState","text":"Get the displacements of several nodes (possibly in one element)\n- 'self': Domain\n- 'el_nodes': Int64[n], node array\n\nReturn: Float64[n, ndims], the displacements of these nodes\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.setDirichletBoundary!-Tuple{Domain,Array{Int64,N} where N,Array{Float64,N} where N}","page":"API Reference","title":"NNFEM.setDirichletBoundary!","text":"In the constructor \nUpdate the fixed (time-independent Dirichlet boundary) state entries \nBuild LM, and DOF array\n- 'self': Domain\n- 'EBC':  Int64[nnodes, ndims], EBC[n,d] is the displacement boundary condition of node n's dth freedom,\n       -1 means fixed(time-independent) Dirichlet boundary nodes\n       -2 means time-dependent Dirichlet boundary nodes\n- 'g':  Float64[nnodes, ndims], values for fixed(time-independent) Dirichlet boundary conditions of node n's dth freedom,\n''\n\n\n\n\n\n","category":"method"},{"location":"api/#Solvers-1","page":"API Reference","title":"Solvers","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"Modules = [NNFEM]\nPages   = [\"NNSolver.jl\", \"Solvers.jl\"]","category":"page"},{"location":"api/#NNFEM.DynamicMatLawLoss-Tuple{Domain,Array{Float64,N} where N,Array{Float64,N} where N,Array{Float64,N} where N,Function}","page":"API Reference","title":"NNFEM.DynamicMatLawLoss","text":"- 'domain': Domain, finite element domain, for data structure\n- 'E_all':  Float64[NT+1, neles*nGauss, nstrains], all strains for the whole simulation from training data\n- 'w∂E∂u_all': Float64[NT+1, neles*nGauss, ndofs_per_element, nstrains], \n            multiplication of the Gaussian weight and ∂E∂u^T for the whole simulation from training data \n- 'F_tot': Float64[NT, neqs] approximated internal force for the whole simulation, from time n=1 to time n=NT\n\nform the loss function, based on dynamic equilibrium \n    (Mddu + fint(NN, E, DE) + MIDddu_bc = fext\n\nwe have  \n    F_tot  = fext - MIDddu_bc - Mddu\nloss = ∑ ||fint(NN, E, DE) - F_tot||^2\n\ntodo\nWe assume the time step is constant for the training data\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.DynamicMatLawLoss-Union{Tuple{S}, Tuple{T}, Tuple{Domain,GlobalData,Array{T,N} where N,Array{S,N} where N,Function,Float64}} where S where T","page":"API Reference","title":"NNFEM.DynamicMatLawLoss","text":"- 'domain': Domain,  finite element domain\n- 'globdat': GlobalData,  finite element data structure\n- 'state_history': Float64[NT+1][ndofs], displace history of all time steps and all nodes, including time 0\n                hcat(state_history...) gives a matrix of Float64[NT+1, ndofs]\n- 'fext_history': Float64[NT+1][neqns] or Float64[NT][neqns]: external force load of all time steps and all equations, \n                with or without the initial step\n                hcat(fext_history...) gives a matrix of size(neqns, NT+1)\nnn: Neural network\nΔt: time step size\n\ncompute loss function from state and external force history\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.LSfittingStress-Tuple{Domain,GlobalData,Array{Float64,N} where N,Array{Float64,N} where N,Float64,String}","page":"API Reference","title":"NNFEM.LSfittingStress","text":"Fit the stress from the strain and external load conditions, \nFor quadratic element, nx, ny, ... elements in each direction\nThe number of equations are neqs ≈ 2*(2nx + 1)*(2ny + 1)\nLinear approach : Assume the stress in each element is constant, the number of unknows are 3*nx*ny\nConstant approach: Assume the stress in each element is linear, the number of unknows are 3*(nx+1)*(ny+1) on each nodes\nLeast Square problem is solving for stress\n\n- 'domain': Domain \n- 'globdat': GlobalData\n- 'state_history': Float64[NT+1, ndofs], displacement fields for each freedoms\n- 'F_ext': Float64[neqns, NT+1] or Float64[neqns, NT+1], external force vector for each equations\n- 'Δt': Float64, time step size\n- 'method': String \"Constant\" or \"Linear\" for Constant approach or Linear approach\n\nReturn: \n- 'E_all':  Float64[NT+1, neles*ngps_per_elem, nstrain], strain fields\n- 'S_all':  Float64[NT+1, neles*ngps_per_elem, nstrain], fitted stress fields at each Gaussian quadratic point\n\nRemark: Turss 1D requires method == \"Constant\", otherwise the system is under constraint\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.LSfittingStressHelper-Tuple{Any,Array{Float64,N} where N,String}","page":"API Reference","title":"NNFEM.LSfittingStressHelper","text":"Compute the Fint, dFintdScomp, Eall, Sall and dfintdstress, based on the state in domain and the stress in Scomp\n\n'domain': Domain\n'S_comp': Float64[neles, nstrain] or Float64[npoints, nstrain], the stresses in each element(Constant) or at each geometric point(Linear)\n'method': String \"Constant\" or \"Linear\" for Constant approach or Linear approach\n\nReturn      Fint: Float64[neqns], constructed from state in domain     dFintdScomp: Float64[neqs,  size(Scomp,1)*nstrain], sparse matrix representation     Eall: Float64[nelesngpsperelem, nstrain], strains at each Gaussian quadrature point ,constructed from state in domain     S_all: Float64[nelesngpsperelem, nstrain], stresses at each Gaussian quadrature point ,constructed from S_comp\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.preprocessing-Tuple{Domain,GlobalData,Array{Float64,N} where N,Float64}","page":"API Reference","title":"NNFEM.preprocessing","text":"Postprocess the data from domain.history and F_ext\n- 'domain': Domain, domain.history[\"state\"] is Float64[NT+1][ndofs] \n- 'globdat': GlobalData, for mass matrix\n- 'F_ext': Float64[neqns, NT+1] or Float64[neqns, NT], external force history with/without the initial step\n- 'Δt': Float64, time step size\n\nReturn:\n- 'F_tot': Float64[NT, neqns], approxmiated internal force\n- 'E_all': Float64[NT+1, neles*nGauss, nstrains], all strains for the whole simulation from training data\n- 'w∂E∂u_all': Float64[NT+1, neles*nGauss, neqns_per_elem, nstrains], multiplication of the Gaussian weight and ∂E∂u^T \nfor the whole simulation from training data \n\n\ntodo\nWe assume the time step is constant for the training data\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.AdaptiveSolver-NTuple{6,Any}","page":"API Reference","title":"NNFEM.AdaptiveSolver","text":"Adaptive Solver, solve the whole process, if this step fails, redo the step with half of\nthe time step size, when there are continuing 5 successful steps, double the step size when dt < T/NT\n\n- 'solvername': String,  so far only NewmarkSolver is supported\n- 'globdat', GlobalData\n- 'domain', Domain\n- 'T', Float64, total simulation time\n- 'NT', Int64, planned time steps\n- 'args', Dict{String, Value}, arguments for the solver\n\n\nreturn globdat, domain, ts, here ts is Float64[nteps+1]\n\ntodo For the first time step a0 = M^{-1}(- f^{int}(u0) + f^{ext}_0)\n\nWe assume globdat.acce[:] = a_0 and so far initialized to 0\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.ExplicitSolver-Tuple{Any,Any,Any}","page":"API Reference","title":"NNFEM.ExplicitSolver","text":"Central Difference explicit solver\n\n'Δt': Float64,  time step size \n'globdat', GlobalData\n'domain', Domain\n\nCentral Difference explicit solver for M a + fint(u) = fext(u), with lumped mass matrix (MID = 0) a, v, u are acceleration, velocity and displacement\n\nbeginalign\nu_n+1 = u_n + dtv_n + dt^22 a_n \nv_n+1 = v_n + dt2(a_n + a_n+1) \nM a_n+1 + f^int(u_n+1) = f^ext_n+1 \nM a_n+1 = f^ext_n+1 - f^int(u_n+1) \nendalign\n\nuse the current states a, v, u, time in globdat, and update these stetes to next time step update domain history \n\ntodo For the first time step a0 = M^{-1}(- f^{int}(u0) + f^{ext}_0)\n\nWe assume globdat.acce[:] = a_0 and so far initialized to 0\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.NewmarkSolver","page":"API Reference","title":"NNFEM.NewmarkSolver","text":"NewmarkSolver (Generalized-alpha) implicit solver\n\n'Δt': Float64,  time step size \n'globdat', GlobalData\n'domain', Domain\n'αm', Float64\n'αf', Float64 \n'ε', Float64, absolute error for Newton convergence\n'ε0', Float64, relative error for Newton convergence\n'maxiterstep', Int64, maximum iteration number for Newton convergence\n'η', Float64, Newton step size at the first iteration\n'failsafe', Bool, if failsafe is true, when the Newton fails to converge,              revert back, and return false\n\nImplicit solver for Ma  + fint(u) = fext a, v, u are acceleration, velocity and displacement respectively.\n\nu_n+1 = u_n + dtv_n + dt^22 ((1 - 2beta)a_n + 2beta a_n+1)\nv_n+1 = v_n + dt((1 - gamma)a_n + gamma a_n+1)\n2beta = 05*(1 - αm + αf)^2\ngamma = 05 - alpha_m + alpha_f\n\n\na_n+1-alpha_m = (1-alpha_m)a_n+1 + alpha_m a_n \nv_n+1-alpha_f = (1-alpha_f)v_n+1 + alpha_f v_n\nu_n+1-alpha_f = (1-alpha_f)u_n+1 + alpha_f u_n\nM a_n+1-alpha_m + f^int(u_n+1-alpha_f) = f^ext_n+1-alpha_f\n\n'a_{n+1}' is solved by \n\nM ((1-alpha_m)a_n+1 + alpha_m a_n)  \n+ f^int((1-alpha_f)(u_n + dtv_n + dt^22 ((1 - 2beta)a_n + 2beta a_n+1))) + alpha_f u_n) \n= f^ext_n+1-alpha_f\n\nAs for '\\alpham' and '\\alphaf'\n\nalpha_m = (2rho_infty - 1)(rho_infty + 1)\nalpha_f = rho_infty(rho_infty + 1)\n\nuse the current states a, v, u, time in globdat, and update these stetes to next time step update domain history, when failsafe is true, and Newton's solver fails, nothing will be changed.\n\ntodo For the first time step a0 = M^{-1}(- f^{int}(u0) + f^{ext}_0)\n\nWe assume globdat.acce[:] = a_0 and so far initialized to 0 We also assume the external force is conservative (it does not depend on the current deformation)\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.StaticSolver","page":"API Reference","title":"NNFEM.StaticSolver","text":"Static implicit solver\n\n'globdat', GlobalData\n'domain', Domain\n'loaditerstep', Int64, load stepping steps\n'ε', Float64, absolute error for Newton convergence\n'maxiterstep', Int64, maximum iteration number for Newton convergence\n\nSolver for fint(u) = fext with load stepping, u is the displacement. Iteratively solve u_{i}\n\nf^int(u_i) = iloaditerstep f^ext\n\ntodo We assume the external force is conservative (it does not depend on the current deformation)\n\n\n\n\n\n","category":"function"},{"location":"api/#Utilities-1","page":"API Reference","title":"Utilities","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"Modules = [NNFEM]\nPages   = [\"io.jl\", \"matrix.jl\", \"shapeFunctions\", \"Testsuit.jl\", \"Visualize.jl\", \"linearConstitutiveLaw.jl\"]","category":"page"},{"location":"api/#NNFEM.orthotropic_H-Tuple{PyCall.PyObject}","page":"API Reference","title":"NNFEM.orthotropic_H","text":"orthotropic_H(y::PyObject)\northotropic_H(o::Array)\n\nCreates a symmetric matrix from 4 parameters\n\nH = beginbmatrix\ny_1  y_2  0 \ny_2  y_3  0  \n0  0  y_4\nendbmatrix\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.spd_Chol_Orth-Tuple{Array}","page":"API Reference","title":"NNFEM.spd_Chol_Orth","text":"spd_Chol_Orth(o::Array)\nspd_Chol_Orth(o::PyObject)\n\nCreates a SPD matrix from 4 scalars. \n\nA = LL\n\nwhere\n\nL = beginbmatrix\no_1   \no_2  o_3  \n    o_4 \nendbmatrix\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.spd_Cholesky-Tuple{Array}","page":"API Reference","title":"NNFEM.spd_Cholesky","text":"spd_Cholesky(o::Array)\nspd_Cholesky(o::PyObject)\n\nCreates a SPD matrix from 6 scalars. \n\nA = LL\n\nwhere\n\nL = beginbmatrix\no_1    \no_2  o_4  \no_3  o_5  o_6 \nendbmatrix\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.spd_H-Tuple{PyCall.PyObject,Array{Float64,2}}","page":"API Reference","title":"NNFEM.spd_H","text":"spd_H(o::PyObject, H0::Array{Float64,2})\nspd_H(o::Array, H0::Array)\n\nCreates a SPD matrix from 3 scalars\n\nH = H_0 - fracH_0nnH_01+nH_0n\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.spd_zero_to_H-Tuple{PyCall.PyObject,Array{Float64,2}}","page":"API Reference","title":"NNFEM.spd_zero_to_H","text":"spd_zero_to_H(o::Array)\nspd_zero_to_H(o::Array, H0inv::Array{Float64,2})\n\nCreates a SPD matrix from 4 scalars. \n\nA = (H_0^-1 +LL)^-1\n\nwhere\n\nL =  beginbmatrix\no_1   \no_2  o_3  \n    o_4\nendbmatrix\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.sym_H-Tuple{PyCall.PyObject}","page":"API Reference","title":"NNFEM.sym_H","text":"sym_H(y::PyObject)\nsym_H(o::Array)\n\nCreates a symmetric matrix from 6 parameters\n\nH = beginbmatrix\ny_1  y_2  y_3 \ny_2  y_4  y_5  \ny_3  y_5  y_6\nendbmatrix\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.gradtest-Tuple{Function,Array{Float64,N} where N}","page":"API Reference","title":"NNFEM.gradtest","text":"gradtest(f::Function, x0::Array{Float64}; scale::Float64 = 1.0)\n\nTesting the gradients of a vector function f.  Here x0 is n-dimensional vector, f takes an n-dimensional vector as inputs, and outputs a m dimensional vector. The function tests the second order convergence of f\n\nf(x_0+gamma c) - f(x_0) - gamma nabla f(x_0) c_2 = mathcalO(gamma^2)\n\n\n\n\n\n","category":"method"},{"location":"#Getting-Started-1","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"#","page":"Getting Started","title":"Getting Started","text":"Under Construction. ","category":"page"}]
}
