var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference-1","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Core-Data-Structure-1","page":"API Reference","title":"Core Data Structure","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"Domain\nGlobalData","category":"page"},{"location":"api/#NNFEM.Domain","page":"API Reference","title":"NNFEM.Domain","text":"Domain\n\nDate structure for the computatational domain.\n\nnnodes: Int64, number of nodes (each quadratical quad element has 9 nodes)\nnodes: Float64[nnodes, ndims], coordinate array of all nodes\nneles: number of elements \nelements: a list of neles element arrays, each element is a struct \nndims: Int64, dimension of the problem space \nstate: a matrix of size nnodes×ndims. Current displacement of all nodal freedoms, state[1:nnodes] are for the first direction.\nDstate: nnodes×ndims. Previous displacement of all nodal freedoms, Dstate[1:nnodes] are for the first direction.\nLM:  Int64[neles][ndims], LM(e,d) is the global equation number (active freedom number) of element e's d th freedom, \n   ∘ -1 means fixed (time-independent) Dirichlet\n\n   ∘ -2 means time-dependent Dirichlet\n\n   ∘ >0 means the global equation number\nDOF: a matrix of size neles×ndims, DOF(e,d) is the global freedom number of element e's d th freedom\nID:  a matrix of size nnodes×ndims. ID(n,d) is the equation number (active freedom number) of node n's d-th freedom, \n   ∘ -1 means fixed (time-independent) Dirichlet\n\n   ∘ -2 means time-dependent Dirichlet\n\n   ∘ >0 means the global equation number\nneqs:  Int64,  number of equations, a.k.a., active freedoms\neq_to_dof:  an integer vector of length neqs, map from to equation number (active freedom number) to the freedom number (Int64[1:nnodes] are for the first direction) \ndof_to_eq:  a bolean array of size nnodes×ndims, map from freedom number(Int64[1:nnodes] are for the first direction) to booleans (active freedoms(equation number) are true)\nEBC:  Int64[nnodes, ndims], EBC[n,d] is the displacement boundary condition of node n's dth freedom,          -1 means fixed(time-independent) Dirichlet boundary nodes          -2 means time-dependent Dirichlet boundary nodes\ng:  Float64[nnodes, ndims], values for fixed(time-independent) Dirichlet boundary conditions of node n's dth freedom,\nFBC: Int64[nnodes, ndims], FBC[n,d] is the force load boundary condition of node n's dth freedom,          -1 means constant(time-independent) force load boundary nodes          -2 means time-dependent force load boundary nodes\nfext:  Float64[neqs], constant (time-independent) nodal forces on these freedoms\nEdge_Traction_Data: n × 3 integer matrix for natural boundary conditions.     EdgeTractionData[i,1] is the element id,     EdgeTractionData[i,2] is the local edge id in the element, where the force is exterted (should be on the boundary, but not required)     EdgeTractionData[i,3] is the force id, which should be consistent with the last component of the Edge_func in the Globdat\ntime: Float64, current time\nnpoints: Int64, number of points (each quadratical quad element has 4 points, npoints==nnodes, when porder==1)\nnode_to_point: Int64[nnodes]:map from node number to point point, -1 means the node is not a geometry point\n\nAuxilliry Data Structures\n\nii_stiff: Int64[], first index of the sparse matrix representation of the stiffness matrix\njj_stiff: Int64[], second index of the sparse matrix representation of the stiffness matrix\nvv_stiff_ele_indptr: Int64[], Int64[e] is the first index entry for the e's element of the sparse matrix representation of the stiffness matrix\nvv_stiff: Float64[], values of the sparse matrix representation of the stiffness matrix\nii_dfint_dstress: Int64[], first index of the sparse matrix representation of the dfint_dstress matrix \njj_dfint_dstress: Int64[], second index of the sparse matrix representation of the dfint_dstress matrix\nvv_dfint_dstress_ele_indptr: Int64[], Int64[e] is the first index entry for the e's element of the sparse matrix representation of the dfint_dstress matrix\nvv_dfint_dstress: Float64[], values of the sparse matrix representation of the dfint_dstress matrix \nii_dstrain_dstate: Int64[], first index of the sparse matrix representation of the dstrain_dstate matrix\njj_dstrain_dstate: Int64[], second index of the sparse matrix representation of the dstrain_dstate matrix\nvv_dstrain_dstate_ele_indptr: Int64[], Int64[e] is the first index entry for the e's element of the sparse matrix representation of the stiffness matrix\nvv_dstrain_dstate: Float64[], values of the sparse matrix representation of the dstrain_dstate matrix\nhistory: Dict{String, Array{Array{Float64}}}, dictionary between string and its time-histories quantity Float64[ntime][]\n\n\n\n\n\n","category":"type"},{"location":"api/#NNFEM.GlobalData","page":"API Reference","title":"NNFEM.GlobalData","text":"GlobalData\n\nStore data for finite element updates. Assume the problem has n freedoms,\n\nstate: a vector of length n. Displacement array at the current time, only for active freedoms.  The ordering is based on the equation number.\nDstate: a vector of length n. Displacement array at the previous time.\nvelo: a vector of length n. Velocity array at the current time.\nacce: a vector of length n. Acceleration array at the current time.\ntime: float, current time.\nM: a matrix of size ntimes n spares mass matrix\nMlumped: a vector of length n lumped mass array\nMID: Float64[n, nd1] off-diagonal part of the mass matrix, between the active freedoms and the time-dependent Dirichlet freedoms, assume there are nd time-dependent Dirichlet freedoms\nEBC_func: displacement d, velocity v, and acceleration a from time-dependent Dirichlet boundary conditions \n\nd v a = textEBC_func(texttime)\n\nThe length of each output is the same as number of \"-2\" in EBC array. The ordering is direction major, i.e., u_1 u_3 ldots v_1 v_3 ldots \n\nFBC_func: time-dependent load boundary condition. \n\nf = textFBC_func(texttime)\n\nHere f is a vector. Its length is the same as number of \"-2\" in FBC array. The ordering is direction major, i.e., u_1 u_3 ldots v_1 v_3 ldots \n\nBody_func: time-dependent/independent body force function. \n\nf = textBody_func(x_textarray y_textarray texttime)\n\nHere f is a vector. Its length is the same as the length of x_textarray or y_textarray.\n\nEdge_func: time-dependent/independent traction load. \n\nf = textEdge_func(x_textarray y_textarray texttime textid)\n\nHere f is a vector. Its length is the same as the length of x_textarray or y_textarray.\n\n\n\n\n\n","category":"type"},{"location":"api/#Core-Data-Structure-Utilities-1","page":"API Reference","title":"Core Data Structure Utilities","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"getEqns\ngetNGauss","category":"page"},{"location":"api/#NNFEM.getEqns","page":"API Reference","title":"NNFEM.getEqns","text":"getEqns(domain::Domain, iele::Int64)\n\nGets the equation numbers(active freedom numbers) of the element.  This excludes both the time-dependent and time-independent Dirichlet boundary conditions. \n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.getNGauss","page":"API Reference","title":"NNFEM.getNGauss","text":"getNGauss(domain::Domain)\n\nGets the total number of Gauss quadrature points. \n\n\n\n\n\n","category":"function"},{"location":"api/#Elements-1","page":"API Reference","title":"Elements","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"Modules = [NNFEM]\nPages   = [\"FiniteStrainContinuum.jl\", \"SmallStrainContinuum.jl\", \"FiniteStrainTruss.jl\"]","category":"page"},{"location":"api/#NNFEM.FiniteStrainContinuum","page":"API Reference","title":"NNFEM.FiniteStrainContinuum","text":"FiniteStrainContinuum(coords::Array{Float64}, elnodes::Array{Int64}, props::Dict{String, Any}, ngp::Int64=2)\n\n\n\n\n\n","category":"type"},{"location":"api/#NNFEM.FiniteStrainContinuum","page":"API Reference","title":"NNFEM.FiniteStrainContinuum","text":"FiniteStrainContinuum\n\nConstructs a finite strain element. \n\neledim: spatial dimension of the element (default = 2).\nmat: constitutive law, a length #elem vector of materials such as PlaneStress\nelnodes: the node indices in this finite element, an integer array \nprops: property dictionary \ncoords: coordinates of the vertices of the element\ndhdx, weights, hs: data for integral \nstress: stress at each quadrature points\n\nExample\n\n#   Local degrees of freedom \n#   4 ---- 3\n#\n#   1 ---- 2\n\nnx = 10\nny = 5\nh = 0.1\nelement = FiniteStrainContinuum[]\nprop = Dict(\"name\"=> \"PlaneStrain\", \"rho\"=> 0.0876584, \"E\"=>0.07180760098, \"nu\"=>0.4)\nfor j = 1:ny\n    for i = 1:nx \n        n = (nx+1)*(j-1) + (i-1)+1\n        elnodes = [n, n + 1, n + 1 + (nx + 1), n + (nx + 1)]\n        ngp = 3 # 3 x 3 Gauss points per element \n        coords = [(i-1)*h (j-1)*h\n                    i*h (j-1)*h\n                    i*h j*h\n                    (i-1)*h j*h]\n        push!(element, FiniteStrainContinuum(coords,elnodes, prop, ngp))\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"api/#NNFEM.SmallStrainContinuum","page":"API Reference","title":"NNFEM.SmallStrainContinuum","text":"SmallStrainContinuum(coords::Array{Float64}, elnodes::Array{Int64}, props::Dict{String, Any}, ngp::Int64=2)\n\n\n\n\n\n","category":"type"},{"location":"api/#NNFEM.SmallStrainContinuum","page":"API Reference","title":"NNFEM.SmallStrainContinuum","text":"SmallStrainContinuum\n\nConstructs a small strain element. \n\neledim: spatial dimension of the element (default = 2).\nmat: constitutive law, a length #elem vector of materials such as PlaneStress\nelnodes: the node indices in this finite element, an integer array \nprops: property dictionary \ncoords: coordinates of the vertices of the element\ndhdx: list of ngp shape functions for first order derivatives nabla phi(x) (ndof×2) on the Gaussian points\nweights: weight vector of length n_gauss_points, for numerical quadrature\nhs: list of ngp shape functions for function values phi(x) (length ndof vectors) on the Gaussian points\nstress: stress at each quadrature points; this field is reserved for visualization. \n\nExample\n\n#   Local degrees of freedom \n#   4 ---- 3\n#\n#   1 ---- 2\n\nnx = 10\nny = 5\nh = 0.1\nelement = SmallStrainContinuum[]\nprop = Dict(\"name\"=> \"PlaneStrain\", \"rho\"=> 0.0876584, \"E\"=>0.07180760098, \"nu\"=>0.4)\nfor j = 1:ny\n    for i = 1:nx \n        n = (nx+1)*(j-1) + (i-1)+1\n        elnodes = [n, n + 1, n + 1 + (nx + 1), n + (nx + 1)]\n        ngp = 3 # 3 x 3 Gauss points per element \n        coords = [(i-1)*h (j-1)*h\n                    i*h (j-1)*h\n                    i*h j*h\n                    (i-1)*h j*h]\n        push!(element, SmallStrainContinuum(coords,elnodes, prop, ngp))\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"api/#NNFEM.getInternalForce-Tuple{SmallStrainContinuum,Array{Float64,N} where N,Array{Float64,N} where N,Float64}","page":"API Reference","title":"NNFEM.getInternalForce","text":"getInternalForce(elem::SmallStrainContinuum, state::Array{Float64}, Dstate::Array{Float64}, Δt::Float64)\n\nReturns the internal force term. state and Dstate are restriction of full state variables to this element. \n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.getStiffAndForce-Tuple{SmallStrainContinuum,Array{Float64,N} where N,Array{Float64,N} where N,Float64}","page":"API Reference","title":"NNFEM.getStiffAndForce","text":"getStiffAndForce(elem::SmallStrainContinuum, state::Array{Float64}, Dstate::Array{Float64}, Δt::Float64)\n\nReturns the internal force term and the stiffness matrix. state and Dstate are restriction of full state variables to this element. \n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.getStrain-Tuple{SmallStrainContinuum,Array{Float64,N} where N}","page":"API Reference","title":"NNFEM.getStrain","text":"getStrain(elem::SmallStrainContinuum, state::Array{Float64})\n\nReturns the strain of this element.  state is restricted to this variable. \n\n\n\n\n\n","category":"method"},{"location":"api/#Materials-1","page":"API Reference","title":"Materials","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"Modules = [NNFEM]\nPages   = [\"PlaneStress.jl\", \"PlaneStrain.jl\", \"PlaneStressIncompressibleRivlinSaunders.jl\",\n            \"PlaneStressPlasticity\"]","category":"page"},{"location":"api/#NNFEM.PlaneStress","page":"API Reference","title":"NNFEM.PlaneStress","text":"PlaneStress\n\nCreates a plane stress element\n\nH: Linear elasticity matrix, 3times3\nE: Young's modulus\nν: Poisson's ratio \nρ: density \nσ0: stress at the last time step \nσ0_: (for internal use), stress to be updated in commitHistory\nε0: strain at the last time step \nε0_: (for internal use), strain to be updated in commitHistory\n\nExample\n\nprop = Dict(\"name\"=> \"PlaneStress\", \"rho\"=> 0.0876584, \"E\"=>0.07180760098, \"nu\"=>0.4)\nmat = PlaneStress(prop)\n\n\n\n\n\n","category":"type"},{"location":"api/#NNFEM.PlaneStress-Tuple{Dict{String,Any}}","page":"API Reference","title":"NNFEM.PlaneStress","text":"PlaneStress(prop::Dict{String, Any})\n\nprop should contain at least the following three fields: E, nu, rho\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.PlaneStrain","page":"API Reference","title":"NNFEM.PlaneStrain","text":"PlaneStrain\n\nCreates a plane strain element\n\nH: Linear elasticity matrix, 3times3\nE: Young's modulus\nν: Poisson's ratio \nρ: density \nσ0: stress at the last time step \nσ0_: (for internal use), stress to be updated in commitHistory\nε0: strain at the last time step \nε0_: (for internal use), strain to be updated in commitHistory\n\nExample\n\nprop = Dict(\"name\"=> \"PlaneStrain\", \"rho\"=> 0.0876584, \"E\"=>0.07180760098, \"nu\"=>0.4)\nmat = PlaneStrain(prop)\n\n\n\n\n\n","category":"type"},{"location":"api/#NNFEM.PlaneStrain-Tuple{Dict{String,Any}}","page":"API Reference","title":"NNFEM.PlaneStrain","text":"PlaneStrain(prop::Dict{String, Any})\n\nprop should contain at least the following three fields: E, nu, rho\n\n\n\n\n\n","category":"method"},{"location":"api/#NNFEM.PlaneStressIncompressibleRivlinSaunders","page":"API Reference","title":"NNFEM.PlaneStressIncompressibleRivlinSaunders","text":"Pascon, João Paulo.  \"Large deformation analysis of plane-stress hyperelastic problems via triangular membrane finite elements.\"  International Journal of Advanced Structural Engineering (2019): 1-20.\n\n\n\n\n\n","category":"type"},{"location":"api/#Matrix-and-Vector-Assembly-1","page":"API Reference","title":"Matrix and Vector Assembly","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"assembleInternalForce\nassembleStiffAndForce\nassembleMassMatrix!\ngetBodyForce\ngetExternalForce!","category":"page"},{"location":"api/#NNFEM.assembleInternalForce","page":"API Reference","title":"NNFEM.assembleInternalForce","text":"assembleInternalForce(globdat::GlobalData, domain::Domain, Δt::Float64 = 0.0)\n\nComputes the internal force vector F_mathrmint of length neqs\n\nglobdat: GlobalData\ndomain: Domain, finite element domain, for data structure\nΔt:  Float64, current time step size\n\n\n\n\n\nassembleInternalForce(domain::Domain, nn::Function, E_all::PyObject, DE_all::PyObject, w∂E∂u_all::PyObject, σ0_all::PyObject)\n\nComputes local internal force fint and then assemble to Fint, which generates inverse problem automatically.\n\ndomain: finite element domain\nnn: constitutive relation for expressing stress = f(strain), assuming stress and strain are defined on Gauss points ((neles*nGauss) × nstrains).\nE_all: strain data of size (neles*nGauss) × nstrains at the current time step.\nDE_all: strain data of size (neles*nGauss) × nstrains at the last time step.\nw∂E∂u_all: sensitivity matrix of size (neles*nGauss) x ndofs_per_element x nstrains; neles*nGauss is the number of Gaussian quadrature points,  ndofs_per_element is the number of freedoms per element, and nstrain is the number of strain components. The sensitivity matrix already considers the quadrature weights. \n\ns_gji^e = w_g^efracpartial epsilon_g^epartial u_j^e\n\nwhere e is the element index, g is the Gaussian index. \n\nσ0_all: stress data of size neles*nGauss×nstrains at the last time step. \n\nReturn: \n\nF_mathrmint\n:  internal force vector of length neqns\nsigma_mathrmall\n: predicted stress at current step, a matrix of size (neles*nGauss) × nstrains\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.assembleStiffAndForce","page":"API Reference","title":"NNFEM.assembleStiffAndForce","text":"assembleStiffAndForce(globdat::GlobalData, domain::Domain, Δt::Float64 = 0.0)\n\nComputes the internal force and stiffness matrix. \n\nglobdat: GlobalData\ndomain: Domain, finite element domain, for data structure\nΔt:  Float64, current time step size\n\nReturns a length neqs vector F_mathrmint and neqs×neqs sparse stiffness matrix. \n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.assembleMassMatrix!","page":"API Reference","title":"NNFEM.assembleMassMatrix!","text":"assembleMassMatrix!(globaldat::GlobalData, domain::Domain)\n\nComputes the constant sparse mass matrix M_mathrmmass, the lumped mass matrix M_mathrmlump due to time-dependent Dirichlet boundary conditions, and store them in globaldat. \n\nM_mathrmmassbeginbmatrix\nM  M_ID \nM_ID^T  M_DD \nendbmatrix\n\nHere M is a neqns×neqns matrix, and M_ID is a neqns×nd matrix. M_mathrmlump assumes that the local mass matrix is a diagonal matrix. \n\nglobdat: GlobalData\ndomain: Domain, finite element domain, for data structure\n\n(Image: )\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.getBodyForce","page":"API Reference","title":"NNFEM.getBodyForce","text":"getBodyForce(elem::Continuum, fvalue::Array{Float64,2})\n\nReturns the body force. \n\nfvalue is a n_gausstimes 2 matrix, which is ordered the same as    Gaussian points in the undeformed parent element.\n\nReturns the nodal force due to the body force int_e mathbff(mathbfx)cdot delta mathbfu(mathbfx) d mathbfx    = int_e mathbff(mathbfxi)cdot delta mathbfu(mathbfxi)    fracpartial mathbfxpartial mathbfxi d mathbfxi\n\ntodo force in the deformed domain\n\n\n\n\n\ngetBodyForce(domain::Domain, globdat::GlobalData, time::Float64)\n\nComputes the body force vector F_mathrmbody of length neqs\n\nglobdat: GlobalData\ndomain: Domain, finite element domain, for data structure\nΔt:  Float64, current time step size\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.getExternalForce!","page":"API Reference","title":"NNFEM.getExternalForce!","text":"getExternalForce!(self::Domain, globaldat::GlobalData, fext::Union{Missing,Array{Float64}}=missing)\n\nComputes external force vector at globaldat.time,  including both external force load and time-dependent Dirichlet boundary conditions.\n\n\n\n\n\n","category":"function"},{"location":"api/#State-Updates-1","page":"API Reference","title":"State Updates","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"This set of functions include boundary condition updates, data transfer, and other bookkeeping utilities.","category":"page"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"commitHistory\nsetConstantDirichletBoundary!\nsetConstantNodalForces!\nupdateStates!\nupdateDomainStateBoundary!","category":"page"},{"location":"api/#NNFEM.commitHistory","page":"API Reference","title":"NNFEM.commitHistory","text":"commitHistory(elem::Continuum)\n\nUpdates the historic parameters in the material properties. \n\n\n\n\n\ncommitHistory(domain::Domain)\n\nUpdate current step strain and stress in the history map of the domain.  This is essential for visualization and time dependent constitutive relations. \n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.setConstantDirichletBoundary!","page":"API Reference","title":"NNFEM.setConstantDirichletBoundary!","text":"setConstantDirichletBoundary!(self::Domain, EBC::Array{Int64}, g::Array{Float64})\n\nBookkeepings for time-independent Dirichlet boundary conditions. Only called once in the constructor of domain.  It updates the fixed (time-independent Dirichlet boundary) state entries and builds both LM and DOF arrays.\n\nself: Domain\nEBC:  Int64[nnodes, ndims], EBC[n,d] is the displacement boundary condition of node n's dth freedom,\n∘ -1 means fixed(time-independent) Dirichlet boundary nodes\n∘ -2 means time-dependent Dirichlet boundary nodes\ng:  Float64[nnodes, ndims], values for fixed (time-independent) Dirichlet boundary conditions of node n's dth freedom,\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.setConstantNodalForces!","page":"API Reference","title":"NNFEM.setConstantNodalForces!","text":"Bookkeepings for time-independent Nodal force boundary conditions. Only called once in the constructor of domain.  It updates the fixed (time-independent Nodal forces) state entries and builds both LM and DOF arrays.\n\nself: Domain\nFBC:  Int64[nnodes, ndims], FBC[n,d] is the displacement boundary condition of node n's dth freedom,\n∘ -1 means fixed (time-independent) Nodal force freedoms\n∘ -2 means time-dependent Nodal force freedoms\nf:  Float64[nnodes, ndims], values for fixed (time-independent) Neumann boundary conditions of node n's dth freedom,\n\n#The name is misleading\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.updateStates!","page":"API Reference","title":"NNFEM.updateStates!","text":"updateStates!(domain::Domain, globaldat::GlobalData)\nupdate time-dependent Dirichlet boundary condition to globaldat.time\n\nAt each time step, updateStates! needs to be called to update the full state and Dstate in domain from active ones in globaldat.\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.updateDomainStateBoundary!","page":"API Reference","title":"NNFEM.updateDomainStateBoundary!","text":"updateDomainStateBoundary!(self::Domain, globaldat::GlobalData)\nupdate time-dependent Dirichlet boundary condition to globaldat.time\n\nIf there exists time-dependent Dirichlet boundary conditions, updateDomainStateBoundary! must be called to update  the boundaries in domain. This function is called by updateStates!\n\n\n\n\n\n","category":"function"},{"location":"api/#Solvers-1","page":"API Reference","title":"Solvers","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"ExplicitSolverStep\nGeneralizedAlphaSolverStep\nSolverInitial!\nSolverInitial","category":"page"},{"location":"api/#NNFEM.ExplicitSolverStep","page":"API Reference","title":"NNFEM.ExplicitSolverStep","text":"ExplicitSolverStep(globdat::GlobalData, domain::Domain, Δt::Float64)\n\nCentral Difference explicit solver for M a + fint(u) = fext(u). a, v, u are acceleration, velocity and displacement.\n\nbeginalign\nu_n+1 = u_n + dtv_n + dt^22 a_n \nv_n+1 = v_n + dt2(a_n + a_n+1) \nM a_n+1 + f^int(u_n+1) = f^ext_n+1 \nM a_n+1 = f^ext_n+1 - f^int(u_n+1) \nendalign\n\ninfo: Info\nYou need to call SolverInitial! before the first time step, if f^ext_0 neq 0.  Otherwise we assume the initial acceleration globdat.acce[:] = 0.\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.GeneralizedAlphaSolverStep","page":"API Reference","title":"NNFEM.GeneralizedAlphaSolverStep","text":"GeneralizedAlphaSolverStep(globdat::GlobalData, domain::Domain, Δt::Float64, \nρ::Float64 = 0.0, ε::Float64 = 1e-8, ε0::Float64 = 1e-8, maxiterstep::Int64=100, \nη::Float64 = 1.0, failsafe::Bool = false, verbose::Bool = false)\n\nImplicit solver for  Ma  + f_int(u) = fext Here a, v, u are acceleration, velocity and displacement respectively.\n\nρ: controls the damping effect of the α-scheme, ρ∈[0,1], ρ=1 corresponds to the maximum damping\nε: Float64, absolute error for Newton convergence\nε0: Float64, relative error for Newton convergence\nmax_iter: Int64, maximum iteration number for Newton convergence\nη: Float64, Newton step size at the first iteration\nfailsafe: Bool, if failsafe is true, when the Newton fails to converge,              revert back, and return false\n\nThe nonlinear alpha\n\nu_n+1 = u_n + dtv_n + dt^22 ((1 - 2beta)a_n + 2beta a_n+1)\nv_n+1 = v_n + dt((1 - gamma)a_n + gamma a_n+1)\n2beta = 05*(1 - αm + αf)^2\ngamma = 05 - alpha_m + alpha_f\n\na_n+1-alpha_m = (1-alpha_m)a_n+1 + alpha_m a_n \nv_n+1-alpha_f = (1-alpha_f)v_n+1 + alpha_f v_n\nu_n+1-alpha_f = (1-alpha_f)u_n+1 + alpha_f u_n\nM a_n+1-alpha_m + f^int(u_n+1-alpha_f) = f^ext_n+1-alpha_f\n\n'a_{n+1}' is solved by \n\nM ((1-alpha_m)a_n+1 + alpha_m a_n)  \n+ f^int((1-alpha_f)(u_n + dtv_n + dt^22 ((1 - 2beta)a_n + 2beta a_n+1))) + alpha_f u_n) \n= f^ext_n+1-alpha_f\n\nAs for \\alpha_m and alpha_f\n\nalpha_m = (2rho_infty - 1)(rho_infty + 1)\nalpha_f = rho_infty(rho_infty + 1)\n\nuse the current states a, v, u, time in globdat, and update these stetes to next time step update domain history, when failsafe is true, and Newton's solver fails, nothing will be changed.\n\nYou need to call SolverInitial! before the first time step, if f^{ext}0 != 0. SolverInitial! updates a0 in the globdat.acce a0 = M^{-1}(- f^{int}(u0) + f^{ext}_0)\n\nWe assume globdat.acce[:] = a_0 and so far initialized to 0 We also assume the external force is conservative (it does not depend on the current deformation)\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.SolverInitial!","page":"API Reference","title":"NNFEM.SolverInitial!","text":"SolverInitial!(Δt::Float64, globdat::GlobalData, domain::Domain)\n\nYou need to call SolverInitial! before the first time step, if f^ext_0 neq 0\n\na_0 = M^-1(- f^int(u_0) + f^ext_0)\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.SolverInitial","page":"API Reference","title":"NNFEM.SolverInitial","text":"SolverInitial(Δt::Float64, globdat::GlobalData, domain::Domain)\n\nSimilar to SolverInitial!, but returns the (displacement, velocity, acceleartion) tuple. \n\n\n\n\n\n","category":"function"},{"location":"api/#Utilities-1","page":"API Reference","title":"Utilities","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"meshread\nvisualize_von_mises_stress\nvisualize_displacement","category":"page"},{"location":"api/#Automatic-Differentiation-1","page":"API Reference","title":"Automatic Differentiation","text":"","category":"section"},{"location":"api/#","page":"API Reference","title":"API Reference","text":"init_nnfem\ns_eval_strain_on_gauss_points\ns_compute_stiffness_matrix\ns_compute_internal_force_term\nf_eval_strain_on_gauss_points\nf_compute_internal_force_term\nExplicitSolver\nExplicitSolverTime\nGeneralizedAlphaSolver\nGeneralizedAlphaSolverTime\ncompute_boundary_info\ncompute_external_force","category":"page"},{"location":"api/#NNFEM.init_nnfem","page":"API Reference","title":"NNFEM.init_nnfem","text":"init_nnfem(domain::Domain)\n\nPrepares domain for use in custom operators.\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.s_eval_strain_on_gauss_points","page":"API Reference","title":"NNFEM.s_eval_strain_on_gauss_points","text":"s_eval_strain_on_gauss_points(state::Union{Array{Float64,1}, PyObject})\n\nComputes the strain on Gauss points in the small strain case. state is the full displacement vector. \n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.s_compute_stiffness_matrix","page":"API Reference","title":"NNFEM.s_compute_stiffness_matrix","text":"s_compute_stiffness_matrix(k::Union{Array{Float64,3}, PyObject})\n\nComputes the small strain stiffness matrix. k is a ntimes 3times 3 matrix, where n is the total number of Gauss points. Returns a SparseTensor. \n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.s_compute_internal_force_term","page":"API Reference","title":"NNFEM.s_compute_internal_force_term","text":"s_compute_internal_force_term(stress::Union{Array{Float64,2}, PyObject})\n\nComputes the internal force int_Omega sigma  delta epsilon dx Only active DOFs are considered. \n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.f_eval_strain_on_gauss_points","page":"API Reference","title":"NNFEM.f_eval_strain_on_gauss_points","text":"f_eval_strain_on_gauss_points(state::Union{Array{Float64,1}, PyObject})\n\nComputes the strain on Gauss points in the finite strain case. state is the full displacement vector. \n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.f_compute_internal_force_term","page":"API Reference","title":"NNFEM.f_compute_internal_force_term","text":"f_compute_internal_force_term(stress::Union{Array{Float64,2}, PyObject}, \n    state::Union{Array{Float64,1}, PyObject},\n    domain::Domain)\n\nComputes the internal force for finite strain continuum\n\nint_Omega sigma  delta epsilon dx\n\nOnly active DOFs are considered. \n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.ExplicitSolver","page":"API Reference","title":"NNFEM.ExplicitSolver","text":"ExplicitSolver(globdat::GlobalData, domain::Domain,\n    d0::Union{Array{Float64, 1}, PyObject}, \n    v0::Union{Array{Float64, 1}, PyObject}, \n    a0::Union{Array{Float64, 1}, PyObject}, \n    Δt::Float64, NT::Int64, \n    H::Union{Array{Float64, 3}, Array{Float64, 2}, PyObject},\n    Fext::Union{Array{Float64, 2}, PyObject, Missing}=missing,\n    ubd::Union{Array{Float64, 2}, PyObject, Missing}=missing,\n    abd::Union{Array{Float64, 2}, PyObject, Missing}=missing; strain::String = \"small\")\n\nDifferentiable Explicit Solver. \n\nd0, v0, a0: initial full displacement, velocity, and acceleration. \nΔt: time step \nHs: linear elasticity matrix at each Gauss point \nFext: external force, mathrmNTtimes n, where n is the active dof.  The external force includes all body forces, external load forces (also called edge forces in NNFEM) and boundary acceleration-induced forces.\nubd, abd: boundary displacementt and acceleration, mathrmNTtimes m, where m is time-dependent boundary DOF.   Time-independent boundary conditions are extracted from domain. \nstrain_type (default = \"small\"): small strain or finite strain\n\n\n\n\n\nExplicitSolver(globdat::GlobalData, domain::Domain,\n    d0::Union{Array{Float64, 1}, PyObject}, \n    v0::Union{Array{Float64, 1}, PyObject}, \n    a0::Union{Array{Float64, 1}, PyObject}, \n    Δt::Float64, NT::Int64, \n    nn::Function,\n    Fext::Union{Array{Float64, 2}, PyObject, Missing}=missing,\n    ubd::Union{Array{Float64, 2}, PyObject, Missing}=missing,\n    abd::Union{Array{Float64, 2}, PyObject, Missing}=missing; strain_type::String = \"small\"))\n\nSimilar to ExplicitSolver; however, the constituve relation from epsilon to sigma must be provided by  the function nn.\n\n\n\n\n\nExplicitSolver(globdat::GlobalData, domain::Domain,\n    d0::Union{Array{Float64, 1}, PyObject}, \n    v0::Union{Array{Float64, 1}, PyObject}, \n    a0::Union{Array{Float64, 1}, PyObject}, \n    σ0::Union{Array{Float64, 1}, PyObject}, \n    ε0::Union{Array{Float64, 1}, PyObject}, \n    Δt::Float64, NT::Int64, \n    nn::Function,\n    Fext::Union{Array{Float64, 2}, PyObject, Missing}=missing,\n    ubd::Union{Array{Float64, 2}, PyObject, Missing}=missing,\n    abd::Union{Array{Float64, 2}, PyObject, Missing}=missing; strain_type::String = \"small\")\n\nSimilar to ExplicitSolver; however, the constitutive relation has the form \n\nsigma^n+1 = mathrmnn(epsilon^n+1 epsilon^n sigma^n)\n\nHere the strain and stress are n times 3 tensors. n is the total number of Gaussian points and can be  obtained via getNGauss(domain).\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.ExplicitSolverTime","page":"API Reference","title":"NNFEM.ExplicitSolverTime","text":"ExplicitSolverTime(Δt::Float64, NT::Int64)\n\nReturns the times for explicit solver. Boundary conditions and external forces should be given at these times.\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.GeneralizedAlphaSolver","page":"API Reference","title":"NNFEM.GeneralizedAlphaSolver","text":"GeneralizedAlphaSolver(globdat::GlobalData, domain::Domain,\n    d0::Union{Array{Float64, 1}, PyObject}, \n    v0::Union{Array{Float64, 1}, PyObject}, \n    a0::Union{Array{Float64, 1}, PyObject}, \n    Δt::Float64, NT::Int64, \n    Hs::Union{Array{Float64, 3}, Array{Float64, 2}, PyObject},\n    Fext::Union{Array{Float64, 2}, PyObject, Missing}=missing,\n    ubd::Union{Array{Float64, 2}, PyObject, Missing}=missing,\n    abd::Union{Array{Float64, 2}, PyObject, Missing}=missing; ρ::Float64 = 0.0)\n\nDifferentiable Generalized alpha scheme. This is an extension of αscheme provided in ADCME. This function does not support damping and variable time step (for efficiency). \n\nd0, v0, a0: initial full displacement, velocity, and acceleration. \nΔt: time step \nHs: linear elasticity matrix at each Gauss point \nFext: external force, mathrmNTtimes n, where n is the active dof.  The external force includes all body forces, external load forces (also called edge forces in NNFEM) and boundary acceleration-induced forces.\nubd, abd: boundary displacementt and acceleration, mathrmNTtimes m, where m is boundary DOF.  Time-independent boundary conditions are extracted from domain. \n\nGeneralizedAlphaSolver does not support finite-strain continuum yet.  \n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.GeneralizedAlphaSolverTime","page":"API Reference","title":"NNFEM.GeneralizedAlphaSolverTime","text":"GeneralizedAlphaSolverTime(Δt::Float64, NT::Int64;ρ::Float64 = 0.0)\n\nReturns the times for the generalized alpha solver. Boundary conditions and external forces should be given at these times.\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.compute_boundary_info","page":"API Reference","title":"NNFEM.compute_boundary_info","text":"compute_boundary_info(domain::Domain, globdat::GlobalData, ts::Array{Float64})\n\nComputes the boundary information ubd and abd\n\n\n\n\n\n","category":"function"},{"location":"api/#NNFEM.compute_external_force","page":"API Reference","title":"NNFEM.compute_external_force","text":"compute_external_force(domain::Domain, globdat::GlobalData, ts::Array{Float64})\n\nComputes the external force (body force, edge force and force due to boundary acceleration).\n\n\n\n\n\n","category":"function"},{"location":"representation/#Representations-of-Constitutive-Relation-1","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"","category":"section"},{"location":"representation/#Constitutive-Theory-1","page":"Representations of Constitutive Relation","title":"Constitutive Theory","text":"","category":"section"},{"location":"representation/#","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"To characterize material mechanics, we usually need to provide relations between kinematic and dynamic quantities. For example, the balance of linear momentum provides a constraint on the material mechanics. Another important relation is the constitutive relation, which describes the material's response to deformation. To describe the constitutive relations, the strain and stress tensors are useful. The strain tensor is automatic symmetric. The stress tensor can be shown to be symmetric based on the balance of angular momentum. ","category":"page"},{"location":"representation/#","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"Mathematically, let mathcalC denote the constitutive quantity, then the most general constitutive relation for mathcalC is given by a functional of the form ","category":"page"},{"location":"representation/#","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"mathcalC(X t) = mathcalF_Yin mathcalB -infty  sleq  t (rho(Y s) chi(Y s) theta(Y s) Y t)","category":"page"},{"location":"representation/#","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"Here mathcalF is the constitutive function, mathcalB is the region of influence for X. rho, chi, theta are te density, the motion, and the temperature. For pure mechanical processes, the constitutive quantity mathcalC can be the stress tensor, the heat flux or the internal energy. ","category":"page"},{"location":"representation/#","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"Not all relations are valid constitutive relations. In the following, we consider some common assumptions on the constitutive relation. ","category":"page"},{"location":"representation/#","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"Principle of Determinism. This means the current state of a material is determined tthrough the current motion and the entire motion-history of all other material points of the continuum body. \nPrinciple of Material Objectivity. This is also known as observer or frame indifference. A material equation must not depend on the choice of the reference frame or observer. An observer deduces a physical law in his or her coordinate mathbfx, and another observer, who is in another coordinate system mathbfx^*, deduces another physical law for the same physical quantities. ","category":"page"},{"location":"representation/#","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"mathbfx^* = Q(t) mathbfx + mathbfx(t) qquad Q(t)Q(t)^T = Q(t)^TQ(t)=mathbfI mathrmdet(Q(t)) = pm 1","category":"page"},{"location":"representation/#","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"Theses two laws should be consistent with each other. For example, the law might be the Newton's second law, which states that the acceleration is proportional to the external force. ","category":"page"},{"location":"representation/#","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"Non-local Materials. The physical action at the point X is determined by the action at all other points Y of the body, and the region of influence is only restricted to the neighborhood of X. This assumption allows us to describe the physical law using the Taylor series of the state variables. For example, for the motion chi(Y t), we have ","category":"page"},{"location":"representation/#","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"chi(Y t) = chi(X t) + frac11fracpartial chi(X t)partial chiDelta X +frac12(Delta X)^Tfracpartial^2 chi(X t)partial chi^2Delta X +ldots","category":"page"},{"location":"representation/#","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"note: Note\nWe can classify the material by the number of terms in the Taylor expansion above. A material is said to have grade N if its constitutive relation is described N+1 terms in the Taylor expansion. ","category":"page"},{"location":"representation/#","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"note: Note\nNonlocal constitutive relations, such as peridynamics, are also considered in literature. ","category":"page"},{"location":"representation/#","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"Material Symmetry. In the case of material symmetries, we can further reduce the general constitutive relation. For example, for hyperelasticity materials, the material symmetry reduces the constitutive relation between strain and stress to isotropic functions. ","category":"page"},{"location":"representation/#Enforcing-Physical-Constraints-in-Constitutive-Relations-1","page":"Representations of Constitutive Relation","title":"Enforcing Physical Constraints in Constitutive Relations","text":"","category":"section"},{"location":"representation/#","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"In NNFEM, we provide a set of tools to enforce physical constraints. ","category":"page"},{"location":"representation/#","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"Isotropic functions for on tensor","category":"page"},{"location":"representation/#","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"isotropic_function","category":"page"},{"location":"representation/#NNFEM.isotropic_function","page":"Representations of Constitutive Relation","title":"NNFEM.isotropic_function","text":"isotropic_function(coef::Union{Array{Float64,2}, PyObject},strain::Union{Array{Float64,2}, PyObject})\n\nIsotropic function of a symmetric tensor.\n\nT = s_0 I + s_1 A + s_2 A^2\n\nHere \n\ntextttcoef(i) = s_0 s_1 s_2\n\nA = leftbeginmatrix\nS_i1  S_i32 \nS_i32  S_i2\nendmatrixright\n\nwhere S_ij is the i-th row and j-th column of strain\n\n\n\n\n\n","category":"function"},{"location":"representation/#","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"info: Info\nTo construct a constitutive relation that has the form T = s_0(sigma_1 sigma_2)  + s_1(sigma_1 sigma_2) S  + s_2(sigma_1 sigma_2) S^2Here sigma_1 and sigma_2 are the two eigenvalues of S, we can use strain_voigt_to_tensor to extract eigenvalues.using NNFEM, ADCME\nstrain = rand(100,3)\nstrain_tensor = strain_voigt_to_tensor(strain)\ne, v = tf.linalg.eigh(strain_tensor)\ncoef = ae(e, [20,20,20,3])\nstress = isotropic_function(coef, strain)","category":"page"},{"location":"representation/#","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"Isotropic functions for two tensors","category":"page"},{"location":"representation/#","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"bi_isotropic_function","category":"page"},{"location":"representation/#NNFEM.bi_isotropic_function","page":"Representations of Constitutive Relation","title":"NNFEM.bi_isotropic_function","text":"bi_isotropic_function(coef::Union{Array{Float64,2}, PyObject},strain::Union{Array{Float64,2}, PyObject},\nstrainrate::Union{Array{Float64,2}, PyObject})\n\nIsotropic function of two symmetric tensors A and B\n\nbeginaligned\nT(A B) = gamma_0 I + gamma_1 A + gamma_2 B + gamma_3 A^2 + gamma_4 (A*B+B*A) \n + gamma_5 B^2 + gamma_6 (A^2 B + BA^2) + gamma_7 (AB^2 + B^2 A) + gamma_8 (A^2B^2+B^2A^2)\nendaligned\n\nThis is useful for rate-dependent constitutive relation. For example, \n\nsigma^n+1 = mathcalC(epsilon^n+1 dotepsilon^n+1)\n\nHere \n\ncoef: Ntimes 9 coefficient array\nstrain: Ntimes 3 strain tensor in Voigt notation\nstrainrate: Ntimes 3 strain rate tensor in Voigt notation\n\n\n\n\n\n","category":"function"},{"location":"representation/#","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"Similar to the isotropic function for one tensor, we can construct a constitutive relation that is an isotropic function of two tensors. ","category":"page"},{"location":"representation/#","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"using NNFEM, ADCME\nstrain = rand(100,3)\nstrain_rate = rand(100,3)\nstrain_tensor = strain_voigt_to_tensor(strain)\nstrain_rate_tensor = strain_voigt_to_tensor(strain_rate)\ne1, v = tf.linalg.eigh(strain_tensor)\ne2, v = tf.linalg.eigh(strain_rate_tensor)\ncoef = ae([e1 e2], [20,20,20,9])\nstress = isotropic_function(coef, strain)","category":"page"},{"location":"representation/#","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"Plasticity ","category":"page"},{"location":"representation/#","page":"Representations of Constitutive Relation","title":"Representations of Constitutive Relation","text":"consistent_tangent_matrix","category":"page"},{"location":"representation/#NNFEM.consistent_tangent_matrix","page":"Representations of Constitutive Relation","title":"NNFEM.consistent_tangent_matrix","text":"consistent_tangent_matrix(inputs::Union{Array{Float64, 2}, PyObject},Dc::Union{Array{Float64,2}, PyObject})\n\nReturns the consistent tangent matrices. The size of the return is Ntimes 3 times 3. \n\nD_c^ep = D_c - fracD_cfracpartial gpartial sigmaleft(fracpartial fpartial sigma right)^T D_c E_p + fracpartial gpartial sigma Dc left(fracpartial fpartial sigma right)^T\n\nHere inputs is a Ntimes 7 matrix, where each row is \n\nleftfracpartial gpartial sigma fracpartial fpartial sigma E_pright\n\nDc is a 3times 3 row-major matrix; each row is a linear elasticity matrix.  \n\ninfo: Info\nThe gradients with respect to both inputs and H are available. \n\n\n\n\n\n","category":"function"},{"location":"verify/#Dynamic-Problems-1","page":"Dynamic Problems","title":"Dynamic Problems","text":"","category":"section"},{"location":"verify/#","page":"Dynamic Problems","title":"Dynamic Problems","text":"NNFEM can be used to solve the folowing dynamical problem","category":"page"},{"location":"verify/#","page":"Dynamic Problems","title":"Dynamic Problems","text":"ddot u - textdivsigma  = f xin Omega tag1","category":"page"},{"location":"verify/#","page":"Dynamic Problems","title":"Dynamic Problems","text":"where u is the 2D displacement vector, sigma is the stress, and f is the body force. The dynamical equation is supplemented with two kinds of boundary conditions: Dirichlet boundary conditions and Neumann boundary conditions. For each type of conditions, we consider two types: time-dependent and time-independent. The following matrix shows all possible boundary conditions supported by NNFEM. ","category":"page"},{"location":"verify/#","page":"Dynamic Problems","title":"Dynamic Problems","text":"|                  | Dirichlet                              | Neumann                                       | | –––––––– | ––––––––––––––––––– | ––––––––––––––––––––––- | | Time-independent | u(xt) = u_1(x) xin Gamma_D^1   | sigma(xt)n(x) = t_1(x) xin Gamma_N^1 | | Time-dependent   | u(xt) = u_2(xt) xin Gamma_D^2 | sigma(xt)n(x) = t_2(x) xin Gamma_N^2 |","category":"page"},{"location":"verify/#","page":"Dynamic Problems","title":"Dynamic Problems","text":"The weak form of Equation 1 can be written as ","category":"page"},{"location":"verify/#","page":"Dynamic Problems","title":"Dynamic Problems","text":"int_Omega u delta u dx  + int_Omega sigma delta epsilon dx = int_Omega f delta u dx + int_Gamma_N t delta u dx tag2","category":"page"},{"location":"verify/#","page":"Dynamic Problems","title":"Dynamic Problems","text":"Here ","category":"page"},{"location":"verify/#","page":"Dynamic Problems","title":"Dynamic Problems","text":"int_Gamma_N t delta u dx =int_Gamma_N^1 t_1 delta u dx + int_Gamma_N^2 t_2 delta u dx \n\nIn NNFEM the boundary information are marked in EBC and FBC arrays in the geometry information Domain respectively These arrays have size n_vtimes 2 corresponding to n_v nodes and x-y-directions -1 represents time-independent boundaries and -2 represents time-dependent boundaries Time indepdent boundary conditions g and fext are precomputed and fed to Domain while time independent bounary conditions can be evaluated online with EBC_func and FBC_func in GlobalData In the case the external load is provided as t(xt) = sigma(xt)n(x) we can use Edge_func and Edge_Traction_Data to provide the information instead of  FBC_func \n\nIf we express Equation 2 in terms of matrices we have\n\nM ddotmathbfu + K (mathbfu) = mathbff + mathbft","category":"page"},{"location":"verify/#","page":"Dynamic Problems","title":"Dynamic Problems","text":"Here K(mathbfu) can be nonlinear. ","category":"page"},{"location":"verify/#","page":"Dynamic Problems","title":"Dynamic Problems","text":"There are two solver implemented in NNFEM: the explicit solver and the generalized alpha solver. Both solvers support automatic differentiation for a linear K. The explicit solver also supports automatic differentiation for nonlinear K. ","category":"page"},{"location":"verify/#","page":"Dynamic Problems","title":"Dynamic Problems","text":"To get started, you can study the following examples. Most likely you only need to modify the script to meet your own needs. ","category":"page"},{"location":"ex_ad/#Automatic-Differentiation-1","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"","category":"section"},{"location":"ex_ad/#Data-Structure-1","page":"Automatic Differentiation","title":"Data Structure","text":"","category":"section"},{"location":"ex_ad/#","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"To facilitate implementing custom operators, we made a shared library for storing all FEM data structures that do not participate in automatic differentiation. In the shared library, there are mainly two data structures","category":"page"},{"location":"ex_ad/#","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"domain\nclass Domain{\npublic:\n    MatrixXd nodes;\n    int neqs;\n    int nnodes;\n    int neles;\n    int ngauss;\n};\nHere \nnodes: coordinates of all nodes, a n_vtimes 2 matrix.\nneqs: number of all active DOFs among 2n_v equations.\nnnodes: number of nodes, n_v\nneles: number of elements n_e, which is also the size of mesh vector (see below). \nngauss: total number of Gauss points. It is equal to getNGauss(domain) in Julia. \ncontinuum\nclass Continuum{\npublic:\n    VectorXi elnodes;\n    MatrixXd coords;\n    vector<MatrixXd> dhdx;\n    Eigen::VectorXd weights;\n    vector<VectorXd> hs;\n    VectorXi el_eqns_active;\n    VectorXi el_eqns;\n    int nGauss;\n    int nnodes;\n\n    Continuum(const int *elnodes_, const double *coords_, \n        const double *dhdx_, const double *weights_, const double *hs_, int n_nodes, int n_gauss,\n        const int *el_eqns_active, int n_active, const int *el_eqns);\n};\nelnodes: the global index of the nodes for this specific element, n^e_v.\ncoords: coordinates of the element vertices, it is of size n^e_vtimes2\ndhdx: a list (length = n_g) of  n_v^etimes 2 matrices, representing the contribution of  nabla phi_i(x) to each nodes. n_g is the number of Gauss points.\nweights: weight vector of Gauss quadrature\nhs: a list (length = n_g) of length n_v^e  vector representing the contribution of  phi_i(x) to each nodes. n_g is the number of Gauss points.\nel_eqns: global indices of active DOFs for each vertex and each direction (u and v). It has length 2n_v^e and each value is within 01ldots 2n_v-1. \nel_eqns_active: local indices of actives DOFs for each vertex and each direction (u and v). It has length at most 2n_v^e and each value is within 01ldots 2n_v^e-1. A typical  usuage is \n// fint: local internal force\n// Fint: global internal force\nfor(int i = 0; i< elem.el_eqns_active.size(); i++){\n  int ix = elem.el_eqns_active[i];\n  int eix = elem.el_eqns[ix];\n  Fint[eix] += fint[ix];\n}","category":"page"},{"location":"ex_ad/#A-Typical-Simulation-Routine-1","page":"Automatic Differentiation","title":"A Typical Simulation Routine","text":"","category":"section"},{"location":"ex_ad/#","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"Make an instance of Domain and GlobalData\nAssemble mass matrices using assembleMassMatrix!\nCompute boundary information using compute_boundary_info\nCompute the external force (body force + external load force + boundary-acceleration-induced force) using compute_external_force\nCompute initial a_0 using SolverInitial\nInvoke solver ExplicitSolver or GeneralizedAlphaSolver","category":"page"},{"location":"ex_ad/#Examples-1","page":"Automatic Differentiation","title":"Examples","text":"","category":"section"},{"location":"ex_ad/#","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"using NNFEM\n\n\ndomain = example_domain()\nglobaldata = example_global_data(domain)\ninit_nnfem(domain)  # IMPORTANT: initialize the NNFEM session\n\n# total number of gauss points\nngauss = length(domain.elements[1].weights) * domain.neles\nH = constant(rand(ngauss, 3, 3)) # linear elasticity matrix \nK = s_compute_stiffness_matrix(H, domain) # stiffness matrix\nassembleMassMatrix!(globaldata, domain)\nM = SparseTensor(globaldata.M) # mass matrix\n\na = 0.1\nb = 0.2\nA = a * K + b * M\n\nrhs = constant(rand(size(K,2)))\nsol = A\\rhs","category":"page"},{"location":"ex_ad/#","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"sol can be differentiated with respect to rhs","category":"page"},{"location":"ex_ad/#","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"julia> gradients(sum(sol), rhs)\nPyObject <tf.Tensor 'gradients_1/IdentityN_12_grad/SparseSolverGrad:3' shape=(242,) dtype=float64>","category":"page"},{"location":"ex_ad/#","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"sol can be differentiated with respect to H","category":"page"},{"location":"ex_ad/#","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"julia> gradients(sum(sol), H)\nPyObject <tf.Tensor 'gradients_2/IdentityN_11_grad/SmallContinuumStiffnessGrad:0' shape=(400, 3, 3) dtype=float64>","category":"page"},{"location":"ex_ad/#","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"","category":"page"},{"location":"ex_ad/#","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"Given the stress stress, we can compute the internal force and evaluate its gradients","category":"page"},{"location":"ex_ad/#","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"stress = constant(rand(ngauss, 3))\nfint = s_compute_internal_force_term(stress, domain)\ngradients(sum(fint), stress)","category":"page"},{"location":"ex_ad/#","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"Expected","category":"page"},{"location":"ex_ad/#","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"PyObject <tf.Tensor 'gradients_3/IdentityN_13_grad/SmallContinuumFintGrad:0' shape=(400, 3) dtype=float64>","category":"page"},{"location":"ex_ad/#","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"","category":"page"},{"location":"ex_ad/#","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"Given the displacement, we can evaluate the strain and evaluate the gradients","category":"page"},{"location":"ex_ad/#","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"state = constant(rand(domain.nnodes*2))\nstrain = s_eval_strain_on_gauss_points(state, domain)\ngradients(sum(strain), state)","category":"page"},{"location":"ex_ad/#","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"Expected","category":"page"},{"location":"ex_ad/#","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"PyObject <tf.Tensor 'gradients_4/IdentityN_14_grad/SmallContinuumStrainGrad:0' shape=(242,) dtype=float64>","category":"page"},{"location":"ex_simulation/#Simulaton-Code-Structure-1","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"","category":"section"},{"location":"ex_simulation/#","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"We use the Newmark method or the generalized alpha scheme to solve the dynamics equation numerically. ","category":"page"},{"location":"ex_simulation/#","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"mddot mathbfu + gammadotmathbfu + kmathbfu = mathbff","category":"page"},{"location":"ex_simulation/#","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"The discretized form is ","category":"page"},{"location":"ex_simulation/#","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"Mmathbfa + Cmathbf v + K mathbf d = mathbf F","category":"page"},{"location":"ex_simulation/#","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"For a detailed description of the generalized alpha scheme, see this post. ","category":"page"},{"location":"ex_simulation/#","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"NNFEM.jl supports two types of boundary conditions, the Dirichlet boundary condition and the Neumann boundary condition. Both boundary conditions can be time independent or dependent. Read [] for how to specify time dependent boundary conditions and [] for how to specify time independent boundary conditions. ","category":"page"},{"location":"ex_simulation/#","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"Here is a script for simulation using an explicit solver. ","category":"page"},{"location":"ex_simulation/#","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"NT = 100\nΔt = 1.0e-2\nT = NT * Δt\n\nm, n =  20, 10\nh = 0.1\n\n# Create a very simple mesh\nelements = SmallStrainContinuum[]\nprop = Dict(\"name\"=> \"PlaneStrain\", \"rho\"=> 0.0876584, \"E\"=>0.07180760098, \"nu\"=>0.4)\ncoords = zeros((m+1)*(n+1), 2)\nfor j = 1:n\n    for i = 1:m\n        idx = (m+1)*(j-1)+i \n        elnodes = [idx; idx+1; idx+1+m+1; idx+m+1]\n        ngp = 3\n        nodes = [\n            (i-1)*h (j-1)*h\n            i*h (j-1)*h\n            i*h j*h\n            (i-1)*h j*h\n        ]\n        coords[elnodes, :] = nodes\n        push!(elements, SmallStrainContinuum(nodes, elnodes, prop, ngp))\n    end\nend\n\n# fixed on the bottom, push on the right\nEBC = zeros(Int64, (m+1)*(n+1), 2)\nFBC = zeros(Int64, (m+1)*(n+1), 2)\ng = zeros((m+1)*(n+1), 2)\nf = zeros((m+1)*(n+1), 2)\nfor i = 1:m+1\n    for j = 1:n+1\n        idx = (j-1)*(m+1) + i \n        if j==n+1\n            EBC[idx,:] .= -1\n        end\n        if i==m+1 && j!=n+1\n            FBC[idx,1] = -1\n            f[idx,1] = -0.001\n        end\n    end\nend\nndims = 2\ndomain = Domain(coords, elements, ndims, EBC, g, FBC, f)\n\n\nDstate = zeros(domain.neqs)\nstate = zeros(domain.neqs)\nvelo = zeros(domain.neqs)\nacce = zeros(domain.neqs)\ngt = nothing\nft = nothing\nglobdat = GlobalData(state, Dstate, velo, acce, domain.neqs, gt, ft)\n\n\nassembleMassMatrix!(globdat, domain)\nupdateStates!(domain, globdat)\n\nfor i = 1:NT\n@info i \n    global globdat, domain = ExplicitSolverStep(globdat, domain, Δt)\nend\nvisualize_displacement(domain)\nvisualize_von_mises_stress(domain)","category":"page"},{"location":"ex_simulation/#","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"The explicit solver is implemented as follows","category":"page"},{"location":"ex_simulation/#","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"function ExplicitSolverStep(globdat::GlobalData, domain::Domain, Δt::Float64)\n    u = globdat.state[:]\n    ∂u  = globdat.velo[:]\n    ∂∂u = globdat.acce[:]\n\n    fext = getExternalForce!(domain, globdat)\n\n    u += Δt*∂u + 0.5*Δt*Δt*∂∂u\n    ∂u += 0.5*Δt * ∂∂u\n    \n    domain.state[domain.eq_to_dof] = u[:]\n    fint  = assembleInternalForce( globdat, domain, Δt)\n    ∂∂up = globdat.M\\(fext - fint)\n\n    ∂u += 0.5 * Δt * ∂∂up\n\n    globdat.Dstate = globdat.state[:]\n    globdat.state = u[:]\n    globdat.velo = ∂u[:]\n    globdat.acce = ∂∂up[:]\n    globdat.time  += Δt\n    commitHistory(domain)\n    updateStates!(domain, globdat)\n\n    return globdat, domain\nend","category":"page"},{"location":"ex_simulation/#","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"We show the follow chart of the implementation. Note inside the ExplicitSolverStep function, the data is exchanged between globdat and domain. In general, globdat saves only the active components of the degrees of freedom (excluding Dirichlet boundary nodes) while domain maintains the full information. ","category":"page"},{"location":"ex_simulation/#","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"(Image: image-20200409172855057)","category":"page"},{"location":"ex_simulation/#Updating-the-Boundary-Conditions-1","page":"Simulaton Code Structure","title":"Updating the Boundary Conditions","text":"","category":"section"},{"location":"ex_simulation/#","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"We give a short description on how the boundary conditions are tackled in NNFEM. In general, we have two kinds of boundary conditions; namely, they are Dirichlet boundary conditions (also known as essential boundary conditions) and Neumann boundary conditions (also known as natural boundary conditions). They can be both time dependent or time independent. ","category":"page"},{"location":"ex_simulation/#Dirichlet-Boundary-Conditions-1","page":"Simulaton Code Structure","title":"Dirichlet Boundary Conditions","text":"","category":"section"},{"location":"ex_simulation/#","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"The basic idea for tackling Dirichlet boundary conditions is to trim the coefficient matrices M and K, and update the right hand side force vectors (consider a linear problem)","category":"page"},{"location":"ex_simulation/#","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"M ddot mathbfu + K mathbfu = mathbff","category":"page"},{"location":"ex_simulation/#","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"We have","category":"page"},{"location":"ex_simulation/#","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"M_II ddot mathbfu_I + M_ID ddot mathbfu_D + K_I mathbfu = mathbff","category":"page"},{"location":"ex_simulation/#","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"Here I stands for the active DOF, and D stands for time-dependent Dirichlet boundary condition DOF. Note ddotmathbfu = mathbf0 for time-independent Dirichlet nodes. ","category":"page"},{"location":"ex_simulation/#","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"assembleMassMatrix! computes and stores M_{II} and M_{ID} in GlobalData. In the time stepping, when getExternalForce! is called, M_ID ddot mathbfu_D is computed and substracted from right hand side. ","category":"page"},{"location":"ex_simulation/#","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"For the stiffness matrix K_I mathbfu, in every iteration, given a candidate mathbfu, assembleStiffAndForce computes ","category":"page"},{"location":"ex_simulation/#","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"K_II K_I mathbfu","category":"page"},{"location":"ex_simulation/#","page":"Simulaton Code Structure","title":"Simulaton Code Structure","text":"This information is sufficient to solve for ddot mathbfu or mathbfu. ","category":"page"},{"location":"#Getting-Started-1","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"#","page":"Getting Started","title":"Getting Started","text":"Under Construction. ","category":"page"},{"location":"qanda/#Q-and-A-1","page":"Q&A","title":"Q&A","text":"","category":"section"},{"location":"qanda/#","page":"Q&A","title":"Q&A","text":"Q: How can I get the number of Dirichlet boundary nodes (including directions)?","category":"page"},{"location":"qanda/#","page":"Q&A","title":"Q&A","text":"sum(domain.EBC[:].!=0)","category":"page"}]
}
